"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useSimulador.ts":
/*!***********************************!*\
  !*** ./src/hooks/useSimulador.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSimulador: () => (/* binding */ useSimulador)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst useSimulador = ()=>{\n    const [simulacao, setSimulacao] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        valorBruto: 0,\n        desconto: 0,\n        valorNegociado: 0,\n        formasPagamento: [],\n        valorRecebidoTotal: 0,\n        descontoReal: 0,\n        valorRestante: 0,\n        travamentos: {\n            valorNegociado: false,\n            descontoReal: false,\n            limiteDescontoReal: 25\n        }\n    });\n    // Prioridade para redistribuição de valores\n    const PRIORIDADE_FORMAS = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useSimulador.useMemo[PRIORIDADE_FORMAS]\": ()=>[\n                'ENTRADA',\n                'BOLETO',\n                'FINANCEIRA',\n                'CARTAO'\n            ]\n    }[\"useSimulador.useMemo[PRIORIDADE_FORMAS]\"], []);\n    const calcularValorRecebidoForma = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[calcularValorRecebidoForma]\": (forma)=>{\n            console.log('Calculando valor recebido para:', forma);\n            switch(forma.tipo){\n                case 'ENTRADA':\n                    return forma.valor;\n                case 'FINANCEIRA':\n                    {\n                        if (!forma.parcelas || !forma.taxaJuros) return forma.valor;\n                        const i = forma.taxaJuros / 100;\n                        const parcelas = forma.parcelas;\n                        const valorPresente = forma.valor / Math.pow(1 + i, parcelas);\n                        console.log(\"Financeira: valor=\".concat(forma.valor, \", parcelas=\").concat(parcelas, \", taxa=\").concat(forma.taxaJuros, \"%, VP=\").concat(valorPresente));\n                        return valorPresente;\n                    }\n                case 'CARTAO':\n                    {\n                        if (!forma.deflacao || !forma.jurosAntecipacao || !forma.parcelas) return forma.valor;\n                        const fatorDeflacao = 1 - forma.deflacao / 100;\n                        const fatorJuros = 1 - forma.jurosAntecipacao / 100 * forma.parcelas;\n                        const valorRecebido = forma.valor * fatorDeflacao * fatorJuros;\n                        console.log(\"Cart\\xe3o: valor=\".concat(forma.valor, \", defla\\xe7\\xe3o=\").concat(forma.deflacao, \"%, juros=\").concat(forma.jurosAntecipacao, \"%, VR=\").concat(valorRecebido));\n                        return valorRecebido;\n                    }\n                case 'BOLETO':\n                    {\n                        if (!forma.parcelas || !forma.custoCapital) return forma.valor;\n                        const ic = forma.custoCapital / 100;\n                        const valorPresenteBoleto = forma.valor / Math.pow(1 + ic, forma.parcelas);\n                        console.log(\"Boleto: valor=\".concat(forma.valor, \", parcelas=\").concat(forma.parcelas, \", custo=\").concat(forma.custoCapital, \"%, VP=\").concat(valorPresenteBoleto));\n                        return valorPresenteBoleto;\n                    }\n                default:\n                    return forma.valor;\n            }\n        }\n    }[\"useSimulador.useCallback[calcularValorRecebidoForma]\"], []);\n    const redistribuirValores = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[redistribuirValores]\": (novoValorNegociado, formasAtuais)=>{\n            console.log('Redistribuindo valores. Novo valor negociado:', novoValorNegociado);\n            const somaAtual = formasAtuais.reduce({\n                \"useSimulador.useCallback[redistribuirValores].somaAtual\": (acc, forma)=>acc + forma.valor\n            }[\"useSimulador.useCallback[redistribuirValores].somaAtual\"], 0);\n            const diferenca = novoValorNegociado - somaAtual;\n            if (Math.abs(diferenca) < 0.01) {\n                return formasAtuais; // Não há diferença significativa\n            }\n            console.log('Diferença a redistribuir:', diferenca);\n            // Separar formas travadas e não travadas\n            const formasTravadas = formasAtuais.filter({\n                \"useSimulador.useCallback[redistribuirValores].formasTravadas\": (forma)=>forma.travado\n            }[\"useSimulador.useCallback[redistribuirValores].formasTravadas\"]);\n            const formasNaoTravadas = formasAtuais.filter({\n                \"useSimulador.useCallback[redistribuirValores].formasNaoTravadas\": (forma)=>!forma.travado\n            }[\"useSimulador.useCallback[redistribuirValores].formasNaoTravadas\"]);\n            // Se todas estão travadas, não podemos redistribuir\n            if (formasNaoTravadas.length === 0) {\n                console.log('Todas as formas estão travadas');\n                return null; // Indica erro\n            }\n            // Ordenar formas não travadas por prioridade\n            const formasOrdenadas = formasNaoTravadas.sort({\n                \"useSimulador.useCallback[redistribuirValores].formasOrdenadas\": (a, b)=>{\n                    const prioridadeA = PRIORIDADE_FORMAS.indexOf(a.tipo);\n                    const prioridadeB = PRIORIDADE_FORMAS.indexOf(b.tipo);\n                    return prioridadeA - prioridadeB;\n                }\n            }[\"useSimulador.useCallback[redistribuirValores].formasOrdenadas\"]);\n            console.log('Formas ordenadas por prioridade:', formasOrdenadas.map({\n                \"useSimulador.useCallback[redistribuirValores]\": (f)=>f.tipo\n            }[\"useSimulador.useCallback[redistribuirValores]\"]));\n            // Redistribuir a diferença: apenas a primeira forma na ordem de prioridade absorve toda a diferença\n            const novasFormas = [\n                ...formasAtuais\n            ];\n            // Verificar se todas as formas não travadas têm valor zero\n            const somaFormasNaoTravadas = formasOrdenadas.reduce({\n                \"useSimulador.useCallback[redistribuirValores].somaFormasNaoTravadas\": (acc, forma)=>acc + forma.valor\n            }[\"useSimulador.useCallback[redistribuirValores].somaFormasNaoTravadas\"], 0);\n            if (somaFormasNaoTravadas === 0) {\n                // Se todas as formas não travadas têm valor 0, distribui igualmente\n                console.log('Todas as formas não travadas têm valor zero, distribuindo igualmente');\n                const ajustePorForma = diferenca / formasOrdenadas.length;\n                formasOrdenadas.forEach({\n                    \"useSimulador.useCallback[redistribuirValores]\": (forma)=>{\n                        const formaIndex = novasFormas.findIndex({\n                            \"useSimulador.useCallback[redistribuirValores].formaIndex\": (f)=>f.id === forma.id\n                        }[\"useSimulador.useCallback[redistribuirValores].formaIndex\"]);\n                        const novoValor = ajustePorForma;\n                        novasFormas[formaIndex] = {\n                            ...novasFormas[formaIndex],\n                            valor: Math.max(0, novoValor)\n                        };\n                        console.log(\"Forma \".concat(forma.tipo, \" ajustada para: \").concat(novoValor, \" (final: \").concat(Math.max(0, novoValor), \")\"));\n                    }\n                }[\"useSimulador.useCallback[redistribuirValores]\"]);\n            } else {\n                // Apenas a primeira forma não travada na ordem de prioridade absorve toda a diferença\n                console.log('Ajustando apenas a primeira forma na ordem de prioridade');\n                const primeiraForma = formasOrdenadas[0];\n                const formaIndex = novasFormas.findIndex({\n                    \"useSimulador.useCallback[redistribuirValores].formaIndex\": (f)=>f.id === primeiraForma.id\n                }[\"useSimulador.useCallback[redistribuirValores].formaIndex\"]);\n                const valorCalculado = primeiraForma.valor + diferenca;\n                const novoValor = Math.max(0, valorCalculado);\n                novasFormas[formaIndex] = {\n                    ...novasFormas[formaIndex],\n                    valor: novoValor\n                };\n                console.log(\"Forma \".concat(primeiraForma.tipo, \" ajustada de \").concat(primeiraForma.valor, \" para \").concat(valorCalculado, \" (final: \").concat(novoValor, \")\"));\n                // Se o valor ficou negativo, indicar impossibilidade\n                if (valorCalculado < 0) {\n                    console.log(\"⚠️ Valor negativo detectado (\".concat(valorCalculado, \"), pode estar no limite de desconto real\"));\n                }\n            }\n            return novasFormas;\n        }\n    }[\"useSimulador.useCallback[redistribuirValores]\"], [\n        PRIORIDADE_FORMAS\n    ]);\n    const recalcularSimulacao = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[recalcularSimulacao]\": (updates)=>{\n            console.log('Recalculando simulação com updates:', updates);\n            setSimulacao({\n                \"useSimulador.useCallback[recalcularSimulacao]\": (prev)=>{\n                    const updated = {\n                        ...prev,\n                        ...updates\n                    };\n                    // Lógica de travamento do valor negociado\n                    if (updated.travamentos.valorNegociado) {\n                        // Se valor negociado está travado, ajusta o desconto quando valor bruto muda\n                        if (updates.valorBruto !== undefined && updates.valorBruto > 0) {\n                            updated.desconto = (updated.valorBruto - updated.valorNegociado) / updated.valorBruto * 100;\n                        }\n                    } else {\n                        // Comportamento normal: calcula valor negociado baseado no desconto\n                        updated.valorNegociado = updated.valorBruto * (1 - updated.desconto / 100);\n                    }\n                    updated.formasPagamento = updated.formasPagamento.map({\n                        \"useSimulador.useCallback[recalcularSimulacao]\": (forma)=>({\n                                ...forma,\n                                valorRecebido: calcularValorRecebidoForma(forma)\n                            })\n                    }[\"useSimulador.useCallback[recalcularSimulacao]\"]);\n                    updated.valorRecebidoTotal = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[recalcularSimulacao]\": (acc, forma)=>acc + forma.valorRecebido\n                    }[\"useSimulador.useCallback[recalcularSimulacao]\"], 0);\n                    updated.descontoReal = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorRecebidoTotal) / updated.valorBruto * 100 : 0;\n                    const somaFormas = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[recalcularSimulacao].somaFormas\": (acc, forma)=>acc + forma.valor\n                    }[\"useSimulador.useCallback[recalcularSimulacao].somaFormas\"], 0);\n                    updated.valorRestante = updated.valorNegociado - somaFormas;\n                    console.log('Simulação atualizada:', updated);\n                    return updated;\n                }\n            }[\"useSimulador.useCallback[recalcularSimulacao]\"]);\n        }\n    }[\"useSimulador.useCallback[recalcularSimulacao]\"], [\n        calcularValorRecebidoForma\n    ]);\n    const editarValorNegociado = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[editarValorNegociado]\": (novoValor)=>{\n            console.log('Editando valor negociado para:', novoValor);\n            setSimulacao({\n                \"useSimulador.useCallback[editarValorNegociado]\": (prev)=>{\n                    const formasRedistribuidas = redistribuirValores(novoValor, prev.formasPagamento);\n                    if (!formasRedistribuidas) {\n                        alert('Não é possível alterar o valor. Todas as formas de pagamento estão travadas.');\n                        return prev;\n                    }\n                    const updated = {\n                        ...prev,\n                        valorNegociado: novoValor,\n                        formasPagamento: formasRedistribuidas.map({\n                            \"useSimulador.useCallback[editarValorNegociado]\": (forma)=>({\n                                    ...forma,\n                                    valorRecebido: calcularValorRecebidoForma(forma)\n                                })\n                        }[\"useSimulador.useCallback[editarValorNegociado]\"])\n                    };\n                    // Recalcular desconto\n                    updated.desconto = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorNegociado) / updated.valorBruto * 100 : 0;\n                    updated.valorRecebidoTotal = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[editarValorNegociado]\": (acc, forma)=>acc + forma.valorRecebido\n                    }[\"useSimulador.useCallback[editarValorNegociado]\"], 0);\n                    updated.descontoReal = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorRecebidoTotal) / updated.valorBruto * 100 : 0;\n                    const somaFormas = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[editarValorNegociado].somaFormas\": (acc, forma)=>acc + forma.valor\n                    }[\"useSimulador.useCallback[editarValorNegociado].somaFormas\"], 0);\n                    updated.valorRestante = updated.valorNegociado - somaFormas;\n                    return updated;\n                }\n            }[\"useSimulador.useCallback[editarValorNegociado]\"]);\n        }\n    }[\"useSimulador.useCallback[editarValorNegociado]\"], [\n        redistribuirValores,\n        calcularValorRecebidoForma\n    ]);\n    const editarDescontoReal = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[editarDescontoReal]\": (novoDescontoReal)=>{\n            console.log('Editando desconto real para:', novoDescontoReal);\n            setSimulacao({\n                \"useSimulador.useCallback[editarDescontoReal]\": (prev)=>{\n                    // Função auxiliar para calcular o desconto real dado um valor negociado\n                    const calcularDescontoRealParaValor = {\n                        \"useSimulador.useCallback[editarDescontoReal].calcularDescontoRealParaValor\": (valorNegociado)=>{\n                            const formasTemp = redistribuirValores(valorNegociado, prev.formasPagamento);\n                            if (!formasTemp) return -1; // Indica erro\n                            const valorRecebidoTemp = formasTemp.reduce({\n                                \"useSimulador.useCallback[editarDescontoReal].calcularDescontoRealParaValor.valorRecebidoTemp\": (acc, forma)=>{\n                                    const formaComRecebido = {\n                                        ...forma,\n                                        valorRecebido: calcularValorRecebidoForma(forma)\n                                    };\n                                    return acc + formaComRecebido.valorRecebido;\n                                }\n                            }[\"useSimulador.useCallback[editarDescontoReal].calcularDescontoRealParaValor.valorRecebidoTemp\"], 0);\n                            return prev.valorBruto > 0 ? (prev.valorBruto - valorRecebidoTemp) / prev.valorBruto * 100 : 0;\n                        }\n                    }[\"useSimulador.useCallback[editarDescontoReal].calcularDescontoRealParaValor\"];\n                    // Busca binária para encontrar o valor negociado que resulta no desconto real desejado\n                    let valorMin = 0;\n                    let valorMax = prev.valorBruto;\n                    let valorNegociadoOtimo = prev.valorNegociado;\n                    let melhorDiferenca = Infinity;\n                    let melhorDesconto = prev.descontoReal;\n                    console.log(\"\\uD83C\\uDFAF Iniciando busca bin\\xe1ria para desconto real: \".concat(novoDescontoReal, \"%\"));\n                    console.log(\"Desconto real atual: \".concat(prev.descontoReal, \"%\"));\n                    console.log(\"Intervalo inicial: \".concat(valorMin, \" - \").concat(valorMax));\n                    // Máximo de 25 iterações para maior precisão\n                    for(let i = 0; i < 25; i++){\n                        const valorTeste = (valorMin + valorMax) / 2;\n                        const descontoRealCalculado = calcularDescontoRealParaValor(valorTeste);\n                        console.log(\"Itera\\xe7\\xe3o \".concat(i + 1, \": valorTeste=\").concat(valorTeste.toFixed(2), \", desconto=\").concat(descontoRealCalculado.toFixed(2), \"%\"));\n                        if (descontoRealCalculado === -1) {\n                            // Erro na redistribuição, tentar valor maior\n                            console.log('❌ Erro na redistribuição, ajustando valor mínimo');\n                            valorMin = valorTeste;\n                            continue;\n                        }\n                        const diferenca = Math.abs(descontoRealCalculado - novoDescontoReal);\n                        // Se encontrou um resultado melhor, guardar\n                        if (diferenca < melhorDiferenca) {\n                            melhorDiferenca = diferenca;\n                            valorNegociadoOtimo = valorTeste;\n                            melhorDesconto = descontoRealCalculado;\n                            console.log(\"✅ Novo melhor resultado: desconto=\".concat(melhorDesconto.toFixed(2), \"%, diferen\\xe7a=\").concat(melhorDiferenca.toFixed(2)));\n                        }\n                        // Se a diferença é muito pequena, parar\n                        if (diferenca < 0.05) {\n                            console.log(\"\\uD83C\\uDFAF Precis\\xe3o atingida! Parando busca.\");\n                            break;\n                        }\n                        // Detectar se estamos no limite físico\n                        if (i > 10 && melhorDiferenca > 2) {\n                            console.log(\"⚠️ Poss\\xedvel limite f\\xedsico detectado. Melhor desconto poss\\xedvel: \".concat(melhorDesconto.toFixed(2), \"%\"));\n                            break;\n                        }\n                        // Ajustar os limites da busca\n                        if (descontoRealCalculado < novoDescontoReal) {\n                            // Desconto calculado é menor que o desejado, precisamos diminuir valor negociado\n                            valorMax = valorTeste;\n                            console.log(\"\\uD83D\\uDCC9 Desconto baixo (\".concat(descontoRealCalculado.toFixed(2), \"% < \").concat(novoDescontoReal, \"%), diminuindo valorMax para \").concat(valorMax.toFixed(2)));\n                        } else {\n                            // Desconto calculado é maior que o desejado, precisamos aumentar valor negociado\n                            valorMin = valorTeste;\n                            console.log(\"\\uD83D\\uDCC8 Desconto alto (\".concat(descontoRealCalculado.toFixed(2), \"% > \").concat(novoDescontoReal, \"%), aumentando valorMin para \").concat(valorMin.toFixed(2)));\n                        }\n                        // Verificar se o intervalo ficou muito pequeno\n                        if (Math.abs(valorMax - valorMin) < 100) {\n                            console.log(\"\\uD83D\\uDD0D Intervalo muito pequeno (\".concat(Math.abs(valorMax - valorMin).toFixed(2), \"), finalizando busca\"));\n                            break;\n                        }\n                    }\n                    console.log(\"\\uD83C\\uDFC1 Busca finalizada:\");\n                    console.log(\"   Valor negociado \\xf3timo: \".concat(valorNegociadoOtimo.toFixed(2)));\n                    console.log(\"   Desconto real resultante: \".concat(melhorDesconto.toFixed(2), \"%\"));\n                    console.log(\"   Diferen\\xe7a do objetivo: \".concat(melhorDiferenca.toFixed(2)));\n                    // Se a diferença ainda é muito grande, avisar o usuário\n                    if (melhorDiferenca > 1) {\n                        console.log(\"⚠️ N\\xe3o foi poss\\xedvel atingir exatamente \".concat(novoDescontoReal, \"%. Melhor resultado: \").concat(melhorDesconto.toFixed(1), \"%\"));\n                        const confirmar = confirm(\"N\\xe3o foi poss\\xedvel atingir exatamente \".concat(novoDescontoReal, \"% de desconto real.\\nMelhor resultado poss\\xedvel: \").concat(melhorDesconto.toFixed(1), \"%\\n\\nDeseja aplicar mesmo assim?\"));\n                        if (!confirmar) {\n                            return prev;\n                        }\n                    }\n                    // Aplicar o valor negociado ótimo encontrado\n                    const formasRedistribuidas = redistribuirValores(valorNegociadoOtimo, prev.formasPagamento);\n                    if (!formasRedistribuidas) {\n                        alert('Não é possível alterar o desconto real. Todas as formas de pagamento estão travadas.');\n                        return prev;\n                    }\n                    const updated = {\n                        ...prev,\n                        valorNegociado: valorNegociadoOtimo,\n                        formasPagamento: formasRedistribuidas.map({\n                            \"useSimulador.useCallback[editarDescontoReal]\": (forma)=>({\n                                    ...forma,\n                                    valorRecebido: calcularValorRecebidoForma(forma)\n                                })\n                        }[\"useSimulador.useCallback[editarDescontoReal]\"])\n                    };\n                    // Recalcular valores derivados\n                    updated.valorRecebidoTotal = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[editarDescontoReal]\": (acc, forma)=>acc + forma.valorRecebido\n                    }[\"useSimulador.useCallback[editarDescontoReal]\"], 0);\n                    updated.descontoReal = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorRecebidoTotal) / updated.valorBruto * 100 : 0;\n                    const somaFormas = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[editarDescontoReal].somaFormas\": (acc, forma)=>acc + forma.valor\n                    }[\"useSimulador.useCallback[editarDescontoReal].somaFormas\"], 0);\n                    updated.valorRestante = updated.valorNegociado - somaFormas;\n                    console.log('Simulação atualizada via desconto real:', updated);\n                    console.log(\"Desconto real resultante: \".concat(updated.descontoReal, \"%\"));\n                    return updated;\n                }\n            }[\"useSimulador.useCallback[editarDescontoReal]\"]);\n        }\n    }[\"useSimulador.useCallback[editarDescontoReal]\"], [\n        redistribuirValores,\n        calcularValorRecebidoForma\n    ]);\n    const editarValorBruto = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[editarValorBruto]\": (novoValor)=>{\n            console.log('Editando valor bruto para:', novoValor);\n            recalcularSimulacao({\n                valorBruto: novoValor\n            });\n        }\n    }[\"useSimulador.useCallback[editarValorBruto]\"], [\n        recalcularSimulacao\n    ]);\n    const adicionarForma = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[adicionarForma]\": (forma)=>{\n            console.log('Adicionando forma:', forma);\n            setSimulacao({\n                \"useSimulador.useCallback[adicionarForma]\": (prev)=>{\n                    // Verificar travamento de desconto real\n                    if (prev.travamentos.descontoReal) {\n                        const novaFormaTemp = {\n                            ...forma,\n                            id: Date.now().toString(),\n                            valorRecebido: 0\n                        };\n                        novaFormaTemp.valorRecebido = calcularValorRecebidoForma(novaFormaTemp);\n                        const novoValorRecebidoTotal = prev.valorRecebidoTotal + novaFormaTemp.valorRecebido;\n                        const novoDescontoReal = prev.valorBruto > 0 ? (prev.valorBruto - novoValorRecebidoTotal) / prev.valorBruto * 100 : 0;\n                        if (novoDescontoReal > prev.travamentos.limiteDescontoReal) {\n                            alert(\"N\\xe3o \\xe9 poss\\xedvel adicionar esta forma. O desconto real excederia o limite de \".concat(prev.travamentos.limiteDescontoReal, \"%\"));\n                            return prev;\n                        }\n                    }\n                    const novaForma = {\n                        ...forma,\n                        id: Date.now().toString(),\n                        valorRecebido: 0,\n                        travado: false\n                    };\n                    novaForma.valorRecebido = calcularValorRecebidoForma(novaForma);\n                    const novasFormas = [\n                        ...prev.formasPagamento,\n                        novaForma\n                    ];\n                    const updated = {\n                        ...prev,\n                        formasPagamento: novasFormas\n                    };\n                    updated.valorRecebidoTotal = novasFormas.reduce({\n                        \"useSimulador.useCallback[adicionarForma]\": (acc, f)=>acc + f.valorRecebido\n                    }[\"useSimulador.useCallback[adicionarForma]\"], 0);\n                    updated.descontoReal = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorRecebidoTotal) / updated.valorBruto * 100 : 0;\n                    const somaFormas = novasFormas.reduce({\n                        \"useSimulador.useCallback[adicionarForma].somaFormas\": (acc, f)=>acc + f.valor\n                    }[\"useSimulador.useCallback[adicionarForma].somaFormas\"], 0);\n                    updated.valorRestante = updated.valorNegociado - somaFormas;\n                    console.log('Nova simulação com forma adicionada:', updated);\n                    return updated;\n                }\n            }[\"useSimulador.useCallback[adicionarForma]\"]);\n        }\n    }[\"useSimulador.useCallback[adicionarForma]\"], [\n        calcularValorRecebidoForma\n    ]);\n    const atualizarForma = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[atualizarForma]\": (id, dadosAtualizados)=>{\n            console.log('Atualizando forma:', id, dadosAtualizados);\n            setSimulacao({\n                \"useSimulador.useCallback[atualizarForma]\": (prev)=>{\n                    const novasFormas = prev.formasPagamento.map({\n                        \"useSimulador.useCallback[atualizarForma].novasFormas\": (forma)=>{\n                            if (forma.id === id) {\n                                // Se a forma está travada, não permite alterar o valor\n                                if (forma.travado && dadosAtualizados.valor !== forma.valor) {\n                                    console.log('Forma travada, não é possível alterar o valor');\n                                    return forma;\n                                }\n                                const formaAtualizada = {\n                                    ...forma,\n                                    ...dadosAtualizados\n                                };\n                                formaAtualizada.valorRecebido = calcularValorRecebidoForma(formaAtualizada);\n                                return formaAtualizada;\n                            }\n                            return forma;\n                        }\n                    }[\"useSimulador.useCallback[atualizarForma].novasFormas\"]);\n                    const updated = {\n                        ...prev,\n                        formasPagamento: novasFormas\n                    };\n                    updated.valorRecebidoTotal = novasFormas.reduce({\n                        \"useSimulador.useCallback[atualizarForma]\": (acc, f)=>acc + f.valorRecebido\n                    }[\"useSimulador.useCallback[atualizarForma]\"], 0);\n                    updated.descontoReal = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorRecebidoTotal) / updated.valorBruto * 100 : 0;\n                    const somaFormas = novasFormas.reduce({\n                        \"useSimulador.useCallback[atualizarForma].somaFormas\": (acc, f)=>acc + f.valor\n                    }[\"useSimulador.useCallback[atualizarForma].somaFormas\"], 0);\n                    updated.valorRestante = updated.valorNegociado - somaFormas;\n                    console.log('Simulação atualizada após edição:', updated);\n                    return updated;\n                }\n            }[\"useSimulador.useCallback[atualizarForma]\"]);\n        }\n    }[\"useSimulador.useCallback[atualizarForma]\"], [\n        calcularValorRecebidoForma\n    ]);\n    const removerForma = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[removerForma]\": (id)=>{\n            console.log('Removendo forma:', id);\n            setSimulacao({\n                \"useSimulador.useCallback[removerForma]\": (prev)=>{\n                    const novasFormas = prev.formasPagamento.filter({\n                        \"useSimulador.useCallback[removerForma].novasFormas\": (f)=>f.id !== id\n                    }[\"useSimulador.useCallback[removerForma].novasFormas\"]);\n                    return {\n                        ...prev,\n                        formasPagamento: novasFormas,\n                        valorRecebidoTotal: novasFormas.reduce({\n                            \"useSimulador.useCallback[removerForma]\": (acc, f)=>acc + f.valorRecebido\n                        }[\"useSimulador.useCallback[removerForma]\"], 0),\n                        descontoReal: prev.valorBruto > 0 ? (prev.valorBruto - novasFormas.reduce({\n                            \"useSimulador.useCallback[removerForma]\": (acc, f)=>acc + f.valorRecebido\n                        }[\"useSimulador.useCallback[removerForma]\"], 0)) / prev.valorBruto * 100 : 0,\n                        valorRestante: prev.valorNegociado - novasFormas.reduce({\n                            \"useSimulador.useCallback[removerForma]\": (acc, f)=>acc + f.valor\n                        }[\"useSimulador.useCallback[removerForma]\"], 0)\n                    };\n                }\n            }[\"useSimulador.useCallback[removerForma]\"]);\n        }\n    }[\"useSimulador.useCallback[removerForma]\"], []);\n    const limparFormas = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[limparFormas]\": ()=>{\n            console.log('Limpando todas as formas');\n            setSimulacao({\n                \"useSimulador.useCallback[limparFormas]\": (prev)=>({\n                        ...prev,\n                        formasPagamento: [],\n                        valorRecebidoTotal: 0,\n                        descontoReal: prev.valorBruto > 0 ? 100 : 0,\n                        valorRestante: prev.valorNegociado\n                    })\n            }[\"useSimulador.useCallback[limparFormas]\"]);\n        }\n    }[\"useSimulador.useCallback[limparFormas]\"], []);\n    const alternarTravamento = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[alternarTravamento]\": (tipo, valor)=>{\n            setSimulacao({\n                \"useSimulador.useCallback[alternarTravamento]\": (prev)=>({\n                        ...prev,\n                        travamentos: {\n                            ...prev.travamentos,\n                            [tipo]: !prev.travamentos[tipo],\n                            ...valor !== undefined && {\n                                limiteDescontoReal: valor\n                            }\n                        }\n                    })\n            }[\"useSimulador.useCallback[alternarTravamento]\"]);\n        }\n    }[\"useSimulador.useCallback[alternarTravamento]\"], []);\n    const alternarTravamentoForma = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[alternarTravamentoForma]\": (id)=>{\n            setSimulacao({\n                \"useSimulador.useCallback[alternarTravamentoForma]\": (prev)=>({\n                        ...prev,\n                        formasPagamento: prev.formasPagamento.map({\n                            \"useSimulador.useCallback[alternarTravamentoForma]\": (forma)=>forma.id === id ? {\n                                    ...forma,\n                                    travado: !forma.travado\n                                } : forma\n                        }[\"useSimulador.useCallback[alternarTravamentoForma]\"])\n                    })\n            }[\"useSimulador.useCallback[alternarTravamentoForma]\"]);\n        }\n    }[\"useSimulador.useCallback[alternarTravamentoForma]\"], []);\n    return {\n        simulacao,\n        recalcularSimulacao,\n        adicionarForma,\n        atualizarForma,\n        removerForma,\n        limparFormas,\n        alternarTravamento,\n        alternarTravamentoForma,\n        editarValorNegociado,\n        editarValorBruto,\n        editarDescontoReal\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VTaW11bGFkb3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXVEO0FBR2hELE1BQU1HLGVBQWU7SUFDMUIsTUFBTSxDQUFDQyxXQUFXQyxhQUFhLEdBQUdMLCtDQUFRQSxDQUFZO1FBQ3BETSxZQUFZO1FBQ1pDLFVBQVU7UUFDVkMsZ0JBQWdCO1FBQ2hCQyxpQkFBaUIsRUFBRTtRQUNuQkMsb0JBQW9CO1FBQ3BCQyxjQUFjO1FBQ2RDLGVBQWU7UUFDZkMsYUFBYTtZQUNYTCxnQkFBZ0I7WUFDaEJHLGNBQWM7WUFDZEcsb0JBQW9CO1FBQ3RCO0lBQ0Y7SUFFQSw0Q0FBNEM7SUFDNUMsTUFBTUMsb0JBQW9CYiw4Q0FBT0E7bURBQUMsSUFBTTtnQkFBQztnQkFBVztnQkFBVTtnQkFBYzthQUFTO2tEQUFFLEVBQUU7SUFFekYsTUFBTWMsNkJBQTZCZixrREFBV0E7Z0VBQUMsQ0FBQ2dCO1lBQzlDQyxRQUFRQyxHQUFHLENBQUMsbUNBQW1DRjtZQUUvQyxPQUFRQSxNQUFNRyxJQUFJO2dCQUNoQixLQUFLO29CQUNILE9BQU9ILE1BQU1JLEtBQUs7Z0JBRXBCLEtBQUs7b0JBQWM7d0JBQ2pCLElBQUksQ0FBQ0osTUFBTUssUUFBUSxJQUFJLENBQUNMLE1BQU1NLFNBQVMsRUFBRSxPQUFPTixNQUFNSSxLQUFLO3dCQUMzRCxNQUFNRyxJQUFJUCxNQUFNTSxTQUFTLEdBQUc7d0JBQzVCLE1BQU1ELFdBQVdMLE1BQU1LLFFBQVE7d0JBQy9CLE1BQU1HLGdCQUFnQlIsTUFBTUksS0FBSyxHQUFHSyxLQUFLQyxHQUFHLENBQUMsSUFBSUgsR0FBR0Y7d0JBQ3BESixRQUFRQyxHQUFHLENBQUMscUJBQThDRyxPQUF6QkwsTUFBTUksS0FBSyxFQUFDLGVBQStCSixPQUFsQkssVUFBUyxXQUFpQ0csT0FBeEJSLE1BQU1NLFNBQVMsRUFBQyxVQUFzQixPQUFkRTt3QkFDcEcsT0FBT0E7b0JBQ1Q7Z0JBRUEsS0FBSztvQkFB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RSxHQUFHL0MsS0FBSztvQ0FBRTZCLFNBQVMsQ0FBQzdCLE1BQU02QixPQUFPO2dDQUFDLElBQUk3Qjs7b0JBRTlEOztRQUNGOzREQUFHLEVBQUU7SUFFTCxPQUFPO1FBQ0xiO1FBQ0FpRTtRQUNBMkI7UUFDQU87UUFDQUc7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQWxDO1FBQ0FvQjtRQUNBakI7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xccmljYXJcXFByb2pldG9zXFxmbHV5dC1wcm9wb3N0YS1zaW11bGFkb3JcXHNyY1xcaG9va3NcXHVzZVNpbXVsYWRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBGb3JtYVBhZ2FtZW50bywgU2ltdWxhY2FvLCBUcmF2YW1lbnRvQ29uZmlnIH0gZnJvbSAnLi4vdHlwZXMvc2ltdWxhZG9yJztcblxuZXhwb3J0IGNvbnN0IHVzZVNpbXVsYWRvciA9ICgpID0+IHtcbiAgY29uc3QgW3NpbXVsYWNhbywgc2V0U2ltdWxhY2FvXSA9IHVzZVN0YXRlPFNpbXVsYWNhbz4oe1xuICAgIHZhbG9yQnJ1dG86IDAsXG4gICAgZGVzY29udG86IDAsXG4gICAgdmFsb3JOZWdvY2lhZG86IDAsXG4gICAgZm9ybWFzUGFnYW1lbnRvOiBbXSxcbiAgICB2YWxvclJlY2ViaWRvVG90YWw6IDAsXG4gICAgZGVzY29udG9SZWFsOiAwLFxuICAgIHZhbG9yUmVzdGFudGU6IDAsXG4gICAgdHJhdmFtZW50b3M6IHtcbiAgICAgIHZhbG9yTmVnb2NpYWRvOiBmYWxzZSxcbiAgICAgIGRlc2NvbnRvUmVhbDogZmFsc2UsXG4gICAgICBsaW1pdGVEZXNjb250b1JlYWw6IDI1XG4gICAgfVxuICB9KTtcblxuICAvLyBQcmlvcmlkYWRlIHBhcmEgcmVkaXN0cmlidWnDp8OjbyBkZSB2YWxvcmVzXG4gIGNvbnN0IFBSSU9SSURBREVfRk9STUFTID0gdXNlTWVtbygoKSA9PiBbJ0VOVFJBREEnLCAnQk9MRVRPJywgJ0ZJTkFOQ0VJUkEnLCAnQ0FSVEFPJ10sIFtdKTtcblxuICBjb25zdCBjYWxjdWxhclZhbG9yUmVjZWJpZG9Gb3JtYSA9IHVzZUNhbGxiYWNrKChmb3JtYTogRm9ybWFQYWdhbWVudG8pOiBudW1iZXIgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdDYWxjdWxhbmRvIHZhbG9yIHJlY2ViaWRvIHBhcmE6JywgZm9ybWEpO1xuICAgIFxuICAgIHN3aXRjaCAoZm9ybWEudGlwbykge1xuICAgICAgY2FzZSAnRU5UUkFEQSc6XG4gICAgICAgIHJldHVybiBmb3JtYS52YWxvcjtcbiAgICAgIFxuICAgICAgY2FzZSAnRklOQU5DRUlSQSc6IHtcbiAgICAgICAgaWYgKCFmb3JtYS5wYXJjZWxhcyB8fCAhZm9ybWEudGF4YUp1cm9zKSByZXR1cm4gZm9ybWEudmFsb3I7XG4gICAgICAgIGNvbnN0IGkgPSBmb3JtYS50YXhhSnVyb3MgLyAxMDA7XG4gICAgICAgIGNvbnN0IHBhcmNlbGFzID0gZm9ybWEucGFyY2VsYXM7XG4gICAgICAgIGNvbnN0IHZhbG9yUHJlc2VudGUgPSBmb3JtYS52YWxvciAvIE1hdGgucG93KDEgKyBpLCBwYXJjZWxhcyk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBGaW5hbmNlaXJhOiB2YWxvcj0ke2Zvcm1hLnZhbG9yfSwgcGFyY2VsYXM9JHtwYXJjZWxhc30sIHRheGE9JHtmb3JtYS50YXhhSnVyb3N9JSwgVlA9JHt2YWxvclByZXNlbnRlfWApO1xuICAgICAgICByZXR1cm4gdmFsb3JQcmVzZW50ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY2FzZSAnQ0FSVEFPJzoge1xuICAgICAgICBpZiAoIWZvcm1hLmRlZmxhY2FvIHx8ICFmb3JtYS5qdXJvc0FudGVjaXBhY2FvIHx8ICFmb3JtYS5wYXJjZWxhcykgcmV0dXJuIGZvcm1hLnZhbG9yO1xuICAgICAgICBjb25zdCBmYXRvckRlZmxhY2FvID0gMSAtIChmb3JtYS5kZWZsYWNhbyAvIDEwMCk7XG4gICAgICAgIGNvbnN0IGZhdG9ySnVyb3MgPSAxIC0gKGZvcm1hLmp1cm9zQW50ZWNpcGFjYW8gLyAxMDAgKiBmb3JtYS5wYXJjZWxhcyk7XG4gICAgICAgIGNvbnN0IHZhbG9yUmVjZWJpZG8gPSBmb3JtYS52YWxvciAqIGZhdG9yRGVmbGFjYW8gKiBmYXRvckp1cm9zO1xuICAgICAgICBjb25zb2xlLmxvZyhgQ2FydMOjbzogdmFsb3I9JHtmb3JtYS52YWxvcn0sIGRlZmxhw6fDo289JHtmb3JtYS5kZWZsYWNhb30lLCBqdXJvcz0ke2Zvcm1hLmp1cm9zQW50ZWNpcGFjYW99JSwgVlI9JHt2YWxvclJlY2ViaWRvfWApO1xuICAgICAgICByZXR1cm4gdmFsb3JSZWNlYmlkbztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY2FzZSAnQk9MRVRPJzoge1xuICAgICAgICBpZiAoIWZvcm1hLnBhcmNlbGFzIHx8ICFmb3JtYS5jdXN0b0NhcGl0YWwpIHJldHVybiBmb3JtYS52YWxvcjtcbiAgICAgICAgY29uc3QgaWMgPSBmb3JtYS5jdXN0b0NhcGl0YWwgLyAxMDA7XG4gICAgICAgIGNvbnN0IHZhbG9yUHJlc2VudGVCb2xldG8gPSBmb3JtYS52YWxvciAvIE1hdGgucG93KDEgKyBpYywgZm9ybWEucGFyY2VsYXMpO1xuICAgICAgICBjb25zb2xlLmxvZyhgQm9sZXRvOiB2YWxvcj0ke2Zvcm1hLnZhbG9yfSwgcGFyY2VsYXM9JHtmb3JtYS5wYXJjZWxhc30sIGN1c3RvPSR7Zm9ybWEuY3VzdG9DYXBpdGFsfSUsIFZQPSR7dmFsb3JQcmVzZW50ZUJvbGV0b31gKTtcbiAgICAgICAgcmV0dXJuIHZhbG9yUHJlc2VudGVCb2xldG87XG4gICAgICB9XG4gICAgICBcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmb3JtYS52YWxvcjtcbiAgICB9XG4gIH0sIFtdKTtcblxuICBjb25zdCByZWRpc3RyaWJ1aXJWYWxvcmVzID0gdXNlQ2FsbGJhY2soKG5vdm9WYWxvck5lZ29jaWFkbzogbnVtYmVyLCBmb3JtYXNBdHVhaXM6IEZvcm1hUGFnYW1lbnRvW10pID0+IHtcbiAgICBjb25zb2xlLmxvZygnUmVkaXN0cmlidWluZG8gdmFsb3Jlcy4gTm92byB2YWxvciBuZWdvY2lhZG86Jywgbm92b1ZhbG9yTmVnb2NpYWRvKTtcbiAgICBcbiAgICBjb25zdCBzb21hQXR1YWwgPSBmb3JtYXNBdHVhaXMucmVkdWNlKChhY2MsIGZvcm1hKSA9PiBhY2MgKyBmb3JtYS52YWxvciwgMCk7XG4gICAgY29uc3QgZGlmZXJlbmNhID0gbm92b1ZhbG9yTmVnb2NpYWRvIC0gc29tYUF0dWFsO1xuICAgIFxuICAgIGlmIChNYXRoLmFicyhkaWZlcmVuY2EpIDwgMC4wMSkge1xuICAgICAgcmV0dXJuIGZvcm1hc0F0dWFpczsgLy8gTsOjbyBow6EgZGlmZXJlbsOnYSBzaWduaWZpY2F0aXZhXG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdEaWZlcmVuw6dhIGEgcmVkaXN0cmlidWlyOicsIGRpZmVyZW5jYSk7XG4gICAgXG4gICAgLy8gU2VwYXJhciBmb3JtYXMgdHJhdmFkYXMgZSBuw6NvIHRyYXZhZGFzXG4gICAgY29uc3QgZm9ybWFzVHJhdmFkYXMgPSBmb3JtYXNBdHVhaXMuZmlsdGVyKGZvcm1hID0+IGZvcm1hLnRyYXZhZG8pO1xuICAgIGNvbnN0IGZvcm1hc05hb1RyYXZhZGFzID0gZm9ybWFzQXR1YWlzLmZpbHRlcihmb3JtYSA9PiAhZm9ybWEudHJhdmFkbyk7XG4gICAgXG4gICAgLy8gU2UgdG9kYXMgZXN0w6NvIHRyYXZhZGFzLCBuw6NvIHBvZGVtb3MgcmVkaXN0cmlidWlyXG4gICAgaWYgKGZvcm1hc05hb1RyYXZhZGFzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5sb2coJ1RvZGFzIGFzIGZvcm1hcyBlc3TDo28gdHJhdmFkYXMnKTtcbiAgICAgIHJldHVybiBudWxsOyAvLyBJbmRpY2EgZXJyb1xuICAgIH1cbiAgICBcbiAgICAvLyBPcmRlbmFyIGZvcm1hcyBuw6NvIHRyYXZhZGFzIHBvciBwcmlvcmlkYWRlXG4gICAgY29uc3QgZm9ybWFzT3JkZW5hZGFzID0gZm9ybWFzTmFvVHJhdmFkYXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgcHJpb3JpZGFkZUEgPSBQUklPUklEQURFX0ZPUk1BUy5pbmRleE9mKGEudGlwbyk7XG4gICAgICBjb25zdCBwcmlvcmlkYWRlQiA9IFBSSU9SSURBREVfRk9STUFTLmluZGV4T2YoYi50aXBvKTtcbiAgICAgIHJldHVybiBwcmlvcmlkYWRlQSAtIHByaW9yaWRhZGVCO1xuICAgIH0pO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdGb3JtYXMgb3JkZW5hZGFzIHBvciBwcmlvcmlkYWRlOicsIGZvcm1hc09yZGVuYWRhcy5tYXAoZiA9PiBmLnRpcG8pKTtcbiAgICBcbiAgICAvLyBSZWRpc3RyaWJ1aXIgYSBkaWZlcmVuw6dhOiBhcGVuYXMgYSBwcmltZWlyYSBmb3JtYSBuYSBvcmRlbSBkZSBwcmlvcmlkYWRlIGFic29ydmUgdG9kYSBhIGRpZmVyZW7Dp2FcbiAgICBjb25zdCBub3Zhc0Zvcm1hcyA9IFsuLi5mb3JtYXNBdHVhaXNdO1xuICAgIFxuICAgIC8vIFZlcmlmaWNhciBzZSB0b2RhcyBhcyBmb3JtYXMgbsOjbyB0cmF2YWRhcyB0w6ptIHZhbG9yIHplcm9cbiAgICBjb25zdCBzb21hRm9ybWFzTmFvVHJhdmFkYXMgPSBmb3JtYXNPcmRlbmFkYXMucmVkdWNlKChhY2MsIGZvcm1hKSA9PiBhY2MgKyBmb3JtYS52YWxvciwgMCk7XG4gICAgXG4gICAgaWYgKHNvbWFGb3JtYXNOYW9UcmF2YWRhcyA9PT0gMCkge1xuICAgICAgLy8gU2UgdG9kYXMgYXMgZm9ybWFzIG7Do28gdHJhdmFkYXMgdMOqbSB2YWxvciAwLCBkaXN0cmlidWkgaWd1YWxtZW50ZVxuICAgICAgY29uc29sZS5sb2coJ1RvZGFzIGFzIGZvcm1hcyBuw6NvIHRyYXZhZGFzIHTDqm0gdmFsb3IgemVybywgZGlzdHJpYnVpbmRvIGlndWFsbWVudGUnKTtcbiAgICAgIGNvbnN0IGFqdXN0ZVBvckZvcm1hID0gZGlmZXJlbmNhIC8gZm9ybWFzT3JkZW5hZGFzLmxlbmd0aDtcbiAgICAgIGZvcm1hc09yZGVuYWRhcy5mb3JFYWNoKGZvcm1hID0+IHtcbiAgICAgICAgY29uc3QgZm9ybWFJbmRleCA9IG5vdmFzRm9ybWFzLmZpbmRJbmRleChmID0+IGYuaWQgPT09IGZvcm1hLmlkKTtcbiAgICAgICAgY29uc3Qgbm92b1ZhbG9yID0gYWp1c3RlUG9yRm9ybWE7XG4gICAgICAgIG5vdmFzRm9ybWFzW2Zvcm1hSW5kZXhdID0geyAuLi5ub3Zhc0Zvcm1hc1tmb3JtYUluZGV4XSwgdmFsb3I6IE1hdGgubWF4KDAsIG5vdm9WYWxvcikgfTtcbiAgICAgICAgY29uc29sZS5sb2coYEZvcm1hICR7Zm9ybWEudGlwb30gYWp1c3RhZGEgcGFyYTogJHtub3ZvVmFsb3J9IChmaW5hbDogJHtNYXRoLm1heCgwLCBub3ZvVmFsb3IpfSlgKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBcGVuYXMgYSBwcmltZWlyYSBmb3JtYSBuw6NvIHRyYXZhZGEgbmEgb3JkZW0gZGUgcHJpb3JpZGFkZSBhYnNvcnZlIHRvZGEgYSBkaWZlcmVuw6dhXG4gICAgICBjb25zb2xlLmxvZygnQWp1c3RhbmRvIGFwZW5hcyBhIHByaW1laXJhIGZvcm1hIG5hIG9yZGVtIGRlIHByaW9yaWRhZGUnKTtcbiAgICAgIGNvbnN0IHByaW1laXJhRm9ybWEgPSBmb3JtYXNPcmRlbmFkYXNbMF07XG4gICAgICBjb25zdCBmb3JtYUluZGV4ID0gbm92YXNGb3JtYXMuZmluZEluZGV4KGYgPT4gZi5pZCA9PT0gcHJpbWVpcmFGb3JtYS5pZCk7XG4gICAgICBjb25zdCB2YWxvckNhbGN1bGFkbyA9IHByaW1laXJhRm9ybWEudmFsb3IgKyBkaWZlcmVuY2E7XG4gICAgICBjb25zdCBub3ZvVmFsb3IgPSBNYXRoLm1heCgwLCB2YWxvckNhbGN1bGFkbyk7XG4gICAgICBub3Zhc0Zvcm1hc1tmb3JtYUluZGV4XSA9IHsgLi4ubm92YXNGb3JtYXNbZm9ybWFJbmRleF0sIHZhbG9yOiBub3ZvVmFsb3IgfTtcbiAgICAgIGNvbnNvbGUubG9nKGBGb3JtYSAke3ByaW1laXJhRm9ybWEudGlwb30gYWp1c3RhZGEgZGUgJHtwcmltZWlyYUZvcm1hLnZhbG9yfSBwYXJhICR7dmFsb3JDYWxjdWxhZG99IChmaW5hbDogJHtub3ZvVmFsb3J9KWApO1xuICAgICAgXG4gICAgICAvLyBTZSBvIHZhbG9yIGZpY291IG5lZ2F0aXZvLCBpbmRpY2FyIGltcG9zc2liaWxpZGFkZVxuICAgICAgaWYgKHZhbG9yQ2FsY3VsYWRvIDwgMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pqg77iPIFZhbG9yIG5lZ2F0aXZvIGRldGVjdGFkbyAoJHt2YWxvckNhbGN1bGFkb30pLCBwb2RlIGVzdGFyIG5vIGxpbWl0ZSBkZSBkZXNjb250byByZWFsYCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBub3Zhc0Zvcm1hcztcbiAgfSwgW1BSSU9SSURBREVfRk9STUFTXSk7XG5cbiAgY29uc3QgcmVjYWxjdWxhclNpbXVsYWNhbyA9IHVzZUNhbGxiYWNrKCh1cGRhdGVzOiBQYXJ0aWFsPFNpbXVsYWNhbz4pID0+IHtcbiAgICBjb25zb2xlLmxvZygnUmVjYWxjdWxhbmRvIHNpbXVsYcOnw6NvIGNvbSB1cGRhdGVzOicsIHVwZGF0ZXMpO1xuICAgIFxuICAgIHNldFNpbXVsYWNhbyhwcmV2ID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWQgPSB7IC4uLnByZXYsIC4uLnVwZGF0ZXMgfTtcbiAgICAgIFxuICAgICAgLy8gTMOzZ2ljYSBkZSB0cmF2YW1lbnRvIGRvIHZhbG9yIG5lZ29jaWFkb1xuICAgICAgaWYgKHVwZGF0ZWQudHJhdmFtZW50b3MudmFsb3JOZWdvY2lhZG8pIHtcbiAgICAgICAgLy8gU2UgdmFsb3IgbmVnb2NpYWRvIGVzdMOhIHRyYXZhZG8sIGFqdXN0YSBvIGRlc2NvbnRvIHF1YW5kbyB2YWxvciBicnV0byBtdWRhXG4gICAgICAgIGlmICh1cGRhdGVzLnZhbG9yQnJ1dG8gIT09IHVuZGVmaW5lZCAmJiB1cGRhdGVzLnZhbG9yQnJ1dG8gPiAwKSB7XG4gICAgICAgICAgdXBkYXRlZC5kZXNjb250byA9ICgodXBkYXRlZC52YWxvckJydXRvIC0gdXBkYXRlZC52YWxvck5lZ29jaWFkbykgLyB1cGRhdGVkLnZhbG9yQnJ1dG8pICogMTAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb21wb3J0YW1lbnRvIG5vcm1hbDogY2FsY3VsYSB2YWxvciBuZWdvY2lhZG8gYmFzZWFkbyBubyBkZXNjb250b1xuICAgICAgICB1cGRhdGVkLnZhbG9yTmVnb2NpYWRvID0gdXBkYXRlZC52YWxvckJydXRvICogKDEgLSB1cGRhdGVkLmRlc2NvbnRvIC8gMTAwKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdXBkYXRlZC5mb3JtYXNQYWdhbWVudG8gPSB1cGRhdGVkLmZvcm1hc1BhZ2FtZW50by5tYXAoZm9ybWEgPT4gKHtcbiAgICAgICAgLi4uZm9ybWEsXG4gICAgICAgIHZhbG9yUmVjZWJpZG86IGNhbGN1bGFyVmFsb3JSZWNlYmlkb0Zvcm1hKGZvcm1hKVxuICAgICAgfSkpO1xuICAgICAgXG4gICAgICB1cGRhdGVkLnZhbG9yUmVjZWJpZG9Ub3RhbCA9IHVwZGF0ZWQuZm9ybWFzUGFnYW1lbnRvLnJlZHVjZSgoYWNjLCBmb3JtYSkgPT4gYWNjICsgZm9ybWEudmFsb3JSZWNlYmlkbywgMCk7XG4gICAgICB1cGRhdGVkLmRlc2NvbnRvUmVhbCA9IHVwZGF0ZWQudmFsb3JCcnV0byA+IDAgPyAoKHVwZGF0ZWQudmFsb3JCcnV0byAtIHVwZGF0ZWQudmFsb3JSZWNlYmlkb1RvdGFsKSAvIHVwZGF0ZWQudmFsb3JCcnV0bykgKiAxMDAgOiAwO1xuICAgICAgXG4gICAgICBjb25zdCBzb21hRm9ybWFzID0gdXBkYXRlZC5mb3JtYXNQYWdhbWVudG8ucmVkdWNlKChhY2MsIGZvcm1hKSA9PiBhY2MgKyBmb3JtYS52YWxvciwgMCk7XG4gICAgICB1cGRhdGVkLnZhbG9yUmVzdGFudGUgPSB1cGRhdGVkLnZhbG9yTmVnb2NpYWRvIC0gc29tYUZvcm1hcztcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1NpbXVsYcOnw6NvIGF0dWFsaXphZGE6JywgdXBkYXRlZCk7XG4gICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9KTtcbiAgfSwgW2NhbGN1bGFyVmFsb3JSZWNlYmlkb0Zvcm1hXSk7XG5cbiAgY29uc3QgZWRpdGFyVmFsb3JOZWdvY2lhZG8gPSB1c2VDYWxsYmFjaygobm92b1ZhbG9yOiBudW1iZXIpID0+IHtcbiAgICBjb25zb2xlLmxvZygnRWRpdGFuZG8gdmFsb3IgbmVnb2NpYWRvIHBhcmE6Jywgbm92b1ZhbG9yKTtcbiAgICBcbiAgICBzZXRTaW11bGFjYW8ocHJldiA9PiB7XG4gICAgICBjb25zdCBmb3JtYXNSZWRpc3RyaWJ1aWRhcyA9IHJlZGlzdHJpYnVpclZhbG9yZXMobm92b1ZhbG9yLCBwcmV2LmZvcm1hc1BhZ2FtZW50byk7XG4gICAgICBcbiAgICAgIGlmICghZm9ybWFzUmVkaXN0cmlidWlkYXMpIHtcbiAgICAgICAgYWxlcnQoJ07Do28gw6kgcG9zc8OtdmVsIGFsdGVyYXIgbyB2YWxvci4gVG9kYXMgYXMgZm9ybWFzIGRlIHBhZ2FtZW50byBlc3TDo28gdHJhdmFkYXMuJyk7XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCB1cGRhdGVkID0ge1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICB2YWxvck5lZ29jaWFkbzogbm92b1ZhbG9yLFxuICAgICAgICBmb3JtYXNQYWdhbWVudG86IGZvcm1hc1JlZGlzdHJpYnVpZGFzLm1hcChmb3JtYSA9PiAoe1xuICAgICAgICAgIC4uLmZvcm1hLFxuICAgICAgICAgIHZhbG9yUmVjZWJpZG86IGNhbGN1bGFyVmFsb3JSZWNlYmlkb0Zvcm1hKGZvcm1hKVxuICAgICAgICB9KSlcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIFJlY2FsY3VsYXIgZGVzY29udG9cbiAgICAgIHVwZGF0ZWQuZGVzY29udG8gPSB1cGRhdGVkLnZhbG9yQnJ1dG8gPiAwID8gKCh1cGRhdGVkLnZhbG9yQnJ1dG8gLSB1cGRhdGVkLnZhbG9yTmVnb2NpYWRvKSAvIHVwZGF0ZWQudmFsb3JCcnV0bykgKiAxMDAgOiAwO1xuICAgICAgXG4gICAgICB1cGRhdGVkLnZhbG9yUmVjZWJpZG9Ub3RhbCA9IHVwZGF0ZWQuZm9ybWFzUGFnYW1lbnRvLnJlZHVjZSgoYWNjLCBmb3JtYSkgPT4gYWNjICsgZm9ybWEudmFsb3JSZWNlYmlkbywgMCk7XG4gICAgICB1cGRhdGVkLmRlc2NvbnRvUmVhbCA9IHVwZGF0ZWQudmFsb3JCcnV0byA+IDAgPyAoKHVwZGF0ZWQudmFsb3JCcnV0byAtIHVwZGF0ZWQudmFsb3JSZWNlYmlkb1RvdGFsKSAvIHVwZGF0ZWQudmFsb3JCcnV0bykgKiAxMDAgOiAwO1xuICAgICAgXG4gICAgICBjb25zdCBzb21hRm9ybWFzID0gdXBkYXRlZC5mb3JtYXNQYWdhbWVudG8ucmVkdWNlKChhY2MsIGZvcm1hKSA9PiBhY2MgKyBmb3JtYS52YWxvciwgMCk7XG4gICAgICB1cGRhdGVkLnZhbG9yUmVzdGFudGUgPSB1cGRhdGVkLnZhbG9yTmVnb2NpYWRvIC0gc29tYUZvcm1hcztcbiAgICAgIFxuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfSk7XG4gIH0sIFtyZWRpc3RyaWJ1aXJWYWxvcmVzLCBjYWxjdWxhclZhbG9yUmVjZWJpZG9Gb3JtYV0pO1xuXG4gIGNvbnN0IGVkaXRhckRlc2NvbnRvUmVhbCA9IHVzZUNhbGxiYWNrKChub3ZvRGVzY29udG9SZWFsOiBudW1iZXIpID0+IHtcbiAgICBjb25zb2xlLmxvZygnRWRpdGFuZG8gZGVzY29udG8gcmVhbCBwYXJhOicsIG5vdm9EZXNjb250b1JlYWwpO1xuICAgIFxuICAgIHNldFNpbXVsYWNhbyhwcmV2ID0+IHtcbiAgICAgIC8vIEZ1bsOnw6NvIGF1eGlsaWFyIHBhcmEgY2FsY3VsYXIgbyBkZXNjb250byByZWFsIGRhZG8gdW0gdmFsb3IgbmVnb2NpYWRvXG4gICAgICBjb25zdCBjYWxjdWxhckRlc2NvbnRvUmVhbFBhcmFWYWxvciA9ICh2YWxvck5lZ29jaWFkbzogbnVtYmVyKTogbnVtYmVyID0+IHtcbiAgICAgICAgY29uc3QgZm9ybWFzVGVtcCA9IHJlZGlzdHJpYnVpclZhbG9yZXModmFsb3JOZWdvY2lhZG8sIHByZXYuZm9ybWFzUGFnYW1lbnRvKTtcbiAgICAgICAgaWYgKCFmb3JtYXNUZW1wKSByZXR1cm4gLTE7IC8vIEluZGljYSBlcnJvXG4gICAgICAgIFxuICAgICAgICBjb25zdCB2YWxvclJlY2ViaWRvVGVtcCA9IGZvcm1hc1RlbXAucmVkdWNlKChhY2MsIGZvcm1hKSA9PiB7XG4gICAgICAgICAgY29uc3QgZm9ybWFDb21SZWNlYmlkbyA9IHsgLi4uZm9ybWEsIHZhbG9yUmVjZWJpZG86IGNhbGN1bGFyVmFsb3JSZWNlYmlkb0Zvcm1hKGZvcm1hKSB9O1xuICAgICAgICAgIHJldHVybiBhY2MgKyBmb3JtYUNvbVJlY2ViaWRvLnZhbG9yUmVjZWJpZG87XG4gICAgICAgIH0sIDApO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHByZXYudmFsb3JCcnV0byA+IDAgPyAoKHByZXYudmFsb3JCcnV0byAtIHZhbG9yUmVjZWJpZG9UZW1wKSAvIHByZXYudmFsb3JCcnV0bykgKiAxMDAgOiAwO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gQnVzY2EgYmluw6FyaWEgcGFyYSBlbmNvbnRyYXIgbyB2YWxvciBuZWdvY2lhZG8gcXVlIHJlc3VsdGEgbm8gZGVzY29udG8gcmVhbCBkZXNlamFkb1xuICAgICAgbGV0IHZhbG9yTWluID0gMDtcbiAgICAgIGxldCB2YWxvck1heCA9IHByZXYudmFsb3JCcnV0bztcbiAgICAgIGxldCB2YWxvck5lZ29jaWFkb090aW1vID0gcHJldi52YWxvck5lZ29jaWFkbztcbiAgICAgIGxldCBtZWxob3JEaWZlcmVuY2EgPSBJbmZpbml0eTtcbiAgICAgIGxldCBtZWxob3JEZXNjb250byA9IHByZXYuZGVzY29udG9SZWFsO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg8J+OryBJbmljaWFuZG8gYnVzY2EgYmluw6FyaWEgcGFyYSBkZXNjb250byByZWFsOiAke25vdm9EZXNjb250b1JlYWx9JWApO1xuICAgICAgY29uc29sZS5sb2coYERlc2NvbnRvIHJlYWwgYXR1YWw6ICR7cHJldi5kZXNjb250b1JlYWx9JWApO1xuICAgICAgY29uc29sZS5sb2coYEludGVydmFsbyBpbmljaWFsOiAke3ZhbG9yTWlufSAtICR7dmFsb3JNYXh9YCk7XG4gICAgICBcbiAgICAgIC8vIE3DoXhpbW8gZGUgMjUgaXRlcmHDp8O1ZXMgcGFyYSBtYWlvciBwcmVjaXPDo29cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU7IGkrKykge1xuICAgICAgICBjb25zdCB2YWxvclRlc3RlID0gKHZhbG9yTWluICsgdmFsb3JNYXgpIC8gMjtcbiAgICAgICAgY29uc3QgZGVzY29udG9SZWFsQ2FsY3VsYWRvID0gY2FsY3VsYXJEZXNjb250b1JlYWxQYXJhVmFsb3IodmFsb3JUZXN0ZSk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgSXRlcmHDp8OjbyAke2kgKyAxfTogdmFsb3JUZXN0ZT0ke3ZhbG9yVGVzdGUudG9GaXhlZCgyKX0sIGRlc2NvbnRvPSR7ZGVzY29udG9SZWFsQ2FsY3VsYWRvLnRvRml4ZWQoMil9JWApO1xuICAgICAgICBcbiAgICAgICAgaWYgKGRlc2NvbnRvUmVhbENhbGN1bGFkbyA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBFcnJvIG5hIHJlZGlzdHJpYnVpw6fDo28sIHRlbnRhciB2YWxvciBtYWlvclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfinYwgRXJybyBuYSByZWRpc3RyaWJ1acOnw6NvLCBhanVzdGFuZG8gdmFsb3IgbcOtbmltbycpO1xuICAgICAgICAgIHZhbG9yTWluID0gdmFsb3JUZXN0ZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgZGlmZXJlbmNhID0gTWF0aC5hYnMoZGVzY29udG9SZWFsQ2FsY3VsYWRvIC0gbm92b0Rlc2NvbnRvUmVhbCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTZSBlbmNvbnRyb3UgdW0gcmVzdWx0YWRvIG1lbGhvciwgZ3VhcmRhclxuICAgICAgICBpZiAoZGlmZXJlbmNhIDwgbWVsaG9yRGlmZXJlbmNhKSB7XG4gICAgICAgICAgbWVsaG9yRGlmZXJlbmNhID0gZGlmZXJlbmNhO1xuICAgICAgICAgIHZhbG9yTmVnb2NpYWRvT3RpbW8gPSB2YWxvclRlc3RlO1xuICAgICAgICAgIG1lbGhvckRlc2NvbnRvID0gZGVzY29udG9SZWFsQ2FsY3VsYWRvO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgTm92byBtZWxob3IgcmVzdWx0YWRvOiBkZXNjb250bz0ke21lbGhvckRlc2NvbnRvLnRvRml4ZWQoMil9JSwgZGlmZXJlbsOnYT0ke21lbGhvckRpZmVyZW5jYS50b0ZpeGVkKDIpfWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTZSBhIGRpZmVyZW7Dp2Egw6kgbXVpdG8gcGVxdWVuYSwgcGFyYXJcbiAgICAgICAgaWYgKGRpZmVyZW5jYSA8IDAuMDUpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+OryBQcmVjaXPDo28gYXRpbmdpZGEhIFBhcmFuZG8gYnVzY2EuYCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIERldGVjdGFyIHNlIGVzdGFtb3Mgbm8gbGltaXRlIGbDrXNpY29cbiAgICAgICAgaWYgKGkgPiAxMCAmJiBtZWxob3JEaWZlcmVuY2EgPiAyKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBQb3Nzw612ZWwgbGltaXRlIGbDrXNpY28gZGV0ZWN0YWRvLiBNZWxob3IgZGVzY29udG8gcG9zc8OtdmVsOiAke21lbGhvckRlc2NvbnRvLnRvRml4ZWQoMil9JWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBBanVzdGFyIG9zIGxpbWl0ZXMgZGEgYnVzY2FcbiAgICAgICAgaWYgKGRlc2NvbnRvUmVhbENhbGN1bGFkbyA8IG5vdm9EZXNjb250b1JlYWwpIHtcbiAgICAgICAgICAvLyBEZXNjb250byBjYWxjdWxhZG8gw6kgbWVub3IgcXVlIG8gZGVzZWphZG8sIHByZWNpc2Ftb3MgZGltaW51aXIgdmFsb3IgbmVnb2NpYWRvXG4gICAgICAgICAgdmFsb3JNYXggPSB2YWxvclRlc3RlO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OJIERlc2NvbnRvIGJhaXhvICgke2Rlc2NvbnRvUmVhbENhbGN1bGFkby50b0ZpeGVkKDIpfSUgPCAke25vdm9EZXNjb250b1JlYWx9JSksIGRpbWludWluZG8gdmFsb3JNYXggcGFyYSAke3ZhbG9yTWF4LnRvRml4ZWQoMil9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGVzY29udG8gY2FsY3VsYWRvIMOpIG1haW9yIHF1ZSBvIGRlc2VqYWRvLCBwcmVjaXNhbW9zIGF1bWVudGFyIHZhbG9yIG5lZ29jaWFkb1xuICAgICAgICAgIHZhbG9yTWluID0gdmFsb3JUZXN0ZTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiCBEZXNjb250byBhbHRvICgke2Rlc2NvbnRvUmVhbENhbGN1bGFkby50b0ZpeGVkKDIpfSUgPiAke25vdm9EZXNjb250b1JlYWx9JSksIGF1bWVudGFuZG8gdmFsb3JNaW4gcGFyYSAke3ZhbG9yTWluLnRvRml4ZWQoMil9YCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFZlcmlmaWNhciBzZSBvIGludGVydmFsbyBmaWNvdSBtdWl0byBwZXF1ZW5vXG4gICAgICAgIGlmIChNYXRoLmFicyh2YWxvck1heCAtIHZhbG9yTWluKSA8IDEwMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEludGVydmFsbyBtdWl0byBwZXF1ZW5vICgke01hdGguYWJzKHZhbG9yTWF4IC0gdmFsb3JNaW4pLnRvRml4ZWQoMil9KSwgZmluYWxpemFuZG8gYnVzY2FgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg8J+PgSBCdXNjYSBmaW5hbGl6YWRhOmApO1xuICAgICAgY29uc29sZS5sb2coYCAgIFZhbG9yIG5lZ29jaWFkbyDDs3RpbW86ICR7dmFsb3JOZWdvY2lhZG9PdGltby50b0ZpeGVkKDIpfWApO1xuICAgICAgY29uc29sZS5sb2coYCAgIERlc2NvbnRvIHJlYWwgcmVzdWx0YW50ZTogJHttZWxob3JEZXNjb250by50b0ZpeGVkKDIpfSVgKTtcbiAgICAgIGNvbnNvbGUubG9nKGAgICBEaWZlcmVuw6dhIGRvIG9iamV0aXZvOiAke21lbGhvckRpZmVyZW5jYS50b0ZpeGVkKDIpfWApO1xuICAgICAgXG4gICAgICAvLyBTZSBhIGRpZmVyZW7Dp2EgYWluZGEgw6kgbXVpdG8gZ3JhbmRlLCBhdmlzYXIgbyB1c3XDoXJpb1xuICAgICAgaWYgKG1lbGhvckRpZmVyZW5jYSA+IDEpIHtcbiAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBOw6NvIGZvaSBwb3Nzw612ZWwgYXRpbmdpciBleGF0YW1lbnRlICR7bm92b0Rlc2NvbnRvUmVhbH0lLiBNZWxob3IgcmVzdWx0YWRvOiAke21lbGhvckRlc2NvbnRvLnRvRml4ZWQoMSl9JWApO1xuICAgICAgICBjb25zdCBjb25maXJtYXIgPSBjb25maXJtKGBOw6NvIGZvaSBwb3Nzw612ZWwgYXRpbmdpciBleGF0YW1lbnRlICR7bm92b0Rlc2NvbnRvUmVhbH0lIGRlIGRlc2NvbnRvIHJlYWwuXFxuTWVsaG9yIHJlc3VsdGFkbyBwb3Nzw612ZWw6ICR7bWVsaG9yRGVzY29udG8udG9GaXhlZCgxKX0lXFxuXFxuRGVzZWphIGFwbGljYXIgbWVzbW8gYXNzaW0/YCk7XG4gICAgICAgIGlmICghY29uZmlybWFyKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQXBsaWNhciBvIHZhbG9yIG5lZ29jaWFkbyDDs3RpbW8gZW5jb250cmFkb1xuICAgICAgY29uc3QgZm9ybWFzUmVkaXN0cmlidWlkYXMgPSByZWRpc3RyaWJ1aXJWYWxvcmVzKHZhbG9yTmVnb2NpYWRvT3RpbW8sIHByZXYuZm9ybWFzUGFnYW1lbnRvKTtcbiAgICAgIFxuICAgICAgaWYgKCFmb3JtYXNSZWRpc3RyaWJ1aWRhcykge1xuICAgICAgICBhbGVydCgnTsOjbyDDqSBwb3Nzw612ZWwgYWx0ZXJhciBvIGRlc2NvbnRvIHJlYWwuIFRvZGFzIGFzIGZvcm1hcyBkZSBwYWdhbWVudG8gZXN0w6NvIHRyYXZhZGFzLicpO1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgdXBkYXRlZCA9IHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgdmFsb3JOZWdvY2lhZG86IHZhbG9yTmVnb2NpYWRvT3RpbW8sXG4gICAgICAgIGZvcm1hc1BhZ2FtZW50bzogZm9ybWFzUmVkaXN0cmlidWlkYXMubWFwKGZvcm1hID0+ICh7XG4gICAgICAgICAgLi4uZm9ybWEsXG4gICAgICAgICAgdmFsb3JSZWNlYmlkbzogY2FsY3VsYXJWYWxvclJlY2ViaWRvRm9ybWEoZm9ybWEpXG4gICAgICAgIH0pKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gUmVjYWxjdWxhciB2YWxvcmVzIGRlcml2YWRvc1xuICAgICAgdXBkYXRlZC52YWxvclJlY2ViaWRvVG90YWwgPSB1cGRhdGVkLmZvcm1hc1BhZ2FtZW50by5yZWR1Y2UoKGFjYywgZm9ybWEpID0+IGFjYyArIGZvcm1hLnZhbG9yUmVjZWJpZG8sIDApO1xuICAgICAgdXBkYXRlZC5kZXNjb250b1JlYWwgPSB1cGRhdGVkLnZhbG9yQnJ1dG8gPiAwID8gKCh1cGRhdGVkLnZhbG9yQnJ1dG8gLSB1cGRhdGVkLnZhbG9yUmVjZWJpZG9Ub3RhbCkgLyB1cGRhdGVkLnZhbG9yQnJ1dG8pICogMTAwIDogMDtcbiAgICAgIFxuICAgICAgY29uc3Qgc29tYUZvcm1hcyA9IHVwZGF0ZWQuZm9ybWFzUGFnYW1lbnRvLnJlZHVjZSgoYWNjLCBmb3JtYSkgPT4gYWNjICsgZm9ybWEudmFsb3IsIDApO1xuICAgICAgdXBkYXRlZC52YWxvclJlc3RhbnRlID0gdXBkYXRlZC52YWxvck5lZ29jaWFkbyAtIHNvbWFGb3JtYXM7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdTaW11bGHDp8OjbyBhdHVhbGl6YWRhIHZpYSBkZXNjb250byByZWFsOicsIHVwZGF0ZWQpO1xuICAgICAgY29uc29sZS5sb2coYERlc2NvbnRvIHJlYWwgcmVzdWx0YW50ZTogJHt1cGRhdGVkLmRlc2NvbnRvUmVhbH0lYCk7XG4gICAgICBcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0pO1xuICB9LCBbcmVkaXN0cmlidWlyVmFsb3JlcywgY2FsY3VsYXJWYWxvclJlY2ViaWRvRm9ybWFdKTtcblxuICBjb25zdCBlZGl0YXJWYWxvckJydXRvID0gdXNlQ2FsbGJhY2soKG5vdm9WYWxvcjogbnVtYmVyKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0VkaXRhbmRvIHZhbG9yIGJydXRvIHBhcmE6Jywgbm92b1ZhbG9yKTtcbiAgICByZWNhbGN1bGFyU2ltdWxhY2FvKHsgdmFsb3JCcnV0bzogbm92b1ZhbG9yIH0pO1xuICB9LCBbcmVjYWxjdWxhclNpbXVsYWNhb10pO1xuXG4gIGNvbnN0IGFkaWNpb25hckZvcm1hID0gdXNlQ2FsbGJhY2soKGZvcm1hOiBPbWl0PEZvcm1hUGFnYW1lbnRvLCAnaWQnIHwgJ3ZhbG9yUmVjZWJpZG8nPikgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdBZGljaW9uYW5kbyBmb3JtYTonLCBmb3JtYSk7XG4gICAgXG4gICAgc2V0U2ltdWxhY2FvKHByZXYgPT4ge1xuICAgICAgLy8gVmVyaWZpY2FyIHRyYXZhbWVudG8gZGUgZGVzY29udG8gcmVhbFxuICAgICAgaWYgKHByZXYudHJhdmFtZW50b3MuZGVzY29udG9SZWFsKSB7XG4gICAgICAgIGNvbnN0IG5vdmFGb3JtYVRlbXA6IEZvcm1hUGFnYW1lbnRvID0ge1xuICAgICAgICAgIC4uLmZvcm1hLFxuICAgICAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXG4gICAgICAgICAgdmFsb3JSZWNlYmlkbzogMFxuICAgICAgICB9O1xuICAgICAgICBub3ZhRm9ybWFUZW1wLnZhbG9yUmVjZWJpZG8gPSBjYWxjdWxhclZhbG9yUmVjZWJpZG9Gb3JtYShub3ZhRm9ybWFUZW1wKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IG5vdm9WYWxvclJlY2ViaWRvVG90YWwgPSBwcmV2LnZhbG9yUmVjZWJpZG9Ub3RhbCArIG5vdmFGb3JtYVRlbXAudmFsb3JSZWNlYmlkbztcbiAgICAgICAgY29uc3Qgbm92b0Rlc2NvbnRvUmVhbCA9IHByZXYudmFsb3JCcnV0byA+IDAgPyAoKHByZXYudmFsb3JCcnV0byAtIG5vdm9WYWxvclJlY2ViaWRvVG90YWwpIC8gcHJldi52YWxvckJydXRvKSAqIDEwMCA6IDA7XG4gICAgICAgIFxuICAgICAgICBpZiAobm92b0Rlc2NvbnRvUmVhbCA+IHByZXYudHJhdmFtZW50b3MubGltaXRlRGVzY29udG9SZWFsKSB7XG4gICAgICAgICAgYWxlcnQoYE7Do28gw6kgcG9zc8OtdmVsIGFkaWNpb25hciBlc3RhIGZvcm1hLiBPIGRlc2NvbnRvIHJlYWwgZXhjZWRlcmlhIG8gbGltaXRlIGRlICR7cHJldi50cmF2YW1lbnRvcy5saW1pdGVEZXNjb250b1JlYWx9JWApO1xuICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IG5vdmFGb3JtYTogRm9ybWFQYWdhbWVudG8gPSB7XG4gICAgICAgIC4uLmZvcm1hLFxuICAgICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLFxuICAgICAgICB2YWxvclJlY2ViaWRvOiAwLFxuICAgICAgICB0cmF2YWRvOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgbm92YUZvcm1hLnZhbG9yUmVjZWJpZG8gPSBjYWxjdWxhclZhbG9yUmVjZWJpZG9Gb3JtYShub3ZhRm9ybWEpO1xuICAgICAgXG4gICAgICBjb25zdCBub3Zhc0Zvcm1hcyA9IFsuLi5wcmV2LmZvcm1hc1BhZ2FtZW50bywgbm92YUZvcm1hXTtcbiAgICAgIGNvbnN0IHVwZGF0ZWQgPSB7IC4uLnByZXYsIGZvcm1hc1BhZ2FtZW50bzogbm92YXNGb3JtYXMgfTtcbiAgICAgIFxuICAgICAgdXBkYXRlZC52YWxvclJlY2ViaWRvVG90YWwgPSBub3Zhc0Zvcm1hcy5yZWR1Y2UoKGFjYywgZikgPT4gYWNjICsgZi52YWxvclJlY2ViaWRvLCAwKTtcbiAgICAgIHVwZGF0ZWQuZGVzY29udG9SZWFsID0gdXBkYXRlZC52YWxvckJydXRvID4gMCA/ICgodXBkYXRlZC52YWxvckJydXRvIC0gdXBkYXRlZC52YWxvclJlY2ViaWRvVG90YWwpIC8gdXBkYXRlZC52YWxvckJydXRvKSAqIDEwMCA6IDA7XG4gICAgICBcbiAgICAgIGNvbnN0IHNvbWFGb3JtYXMgPSBub3Zhc0Zvcm1hcy5yZWR1Y2UoKGFjYywgZikgPT4gYWNjICsgZi52YWxvciwgMCk7XG4gICAgICB1cGRhdGVkLnZhbG9yUmVzdGFudGUgPSB1cGRhdGVkLnZhbG9yTmVnb2NpYWRvIC0gc29tYUZvcm1hcztcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ05vdmEgc2ltdWxhw6fDo28gY29tIGZvcm1hIGFkaWNpb25hZGE6JywgdXBkYXRlZCk7XG4gICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9KTtcbiAgfSwgW2NhbGN1bGFyVmFsb3JSZWNlYmlkb0Zvcm1hXSk7XG5cbiAgY29uc3QgYXR1YWxpemFyRm9ybWEgPSB1c2VDYWxsYmFjaygoaWQ6IHN0cmluZywgZGFkb3NBdHVhbGl6YWRvczogT21pdDxGb3JtYVBhZ2FtZW50bywgJ2lkJyB8ICd2YWxvclJlY2ViaWRvJz4pID0+IHtcbiAgICBjb25zb2xlLmxvZygnQXR1YWxpemFuZG8gZm9ybWE6JywgaWQsIGRhZG9zQXR1YWxpemFkb3MpO1xuICAgIFxuICAgIHNldFNpbXVsYWNhbyhwcmV2ID0+IHtcbiAgICAgIGNvbnN0IG5vdmFzRm9ybWFzID0gcHJldi5mb3JtYXNQYWdhbWVudG8ubWFwKGZvcm1hID0+IHtcbiAgICAgICAgaWYgKGZvcm1hLmlkID09PSBpZCkge1xuICAgICAgICAgIC8vIFNlIGEgZm9ybWEgZXN0w6EgdHJhdmFkYSwgbsOjbyBwZXJtaXRlIGFsdGVyYXIgbyB2YWxvclxuICAgICAgICAgIGlmIChmb3JtYS50cmF2YWRvICYmIGRhZG9zQXR1YWxpemFkb3MudmFsb3IgIT09IGZvcm1hLnZhbG9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRm9ybWEgdHJhdmFkYSwgbsOjbyDDqSBwb3Nzw612ZWwgYWx0ZXJhciBvIHZhbG9yJyk7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWE7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGZvcm1hQXR1YWxpemFkYSA9IHsgLi4uZm9ybWEsIC4uLmRhZG9zQXR1YWxpemFkb3MgfTtcbiAgICAgICAgICBmb3JtYUF0dWFsaXphZGEudmFsb3JSZWNlYmlkbyA9IGNhbGN1bGFyVmFsb3JSZWNlYmlkb0Zvcm1hKGZvcm1hQXR1YWxpemFkYSk7XG4gICAgICAgICAgcmV0dXJuIGZvcm1hQXR1YWxpemFkYTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWE7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdXBkYXRlZCA9IHsgLi4ucHJldiwgZm9ybWFzUGFnYW1lbnRvOiBub3Zhc0Zvcm1hcyB9O1xuICAgICAgXG4gICAgICB1cGRhdGVkLnZhbG9yUmVjZWJpZG9Ub3RhbCA9IG5vdmFzRm9ybWFzLnJlZHVjZSgoYWNjLCBmKSA9PiBhY2MgKyBmLnZhbG9yUmVjZWJpZG8sIDApO1xuICAgICAgdXBkYXRlZC5kZXNjb250b1JlYWwgPSB1cGRhdGVkLnZhbG9yQnJ1dG8gPiAwID8gKCh1cGRhdGVkLnZhbG9yQnJ1dG8gLSB1cGRhdGVkLnZhbG9yUmVjZWJpZG9Ub3RhbCkgLyB1cGRhdGVkLnZhbG9yQnJ1dG8pICogMTAwIDogMDtcbiAgICAgIFxuICAgICAgY29uc3Qgc29tYUZvcm1hcyA9IG5vdmFzRm9ybWFzLnJlZHVjZSgoYWNjLCBmKSA9PiBhY2MgKyBmLnZhbG9yLCAwKTtcbiAgICAgIHVwZGF0ZWQudmFsb3JSZXN0YW50ZSA9IHVwZGF0ZWQudmFsb3JOZWdvY2lhZG8gLSBzb21hRm9ybWFzO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnU2ltdWxhw6fDo28gYXR1YWxpemFkYSBhcMOzcyBlZGnDp8OjbzonLCB1cGRhdGVkKTtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0pO1xuICB9LCBbY2FsY3VsYXJWYWxvclJlY2ViaWRvRm9ybWFdKTtcblxuICBjb25zdCByZW1vdmVyRm9ybWEgPSB1c2VDYWxsYmFjaygoaWQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdSZW1vdmVuZG8gZm9ybWE6JywgaWQpO1xuICAgIFxuICAgIHNldFNpbXVsYWNhbyhwcmV2ID0+IHtcbiAgICAgIGNvbnN0IG5vdmFzRm9ybWFzID0gcHJldi5mb3JtYXNQYWdhbWVudG8uZmlsdGVyKGYgPT4gZi5pZCAhPT0gaWQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgZm9ybWFzUGFnYW1lbnRvOiBub3Zhc0Zvcm1hcyxcbiAgICAgICAgdmFsb3JSZWNlYmlkb1RvdGFsOiBub3Zhc0Zvcm1hcy5yZWR1Y2UoKGFjYywgZikgPT4gYWNjICsgZi52YWxvclJlY2ViaWRvLCAwKSxcbiAgICAgICAgZGVzY29udG9SZWFsOiBwcmV2LnZhbG9yQnJ1dG8gPiAwID8gKChwcmV2LnZhbG9yQnJ1dG8gLSBub3Zhc0Zvcm1hcy5yZWR1Y2UoKGFjYywgZikgPT4gYWNjICsgZi52YWxvclJlY2ViaWRvLCAwKSkgLyBwcmV2LnZhbG9yQnJ1dG8pICogMTAwIDogMCxcbiAgICAgICAgdmFsb3JSZXN0YW50ZTogcHJldi52YWxvck5lZ29jaWFkbyAtIG5vdmFzRm9ybWFzLnJlZHVjZSgoYWNjLCBmKSA9PiBhY2MgKyBmLnZhbG9yLCAwKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGxpbXBhckZvcm1hcyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnTGltcGFuZG8gdG9kYXMgYXMgZm9ybWFzJyk7XG4gICAgc2V0U2ltdWxhY2FvKHByZXYgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICBmb3JtYXNQYWdhbWVudG86IFtdLFxuICAgICAgdmFsb3JSZWNlYmlkb1RvdGFsOiAwLFxuICAgICAgZGVzY29udG9SZWFsOiBwcmV2LnZhbG9yQnJ1dG8gPiAwID8gMTAwIDogMCxcbiAgICAgIHZhbG9yUmVzdGFudGU6IHByZXYudmFsb3JOZWdvY2lhZG9cbiAgICB9KSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBhbHRlcm5hclRyYXZhbWVudG8gPSB1c2VDYWxsYmFjaygodGlwbzoga2V5b2YgVHJhdmFtZW50b0NvbmZpZywgdmFsb3I/OiBudW1iZXIpID0+IHtcbiAgICBzZXRTaW11bGFjYW8ocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIHRyYXZhbWVudG9zOiB7XG4gICAgICAgIC4uLnByZXYudHJhdmFtZW50b3MsXG4gICAgICAgIFt0aXBvXTogIXByZXYudHJhdmFtZW50b3NbdGlwb10sXG4gICAgICAgIC4uLih2YWxvciAhPT0gdW5kZWZpbmVkICYmIHsgbGltaXRlRGVzY29udG9SZWFsOiB2YWxvciB9KVxuICAgICAgfVxuICAgIH0pKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGFsdGVybmFyVHJhdmFtZW50b0Zvcm1hID0gdXNlQ2FsbGJhY2soKGlkOiBzdHJpbmcpID0+IHtcbiAgICBzZXRTaW11bGFjYW8ocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIGZvcm1hc1BhZ2FtZW50bzogcHJldi5mb3JtYXNQYWdhbWVudG8ubWFwKGZvcm1hID0+IFxuICAgICAgICBmb3JtYS5pZCA9PT0gaWQgPyB7IC4uLmZvcm1hLCB0cmF2YWRvOiAhZm9ybWEudHJhdmFkbyB9IDogZm9ybWFcbiAgICAgIClcbiAgICB9KSk7XG4gIH0sIFtdKTtcblxuICByZXR1cm4ge1xuICAgIHNpbXVsYWNhbyxcbiAgICByZWNhbGN1bGFyU2ltdWxhY2FvLFxuICAgIGFkaWNpb25hckZvcm1hLFxuICAgIGF0dWFsaXphckZvcm1hLFxuICAgIHJlbW92ZXJGb3JtYSxcbiAgICBsaW1wYXJGb3JtYXMsXG4gICAgYWx0ZXJuYXJUcmF2YW1lbnRvLFxuICAgIGFsdGVybmFyVHJhdmFtZW50b0Zvcm1hLFxuICAgIGVkaXRhclZhbG9yTmVnb2NpYWRvLFxuICAgIGVkaXRhclZhbG9yQnJ1dG8sXG4gICAgZWRpdGFyRGVzY29udG9SZWFsXG4gIH07XG59O1xuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VNZW1vIiwidXNlU2ltdWxhZG9yIiwic2ltdWxhY2FvIiwic2V0U2ltdWxhY2FvIiwidmFsb3JCcnV0byIsImRlc2NvbnRvIiwidmFsb3JOZWdvY2lhZG8iLCJmb3JtYXNQYWdhbWVudG8iLCJ2YWxvclJlY2ViaWRvVG90YWwiLCJkZXNjb250b1JlYWwiLCJ2YWxvclJlc3RhbnRlIiwidHJhdmFtZW50b3MiLCJsaW1pdGVEZXNjb250b1JlYWwiLCJQUklPUklEQURFX0ZPUk1BUyIsImNhbGN1bGFyVmFsb3JSZWNlYmlkb0Zvcm1hIiwiZm9ybWEiLCJjb25zb2xlIiwibG9nIiwidGlwbyIsInZhbG9yIiwicGFyY2VsYXMiLCJ0YXhhSnVyb3MiLCJpIiwidmFsb3JQcmVzZW50ZSIsIk1hdGgiLCJwb3ciLCJkZWZsYWNhbyIsImp1cm9zQW50ZWNpcGFjYW8iLCJmYXRvckRlZmxhY2FvIiwiZmF0b3JKdXJvcyIsInZhbG9yUmVjZWJpZG8iLCJjdXN0b0NhcGl0YWwiLCJpYyIsInZhbG9yUHJlc2VudGVCb2xldG8iLCJyZWRpc3RyaWJ1aXJWYWxvcmVzIiwibm92b1ZhbG9yTmVnb2NpYWRvIiwiZm9ybWFzQXR1YWlzIiwic29tYUF0dWFsIiwicmVkdWNlIiwiYWNjIiwiZGlmZXJlbmNhIiwiYWJzIiwiZm9ybWFzVHJhdmFkYXMiLCJmaWx0ZXIiLCJ0cmF2YWRvIiwiZm9ybWFzTmFvVHJhdmFkYXMiLCJsZW5ndGgiLCJmb3JtYXNPcmRlbmFkYXMiLCJzb3J0IiwiYSIsImIiLCJwcmlvcmlkYWRlQSIsImluZGV4T2YiLCJwcmlvcmlkYWRlQiIsIm1hcCIsImYiLCJub3Zhc0Zvcm1hcyIsInNvbWFGb3JtYXNOYW9UcmF2YWRhcyIsImFqdXN0ZVBvckZvcm1hIiwiZm9yRWFjaCIsImZvcm1hSW5kZXgiLCJmaW5kSW5kZXgiLCJpZCIsIm5vdm9WYWxvciIsIm1heCIsInByaW1laXJhRm9ybWEiLCJ2YWxvckNhbGN1bGFkbyIsInJlY2FsY3VsYXJTaW11bGFjYW8iLCJ1cGRhdGVzIiwicHJldiIsInVwZGF0ZWQiLCJ1bmRlZmluZWQiLCJzb21hRm9ybWFzIiwiZWRpdGFyVmFsb3JOZWdvY2lhZG8iLCJmb3JtYXNSZWRpc3RyaWJ1aWRhcyIsImFsZXJ0IiwiZWRpdGFyRGVzY29udG9SZWFsIiwibm92b0Rlc2NvbnRvUmVhbCIsImNhbGN1bGFyRGVzY29udG9SZWFsUGFyYVZhbG9yIiwiZm9ybWFzVGVtcCIsInZhbG9yUmVjZWJpZG9UZW1wIiwiZm9ybWFDb21SZWNlYmlkbyIsInZhbG9yTWluIiwidmFsb3JNYXgiLCJ2YWxvck5lZ29jaWFkb090aW1vIiwibWVsaG9yRGlmZXJlbmNhIiwiSW5maW5pdHkiLCJtZWxob3JEZXNjb250byIsInZhbG9yVGVzdGUiLCJkZXNjb250b1JlYWxDYWxjdWxhZG8iLCJ0b0ZpeGVkIiwiY29uZmlybWFyIiwiY29uZmlybSIsImVkaXRhclZhbG9yQnJ1dG8iLCJhZGljaW9uYXJGb3JtYSIsIm5vdmFGb3JtYVRlbXAiLCJEYXRlIiwibm93IiwidG9TdHJpbmciLCJub3ZvVmFsb3JSZWNlYmlkb1RvdGFsIiwibm92YUZvcm1hIiwiYXR1YWxpemFyRm9ybWEiLCJkYWRvc0F0dWFsaXphZG9zIiwiZm9ybWFBdHVhbGl6YWRhIiwicmVtb3ZlckZvcm1hIiwibGltcGFyRm9ybWFzIiwiYWx0ZXJuYXJUcmF2YW1lbnRvIiwiYWx0ZXJuYXJUcmF2YW1lbnRvRm9ybWEiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useSimulador.ts\n"));

/***/ })

});