"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useSimulador.ts":
/*!***********************************!*\
  !*** ./src/hooks/useSimulador.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSimulador: () => (/* binding */ useSimulador)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst useSimulador = ()=>{\n    const [simulacao, setSimulacao] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        valorBruto: 0,\n        desconto: 0,\n        valorNegociado: 0,\n        formasPagamento: [],\n        valorRecebidoTotal: 0,\n        descontoReal: 0,\n        valorRestante: 0,\n        travamentos: {\n            valorNegociado: false,\n            descontoReal: false,\n            limiteDescontoReal: 25\n        }\n    });\n    // Prioridade para redistribuição de valores\n    const PRIORIDADE_FORMAS = [\n        'ENTRADA',\n        'BOLETO',\n        'FINANCEIRA',\n        'CARTAO'\n    ];\n    const calcularValorRecebidoForma = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[calcularValorRecebidoForma]\": (forma)=>{\n            console.log('Calculando valor recebido para:', forma);\n            switch(forma.tipo){\n                case 'ENTRADA':\n                    return forma.valor;\n                case 'FINANCEIRA':\n                    {\n                        if (!forma.parcelas || !forma.taxaJuros) return forma.valor;\n                        const i = forma.taxaJuros / 100;\n                        const parcelas = forma.parcelas;\n                        const valorPresente = forma.valor / Math.pow(1 + i, parcelas);\n                        console.log(\"Financeira: valor=\".concat(forma.valor, \", parcelas=\").concat(parcelas, \", taxa=\").concat(forma.taxaJuros, \"%, VP=\").concat(valorPresente));\n                        return valorPresente;\n                    }\n                case 'CARTAO':\n                    {\n                        if (!forma.deflacao || !forma.jurosAntecipacao || !forma.parcelas) return forma.valor;\n                        const fatorDeflacao = 1 - forma.deflacao / 100;\n                        const fatorJuros = 1 - forma.jurosAntecipacao / 100 * forma.parcelas;\n                        const valorRecebido = forma.valor * fatorDeflacao * fatorJuros;\n                        console.log(\"Cart\\xe3o: valor=\".concat(forma.valor, \", defla\\xe7\\xe3o=\").concat(forma.deflacao, \"%, juros=\").concat(forma.jurosAntecipacao, \"%, VR=\").concat(valorRecebido));\n                        return valorRecebido;\n                    }\n                case 'BOLETO':\n                    {\n                        if (!forma.parcelas || !forma.custoCapital) return forma.valor;\n                        const ic = forma.custoCapital / 100;\n                        const valorPresenteBoleto = forma.valor / Math.pow(1 + ic, forma.parcelas);\n                        console.log(\"Boleto: valor=\".concat(forma.valor, \", parcelas=\").concat(forma.parcelas, \", custo=\").concat(forma.custoCapital, \"%, VP=\").concat(valorPresenteBoleto));\n                        return valorPresenteBoleto;\n                    }\n                default:\n                    return forma.valor;\n            }\n        }\n    }[\"useSimulador.useCallback[calcularValorRecebidoForma]\"], []);\n    const redistribuirValores = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[redistribuirValores]\": (novoValorNegociado, formasAtuais)=>{\n            console.log('Redistribuindo valores. Novo valor negociado:', novoValorNegociado);\n            const somaAtual = formasAtuais.reduce({\n                \"useSimulador.useCallback[redistribuirValores].somaAtual\": (acc, forma)=>acc + forma.valor\n            }[\"useSimulador.useCallback[redistribuirValores].somaAtual\"], 0);\n            const diferenca = novoValorNegociado - somaAtual;\n            if (Math.abs(diferenca) < 0.01) {\n                return formasAtuais; // Não há diferença significativa\n            }\n            console.log('Diferença a redistribuir:', diferenca);\n            // Separar formas travadas e não travadas\n            const formasTravadas = formasAtuais.filter({\n                \"useSimulador.useCallback[redistribuirValores].formasTravadas\": (forma)=>forma.travado\n            }[\"useSimulador.useCallback[redistribuirValores].formasTravadas\"]);\n            const formasNaoTravadas = formasAtuais.filter({\n                \"useSimulador.useCallback[redistribuirValores].formasNaoTravadas\": (forma)=>!forma.travado\n            }[\"useSimulador.useCallback[redistribuirValores].formasNaoTravadas\"]);\n            // Se todas estão travadas, não podemos redistribuir\n            if (formasNaoTravadas.length === 0) {\n                console.log('Todas as formas estão travadas');\n                return null; // Indica erro\n            }\n            // Ordenar formas não travadas por prioridade\n            const formasOrdenadas = formasNaoTravadas.sort({\n                \"useSimulador.useCallback[redistribuirValores].formasOrdenadas\": (a, b)=>{\n                    const prioridadeA = PRIORIDADE_FORMAS.indexOf(a.tipo);\n                    const prioridadeB = PRIORIDADE_FORMAS.indexOf(b.tipo);\n                    return prioridadeA - prioridadeB;\n                }\n            }[\"useSimulador.useCallback[redistribuirValores].formasOrdenadas\"]);\n            console.log('Formas ordenadas por prioridade:', formasOrdenadas.map({\n                \"useSimulador.useCallback[redistribuirValores]\": (f)=>f.tipo\n            }[\"useSimulador.useCallback[redistribuirValores]\"]));\n            // Redistribuir a diferença: apenas a primeira forma na ordem de prioridade absorve toda a diferença\n            const novasFormas = [\n                ...formasAtuais\n            ];\n            // Verificar se todas as formas não travadas têm valor zero\n            const somaFormasNaoTravadas = formasOrdenadas.reduce({\n                \"useSimulador.useCallback[redistribuirValores].somaFormasNaoTravadas\": (acc, forma)=>acc + forma.valor\n            }[\"useSimulador.useCallback[redistribuirValores].somaFormasNaoTravadas\"], 0);\n            if (somaFormasNaoTravadas === 0) {\n                // Se todas as formas não travadas têm valor 0, distribui igualmente\n                console.log('Todas as formas não travadas têm valor zero, distribuindo igualmente');\n                const ajustePorForma = diferenca / formasOrdenadas.length;\n                formasOrdenadas.forEach({\n                    \"useSimulador.useCallback[redistribuirValores]\": (forma)=>{\n                        const formaIndex = novasFormas.findIndex({\n                            \"useSimulador.useCallback[redistribuirValores].formaIndex\": (f)=>f.id === forma.id\n                        }[\"useSimulador.useCallback[redistribuirValores].formaIndex\"]);\n                        const novoValor = Math.max(0, ajustePorForma);\n                        novasFormas[formaIndex] = {\n                            ...novasFormas[formaIndex],\n                            valor: novoValor\n                        };\n                    }\n                }[\"useSimulador.useCallback[redistribuirValores]\"]);\n            } else {\n                // Apenas a primeira forma não travada na ordem de prioridade absorve toda a diferença\n                console.log('Ajustando apenas a primeira forma na ordem de prioridade');\n                const primeiraForma = formasOrdenadas[0];\n                const formaIndex = novasFormas.findIndex({\n                    \"useSimulador.useCallback[redistribuirValores].formaIndex\": (f)=>f.id === primeiraForma.id\n                }[\"useSimulador.useCallback[redistribuirValores].formaIndex\"]);\n                const novoValor = Math.max(0, primeiraForma.valor + diferenca);\n                novasFormas[formaIndex] = {\n                    ...novasFormas[formaIndex],\n                    valor: novoValor\n                };\n                console.log(\"Forma \".concat(primeiraForma.tipo, \" ajustada de \").concat(primeiraForma.valor, \" para \").concat(novoValor));\n            }\n            return novasFormas;\n        }\n    }[\"useSimulador.useCallback[redistribuirValores]\"], []);\n    const recalcularSimulacao = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[recalcularSimulacao]\": (updates)=>{\n            console.log('Recalculando simulação com updates:', updates);\n            setSimulacao({\n                \"useSimulador.useCallback[recalcularSimulacao]\": (prev)=>{\n                    const updated = {\n                        ...prev,\n                        ...updates\n                    };\n                    // Lógica de travamento do valor negociado\n                    if (updated.travamentos.valorNegociado) {\n                        // Se valor negociado está travado, ajusta o desconto quando valor bruto muda\n                        if (updates.valorBruto !== undefined && updates.valorBruto > 0) {\n                            updated.desconto = (updated.valorBruto - updated.valorNegociado) / updated.valorBruto * 100;\n                        }\n                    } else {\n                        // Comportamento normal: calcula valor negociado baseado no desconto\n                        updated.valorNegociado = updated.valorBruto * (1 - updated.desconto / 100);\n                    }\n                    updated.formasPagamento = updated.formasPagamento.map({\n                        \"useSimulador.useCallback[recalcularSimulacao]\": (forma)=>({\n                                ...forma,\n                                valorRecebido: calcularValorRecebidoForma(forma)\n                            })\n                    }[\"useSimulador.useCallback[recalcularSimulacao]\"]);\n                    updated.valorRecebidoTotal = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[recalcularSimulacao]\": (acc, forma)=>acc + forma.valorRecebido\n                    }[\"useSimulador.useCallback[recalcularSimulacao]\"], 0);\n                    updated.descontoReal = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorRecebidoTotal) / updated.valorBruto * 100 : 0;\n                    const somaFormas = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[recalcularSimulacao].somaFormas\": (acc, forma)=>acc + forma.valor\n                    }[\"useSimulador.useCallback[recalcularSimulacao].somaFormas\"], 0);\n                    updated.valorRestante = updated.valorNegociado - somaFormas;\n                    console.log('Simulação atualizada:', updated);\n                    return updated;\n                }\n            }[\"useSimulador.useCallback[recalcularSimulacao]\"]);\n        }\n    }[\"useSimulador.useCallback[recalcularSimulacao]\"], [\n        calcularValorRecebidoForma\n    ]);\n    const editarValorNegociado = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[editarValorNegociado]\": (novoValor)=>{\n            console.log('Editando valor negociado para:', novoValor);\n            setSimulacao({\n                \"useSimulador.useCallback[editarValorNegociado]\": (prev)=>{\n                    const formasRedistribuidas = redistribuirValores(novoValor, prev.formasPagamento);\n                    if (!formasRedistribuidas) {\n                        alert('Não é possível alterar o valor. Todas as formas de pagamento estão travadas.');\n                        return prev;\n                    }\n                    const updated = {\n                        ...prev,\n                        valorNegociado: novoValor,\n                        formasPagamento: formasRedistribuidas.map({\n                            \"useSimulador.useCallback[editarValorNegociado]\": (forma)=>({\n                                    ...forma,\n                                    valorRecebido: calcularValorRecebidoForma(forma)\n                                })\n                        }[\"useSimulador.useCallback[editarValorNegociado]\"])\n                    };\n                    // Recalcular desconto\n                    updated.desconto = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorNegociado) / updated.valorBruto * 100 : 0;\n                    updated.valorRecebidoTotal = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[editarValorNegociado]\": (acc, forma)=>acc + forma.valorRecebido\n                    }[\"useSimulador.useCallback[editarValorNegociado]\"], 0);\n                    updated.descontoReal = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorRecebidoTotal) / updated.valorBruto * 100 : 0;\n                    const somaFormas = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[editarValorNegociado].somaFormas\": (acc, forma)=>acc + forma.valor\n                    }[\"useSimulador.useCallback[editarValorNegociado].somaFormas\"], 0);\n                    updated.valorRestante = updated.valorNegociado - somaFormas;\n                    return updated;\n                }\n            }[\"useSimulador.useCallback[editarValorNegociado]\"]);\n        }\n    }[\"useSimulador.useCallback[editarValorNegociado]\"], [\n        redistribuirValores,\n        calcularValorRecebidoForma\n    ]);\n    const editarDescontoReal = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[editarDescontoReal]\": (novoDesconto)=>{\n            console.log('Editando desconto real para:', novoDesconto);\n            setSimulacao({\n                \"useSimulador.useCallback[editarDescontoReal]\": (prev)=>{\n                    // Calcular novo valor negociado baseado no desconto\n                    const novoValorNegociado = prev.valorBruto * (1 - novoDesconto / 100);\n                    const formasRedistribuidas = redistribuirValores(novoValorNegociado, prev.formasPagamento);\n                    if (!formasRedistribuidas) {\n                        alert('Não é possível alterar o desconto. Todas as formas de pagamento estão travadas.');\n                        return prev;\n                    }\n                    const updated = {\n                        ...prev,\n                        desconto: novoDesconto,\n                        valorNegociado: novoValorNegociado,\n                        formasPagamento: formasRedistribuidas.map({\n                            \"useSimulador.useCallback[editarDescontoReal]\": (forma)=>({\n                                    ...forma,\n                                    valorRecebido: calcularValorRecebidoForma(forma)\n                                })\n                        }[\"useSimulador.useCallback[editarDescontoReal]\"])\n                    };\n                    updated.valorRecebidoTotal = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[editarDescontoReal]\": (acc, forma)=>acc + forma.valorRecebido\n                    }[\"useSimulador.useCallback[editarDescontoReal]\"], 0);\n                    updated.descontoReal = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorRecebidoTotal) / updated.valorBruto * 100 : 0;\n                    const somaFormas = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[editarDescontoReal].somaFormas\": (acc, forma)=>acc + forma.valor\n                    }[\"useSimulador.useCallback[editarDescontoReal].somaFormas\"], 0);\n                    updated.valorRestante = updated.valorNegociado - somaFormas;\n                    return updated;\n                }\n            }[\"useSimulador.useCallback[editarDescontoReal]\"]);\n        }\n    }[\"useSimulador.useCallback[editarDescontoReal]\"], [\n        redistribuirValores,\n        calcularValorRecebidoForma\n    ]);\n    const editarValorBruto = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[editarValorBruto]\": (novoValor)=>{\n            console.log('Editando valor bruto para:', novoValor);\n            recalcularSimulacao({\n                valorBruto: novoValor\n            });\n        }\n    }[\"useSimulador.useCallback[editarValorBruto]\"], [\n        recalcularSimulacao\n    ]);\n    const adicionarForma = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[adicionarForma]\": (forma)=>{\n            console.log('Adicionando forma:', forma);\n            setSimulacao({\n                \"useSimulador.useCallback[adicionarForma]\": (prev)=>{\n                    // Verificar travamento de desconto real\n                    if (prev.travamentos.descontoReal) {\n                        const novaFormaTemp = {\n                            ...forma,\n                            id: Date.now().toString(),\n                            valorRecebido: 0\n                        };\n                        novaFormaTemp.valorRecebido = calcularValorRecebidoForma(novaFormaTemp);\n                        const novoValorRecebidoTotal = prev.valorRecebidoTotal + novaFormaTemp.valorRecebido;\n                        const novoDescontoReal = prev.valorBruto > 0 ? (prev.valorBruto - novoValorRecebidoTotal) / prev.valorBruto * 100 : 0;\n                        if (novoDescontoReal > prev.travamentos.limiteDescontoReal) {\n                            alert(\"N\\xe3o \\xe9 poss\\xedvel adicionar esta forma. O desconto real excederia o limite de \".concat(prev.travamentos.limiteDescontoReal, \"%\"));\n                            return prev;\n                        }\n                    }\n                    const novaForma = {\n                        ...forma,\n                        id: Date.now().toString(),\n                        valorRecebido: 0,\n                        travado: false\n                    };\n                    novaForma.valorRecebido = calcularValorRecebidoForma(novaForma);\n                    const novasFormas = [\n                        ...prev.formasPagamento,\n                        novaForma\n                    ];\n                    const updated = {\n                        ...prev,\n                        formasPagamento: novasFormas\n                    };\n                    updated.valorRecebidoTotal = novasFormas.reduce({\n                        \"useSimulador.useCallback[adicionarForma]\": (acc, f)=>acc + f.valorRecebido\n                    }[\"useSimulador.useCallback[adicionarForma]\"], 0);\n                    updated.descontoReal = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorRecebidoTotal) / updated.valorBruto * 100 : 0;\n                    const somaFormas = novasFormas.reduce({\n                        \"useSimulador.useCallback[adicionarForma].somaFormas\": (acc, f)=>acc + f.valor\n                    }[\"useSimulador.useCallback[adicionarForma].somaFormas\"], 0);\n                    updated.valorRestante = updated.valorNegociado - somaFormas;\n                    console.log('Nova simulação com forma adicionada:', updated);\n                    return updated;\n                }\n            }[\"useSimulador.useCallback[adicionarForma]\"]);\n        }\n    }[\"useSimulador.useCallback[adicionarForma]\"], [\n        calcularValorRecebidoForma\n    ]);\n    const atualizarForma = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[atualizarForma]\": (id, dadosAtualizados)=>{\n            console.log('Atualizando forma:', id, dadosAtualizados);\n            setSimulacao({\n                \"useSimulador.useCallback[atualizarForma]\": (prev)=>{\n                    const novasFormas = prev.formasPagamento.map({\n                        \"useSimulador.useCallback[atualizarForma].novasFormas\": (forma)=>{\n                            if (forma.id === id) {\n                                // Se a forma está travada, não permite alterar o valor\n                                if (forma.travado && dadosAtualizados.valor !== forma.valor) {\n                                    console.log('Forma travada, não é possível alterar o valor');\n                                    return forma;\n                                }\n                                const formaAtualizada = {\n                                    ...forma,\n                                    ...dadosAtualizados\n                                };\n                                formaAtualizada.valorRecebido = calcularValorRecebidoForma(formaAtualizada);\n                                return formaAtualizada;\n                            }\n                            return forma;\n                        }\n                    }[\"useSimulador.useCallback[atualizarForma].novasFormas\"]);\n                    const updated = {\n                        ...prev,\n                        formasPagamento: novasFormas\n                    };\n                    updated.valorRecebidoTotal = novasFormas.reduce({\n                        \"useSimulador.useCallback[atualizarForma]\": (acc, f)=>acc + f.valorRecebido\n                    }[\"useSimulador.useCallback[atualizarForma]\"], 0);\n                    updated.descontoReal = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorRecebidoTotal) / updated.valorBruto * 100 : 0;\n                    const somaFormas = novasFormas.reduce({\n                        \"useSimulador.useCallback[atualizarForma].somaFormas\": (acc, f)=>acc + f.valor\n                    }[\"useSimulador.useCallback[atualizarForma].somaFormas\"], 0);\n                    updated.valorRestante = updated.valorNegociado - somaFormas;\n                    console.log('Simulação atualizada após edição:', updated);\n                    return updated;\n                }\n            }[\"useSimulador.useCallback[atualizarForma]\"]);\n        }\n    }[\"useSimulador.useCallback[atualizarForma]\"], [\n        calcularValorRecebidoForma\n    ]);\n    const removerForma = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[removerForma]\": (id)=>{\n            console.log('Removendo forma:', id);\n            setSimulacao({\n                \"useSimulador.useCallback[removerForma]\": (prev)=>{\n                    const novasFormas = prev.formasPagamento.filter({\n                        \"useSimulador.useCallback[removerForma].novasFormas\": (f)=>f.id !== id\n                    }[\"useSimulador.useCallback[removerForma].novasFormas\"]);\n                    return {\n                        ...prev,\n                        formasPagamento: novasFormas,\n                        valorRecebidoTotal: novasFormas.reduce({\n                            \"useSimulador.useCallback[removerForma]\": (acc, f)=>acc + f.valorRecebido\n                        }[\"useSimulador.useCallback[removerForma]\"], 0),\n                        descontoReal: prev.valorBruto > 0 ? (prev.valorBruto - novasFormas.reduce({\n                            \"useSimulador.useCallback[removerForma]\": (acc, f)=>acc + f.valorRecebido\n                        }[\"useSimulador.useCallback[removerForma]\"], 0)) / prev.valorBruto * 100 : 0,\n                        valorRestante: prev.valorNegociado - novasFormas.reduce({\n                            \"useSimulador.useCallback[removerForma]\": (acc, f)=>acc + f.valor\n                        }[\"useSimulador.useCallback[removerForma]\"], 0)\n                    };\n                }\n            }[\"useSimulador.useCallback[removerForma]\"]);\n        }\n    }[\"useSimulador.useCallback[removerForma]\"], []);\n    const limparFormas = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[limparFormas]\": ()=>{\n            console.log('Limpando todas as formas');\n            setSimulacao({\n                \"useSimulador.useCallback[limparFormas]\": (prev)=>({\n                        ...prev,\n                        formasPagamento: [],\n                        valorRecebidoTotal: 0,\n                        descontoReal: prev.valorBruto > 0 ? 100 : 0,\n                        valorRestante: prev.valorNegociado\n                    })\n            }[\"useSimulador.useCallback[limparFormas]\"]);\n        }\n    }[\"useSimulador.useCallback[limparFormas]\"], []);\n    const alternarTravamento = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[alternarTravamento]\": (tipo, valor)=>{\n            setSimulacao({\n                \"useSimulador.useCallback[alternarTravamento]\": (prev)=>({\n                        ...prev,\n                        travamentos: {\n                            ...prev.travamentos,\n                            [tipo]: !prev.travamentos[tipo],\n                            ...valor !== undefined && {\n                                limiteDescontoReal: valor\n                            }\n                        }\n                    })\n            }[\"useSimulador.useCallback[alternarTravamento]\"]);\n        }\n    }[\"useSimulador.useCallback[alternarTravamento]\"], []);\n    const alternarTravamentoForma = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[alternarTravamentoForma]\": (id)=>{\n            setSimulacao({\n                \"useSimulador.useCallback[alternarTravamentoForma]\": (prev)=>({\n                        ...prev,\n                        formasPagamento: prev.formasPagamento.map({\n                            \"useSimulador.useCallback[alternarTravamentoForma]\": (forma)=>forma.id === id ? {\n                                    ...forma,\n                                    travado: !forma.travado\n                                } : forma\n                        }[\"useSimulador.useCallback[alternarTravamentoForma]\"])\n                    })\n            }[\"useSimulador.useCallback[alternarTravamentoForma]\"]);\n        }\n    }[\"useSimulador.useCallback[alternarTravamentoForma]\"], []);\n    return {\n        simulacao,\n        recalcularSimulacao,\n        adicionarForma,\n        atualizarForma,\n        removerForma,\n        limparFormas,\n        alternarTravamento,\n        alternarTravamentoForma,\n        editarValorNegociado,\n        editarValorBruto,\n        editarDescontoReal\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VTaW11bGFkb3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQThDO0FBR3ZDLE1BQU1FLGVBQWU7SUFDMUIsTUFBTSxDQUFDQyxXQUFXQyxhQUFhLEdBQUdKLCtDQUFRQSxDQUFZO1FBQ3BESyxZQUFZO1FBQ1pDLFVBQVU7UUFDVkMsZ0JBQWdCO1FBQ2hCQyxpQkFBaUIsRUFBRTtRQUNuQkMsb0JBQW9CO1FBQ3BCQyxjQUFjO1FBQ2RDLGVBQWU7UUFDZkMsYUFBYTtZQUNYTCxnQkFBZ0I7WUFDaEJHLGNBQWM7WUFDZEcsb0JBQW9CO1FBQ3RCO0lBQ0Y7SUFFQSw0Q0FBNEM7SUFDNUMsTUFBTUMsb0JBQW9CO1FBQUM7UUFBVztRQUFVO1FBQWM7S0FBUztJQUV2RSxNQUFNQyw2QkFBNkJkLGtEQUFXQTtnRUFBQyxDQUFDZTtZQUM5Q0MsUUFBUUMsR0FBRyxDQUFDLG1DQUFtQ0Y7WUFFL0MsT0FBUUEsTUFBTUcsSUFBSTtnQkFDaEIsS0FBSztvQkFDSCxPQUFPSCxNQUFNSSxLQUFLO2dCQUVwQixLQUFLO29CQUFjO3dCQUNqQixJQUFJLENBQUNKLE1BQU1LLFFBQVEsSUFBSSxDQUFDTCxNQUFNTSxTQUFTLEVBQUUsT0FBT04sTUFBTUksS0FBSzt3QkFDM0QsTUFBTUcsSUFBSVAsTUFBTU0sU0FBUyxHQUFHO3dCQUM1QixNQUFNRCxXQUFXTCxNQUFNSyxRQUFRO3dCQUMvQixNQUFNRyxnQkFBZ0JSLE1BQU1JLEtBQUssR0FBR0ssS0FBS0MsR0FBRyxDQUFDLElBQUlILEdBQUdGO3dCQUNwREosUUFBUUMsR0FBRyxDQUFDLHFCQUE4Q0csT0FBekJMLE1BQU1JLEtBQUssRUFBQyxlQUErQkosT0FBbEJLLFVBQVMsV0FBaUNHLE9BQXhCUixNQUFNTSxTQUFTLEVBQUMsVUFBc0IsT0FBZEU7d0JBQ3BHLE9BQU9BO29CQUNUO2dCQUVBLEtBQUs7b0JBQVU7d0JBQ2IsSUFBSSxDQUFDUixNQUFNVyxRQUFRLElBQUks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UUFDQWdFO1FBQ0FZO1FBQ0FRO1FBQ0FHO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FwQjtRQUNBSztRQUNBRjtJQUNGO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxyaWNhclxcUHJvamV0b3NcXGZsdXl0LXByb3Bvc3RhLXNpbXVsYWRvclxcc3JjXFxob29rc1xcdXNlU2ltdWxhZG9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEZvcm1hUGFnYW1lbnRvLCBTaW11bGFjYW8sIFRyYXZhbWVudG9Db25maWcgfSBmcm9tICcuLi90eXBlcy9zaW11bGFkb3InO1xuXG5leHBvcnQgY29uc3QgdXNlU2ltdWxhZG9yID0gKCkgPT4ge1xuICBjb25zdCBbc2ltdWxhY2FvLCBzZXRTaW11bGFjYW9dID0gdXNlU3RhdGU8U2ltdWxhY2FvPih7XG4gICAgdmFsb3JCcnV0bzogMCxcbiAgICBkZXNjb250bzogMCxcbiAgICB2YWxvck5lZ29jaWFkbzogMCxcbiAgICBmb3JtYXNQYWdhbWVudG86IFtdLFxuICAgIHZhbG9yUmVjZWJpZG9Ub3RhbDogMCxcbiAgICBkZXNjb250b1JlYWw6IDAsXG4gICAgdmFsb3JSZXN0YW50ZTogMCxcbiAgICB0cmF2YW1lbnRvczoge1xuICAgICAgdmFsb3JOZWdvY2lhZG86IGZhbHNlLFxuICAgICAgZGVzY29udG9SZWFsOiBmYWxzZSxcbiAgICAgIGxpbWl0ZURlc2NvbnRvUmVhbDogMjVcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFByaW9yaWRhZGUgcGFyYSByZWRpc3RyaWJ1acOnw6NvIGRlIHZhbG9yZXNcbiAgY29uc3QgUFJJT1JJREFERV9GT1JNQVMgPSBbJ0VOVFJBREEnLCAnQk9MRVRPJywgJ0ZJTkFOQ0VJUkEnLCAnQ0FSVEFPJ107XG5cbiAgY29uc3QgY2FsY3VsYXJWYWxvclJlY2ViaWRvRm9ybWEgPSB1c2VDYWxsYmFjaygoZm9ybWE6IEZvcm1hUGFnYW1lbnRvKTogbnVtYmVyID0+IHtcbiAgICBjb25zb2xlLmxvZygnQ2FsY3VsYW5kbyB2YWxvciByZWNlYmlkbyBwYXJhOicsIGZvcm1hKTtcbiAgICBcbiAgICBzd2l0Y2ggKGZvcm1hLnRpcG8pIHtcbiAgICAgIGNhc2UgJ0VOVFJBREEnOlxuICAgICAgICByZXR1cm4gZm9ybWEudmFsb3I7XG4gICAgICBcbiAgICAgIGNhc2UgJ0ZJTkFOQ0VJUkEnOiB7XG4gICAgICAgIGlmICghZm9ybWEucGFyY2VsYXMgfHwgIWZvcm1hLnRheGFKdXJvcykgcmV0dXJuIGZvcm1hLnZhbG9yO1xuICAgICAgICBjb25zdCBpID0gZm9ybWEudGF4YUp1cm9zIC8gMTAwO1xuICAgICAgICBjb25zdCBwYXJjZWxhcyA9IGZvcm1hLnBhcmNlbGFzO1xuICAgICAgICBjb25zdCB2YWxvclByZXNlbnRlID0gZm9ybWEudmFsb3IgLyBNYXRoLnBvdygxICsgaSwgcGFyY2VsYXMpO1xuICAgICAgICBjb25zb2xlLmxvZyhgRmluYW5jZWlyYTogdmFsb3I9JHtmb3JtYS52YWxvcn0sIHBhcmNlbGFzPSR7cGFyY2VsYXN9LCB0YXhhPSR7Zm9ybWEudGF4YUp1cm9zfSUsIFZQPSR7dmFsb3JQcmVzZW50ZX1gKTtcbiAgICAgICAgcmV0dXJuIHZhbG9yUHJlc2VudGU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNhc2UgJ0NBUlRBTyc6IHtcbiAgICAgICAgaWYgKCFmb3JtYS5kZWZsYWNhbyB8fCAhZm9ybWEuanVyb3NBbnRlY2lwYWNhbyB8fCAhZm9ybWEucGFyY2VsYXMpIHJldHVybiBmb3JtYS52YWxvcjtcbiAgICAgICAgY29uc3QgZmF0b3JEZWZsYWNhbyA9IDEgLSAoZm9ybWEuZGVmbGFjYW8gLyAxMDApO1xuICAgICAgICBjb25zdCBmYXRvckp1cm9zID0gMSAtIChmb3JtYS5qdXJvc0FudGVjaXBhY2FvIC8gMTAwICogZm9ybWEucGFyY2VsYXMpO1xuICAgICAgICBjb25zdCB2YWxvclJlY2ViaWRvID0gZm9ybWEudmFsb3IgKiBmYXRvckRlZmxhY2FvICogZmF0b3JKdXJvcztcbiAgICAgICAgY29uc29sZS5sb2coYENhcnTDo286IHZhbG9yPSR7Zm9ybWEudmFsb3J9LCBkZWZsYcOnw6NvPSR7Zm9ybWEuZGVmbGFjYW99JSwganVyb3M9JHtmb3JtYS5qdXJvc0FudGVjaXBhY2FvfSUsIFZSPSR7dmFsb3JSZWNlYmlkb31gKTtcbiAgICAgICAgcmV0dXJuIHZhbG9yUmVjZWJpZG87XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNhc2UgJ0JPTEVUTyc6IHtcbiAgICAgICAgaWYgKCFmb3JtYS5wYXJjZWxhcyB8fCAhZm9ybWEuY3VzdG9DYXBpdGFsKSByZXR1cm4gZm9ybWEudmFsb3I7XG4gICAgICAgIGNvbnN0IGljID0gZm9ybWEuY3VzdG9DYXBpdGFsIC8gMTAwO1xuICAgICAgICBjb25zdCB2YWxvclByZXNlbnRlQm9sZXRvID0gZm9ybWEudmFsb3IgLyBNYXRoLnBvdygxICsgaWMsIGZvcm1hLnBhcmNlbGFzKTtcbiAgICAgICAgY29uc29sZS5sb2coYEJvbGV0bzogdmFsb3I9JHtmb3JtYS52YWxvcn0sIHBhcmNlbGFzPSR7Zm9ybWEucGFyY2VsYXN9LCBjdXN0bz0ke2Zvcm1hLmN1c3RvQ2FwaXRhbH0lLCBWUD0ke3ZhbG9yUHJlc2VudGVCb2xldG99YCk7XG4gICAgICAgIHJldHVybiB2YWxvclByZXNlbnRlQm9sZXRvO1xuICAgICAgfVxuICAgICAgXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZm9ybWEudmFsb3I7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgY29uc3QgcmVkaXN0cmlidWlyVmFsb3JlcyA9IHVzZUNhbGxiYWNrKChub3ZvVmFsb3JOZWdvY2lhZG86IG51bWJlciwgZm9ybWFzQXR1YWlzOiBGb3JtYVBhZ2FtZW50b1tdKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1JlZGlzdHJpYnVpbmRvIHZhbG9yZXMuIE5vdm8gdmFsb3IgbmVnb2NpYWRvOicsIG5vdm9WYWxvck5lZ29jaWFkbyk7XG4gICAgXG4gICAgY29uc3Qgc29tYUF0dWFsID0gZm9ybWFzQXR1YWlzLnJlZHVjZSgoYWNjLCBmb3JtYSkgPT4gYWNjICsgZm9ybWEudmFsb3IsIDApO1xuICAgIGNvbnN0IGRpZmVyZW5jYSA9IG5vdm9WYWxvck5lZ29jaWFkbyAtIHNvbWFBdHVhbDtcbiAgICBcbiAgICBpZiAoTWF0aC5hYnMoZGlmZXJlbmNhKSA8IDAuMDEpIHtcbiAgICAgIHJldHVybiBmb3JtYXNBdHVhaXM7IC8vIE7Do28gaMOhIGRpZmVyZW7Dp2Egc2lnbmlmaWNhdGl2YVxuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZygnRGlmZXJlbsOnYSBhIHJlZGlzdHJpYnVpcjonLCBkaWZlcmVuY2EpO1xuICAgIFxuICAgIC8vIFNlcGFyYXIgZm9ybWFzIHRyYXZhZGFzIGUgbsOjbyB0cmF2YWRhc1xuICAgIGNvbnN0IGZvcm1hc1RyYXZhZGFzID0gZm9ybWFzQXR1YWlzLmZpbHRlcihmb3JtYSA9PiBmb3JtYS50cmF2YWRvKTtcbiAgICBjb25zdCBmb3JtYXNOYW9UcmF2YWRhcyA9IGZvcm1hc0F0dWFpcy5maWx0ZXIoZm9ybWEgPT4gIWZvcm1hLnRyYXZhZG8pO1xuICAgIFxuICAgIC8vIFNlIHRvZGFzIGVzdMOjbyB0cmF2YWRhcywgbsOjbyBwb2RlbW9zIHJlZGlzdHJpYnVpclxuICAgIGlmIChmb3JtYXNOYW9UcmF2YWRhcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdUb2RhcyBhcyBmb3JtYXMgZXN0w6NvIHRyYXZhZGFzJyk7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gSW5kaWNhIGVycm9cbiAgICB9XG4gICAgXG4gICAgLy8gT3JkZW5hciBmb3JtYXMgbsOjbyB0cmF2YWRhcyBwb3IgcHJpb3JpZGFkZVxuICAgIGNvbnN0IGZvcm1hc09yZGVuYWRhcyA9IGZvcm1hc05hb1RyYXZhZGFzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IHByaW9yaWRhZGVBID0gUFJJT1JJREFERV9GT1JNQVMuaW5kZXhPZihhLnRpcG8pO1xuICAgICAgY29uc3QgcHJpb3JpZGFkZUIgPSBQUklPUklEQURFX0ZPUk1BUy5pbmRleE9mKGIudGlwbyk7XG4gICAgICByZXR1cm4gcHJpb3JpZGFkZUEgLSBwcmlvcmlkYWRlQjtcbiAgICB9KTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygnRm9ybWFzIG9yZGVuYWRhcyBwb3IgcHJpb3JpZGFkZTonLCBmb3JtYXNPcmRlbmFkYXMubWFwKGYgPT4gZi50aXBvKSk7XG4gICAgXG4gICAgLy8gUmVkaXN0cmlidWlyIGEgZGlmZXJlbsOnYTogYXBlbmFzIGEgcHJpbWVpcmEgZm9ybWEgbmEgb3JkZW0gZGUgcHJpb3JpZGFkZSBhYnNvcnZlIHRvZGEgYSBkaWZlcmVuw6dhXG4gICAgY29uc3Qgbm92YXNGb3JtYXMgPSBbLi4uZm9ybWFzQXR1YWlzXTtcbiAgICBcbiAgICAvLyBWZXJpZmljYXIgc2UgdG9kYXMgYXMgZm9ybWFzIG7Do28gdHJhdmFkYXMgdMOqbSB2YWxvciB6ZXJvXG4gICAgY29uc3Qgc29tYUZvcm1hc05hb1RyYXZhZGFzID0gZm9ybWFzT3JkZW5hZGFzLnJlZHVjZSgoYWNjLCBmb3JtYSkgPT4gYWNjICsgZm9ybWEudmFsb3IsIDApO1xuICAgIFxuICAgIGlmIChzb21hRm9ybWFzTmFvVHJhdmFkYXMgPT09IDApIHtcbiAgICAgIC8vIFNlIHRvZGFzIGFzIGZvcm1hcyBuw6NvIHRyYXZhZGFzIHTDqm0gdmFsb3IgMCwgZGlzdHJpYnVpIGlndWFsbWVudGVcbiAgICAgIGNvbnNvbGUubG9nKCdUb2RhcyBhcyBmb3JtYXMgbsOjbyB0cmF2YWRhcyB0w6ptIHZhbG9yIHplcm8sIGRpc3RyaWJ1aW5kbyBpZ3VhbG1lbnRlJyk7XG4gICAgICBjb25zdCBhanVzdGVQb3JGb3JtYSA9IGRpZmVyZW5jYSAvIGZvcm1hc09yZGVuYWRhcy5sZW5ndGg7XG4gICAgICBmb3JtYXNPcmRlbmFkYXMuZm9yRWFjaChmb3JtYSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hSW5kZXggPSBub3Zhc0Zvcm1hcy5maW5kSW5kZXgoZiA9PiBmLmlkID09PSBmb3JtYS5pZCk7XG4gICAgICAgIGNvbnN0IG5vdm9WYWxvciA9IE1hdGgubWF4KDAsIGFqdXN0ZVBvckZvcm1hKTtcbiAgICAgICAgbm92YXNGb3JtYXNbZm9ybWFJbmRleF0gPSB7IC4uLm5vdmFzRm9ybWFzW2Zvcm1hSW5kZXhdLCB2YWxvcjogbm92b1ZhbG9yIH07XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBlbmFzIGEgcHJpbWVpcmEgZm9ybWEgbsOjbyB0cmF2YWRhIG5hIG9yZGVtIGRlIHByaW9yaWRhZGUgYWJzb3J2ZSB0b2RhIGEgZGlmZXJlbsOnYVxuICAgICAgY29uc29sZS5sb2coJ0FqdXN0YW5kbyBhcGVuYXMgYSBwcmltZWlyYSBmb3JtYSBuYSBvcmRlbSBkZSBwcmlvcmlkYWRlJyk7XG4gICAgICBjb25zdCBwcmltZWlyYUZvcm1hID0gZm9ybWFzT3JkZW5hZGFzWzBdO1xuICAgICAgY29uc3QgZm9ybWFJbmRleCA9IG5vdmFzRm9ybWFzLmZpbmRJbmRleChmID0+IGYuaWQgPT09IHByaW1laXJhRm9ybWEuaWQpO1xuICAgICAgY29uc3Qgbm92b1ZhbG9yID0gTWF0aC5tYXgoMCwgcHJpbWVpcmFGb3JtYS52YWxvciArIGRpZmVyZW5jYSk7XG4gICAgICBub3Zhc0Zvcm1hc1tmb3JtYUluZGV4XSA9IHsgLi4ubm92YXNGb3JtYXNbZm9ybWFJbmRleF0sIHZhbG9yOiBub3ZvVmFsb3IgfTtcbiAgICAgIGNvbnNvbGUubG9nKGBGb3JtYSAke3ByaW1laXJhRm9ybWEudGlwb30gYWp1c3RhZGEgZGUgJHtwcmltZWlyYUZvcm1hLnZhbG9yfSBwYXJhICR7bm92b1ZhbG9yfWApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gbm92YXNGb3JtYXM7XG4gIH0sIFtdKTtcblxuICBjb25zdCByZWNhbGN1bGFyU2ltdWxhY2FvID0gdXNlQ2FsbGJhY2soKHVwZGF0ZXM6IFBhcnRpYWw8U2ltdWxhY2FvPikgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdSZWNhbGN1bGFuZG8gc2ltdWxhw6fDo28gY29tIHVwZGF0ZXM6JywgdXBkYXRlcyk7XG4gICAgXG4gICAgc2V0U2ltdWxhY2FvKHByZXYgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZCA9IHsgLi4ucHJldiwgLi4udXBkYXRlcyB9O1xuICAgICAgXG4gICAgICAvLyBMw7NnaWNhIGRlIHRyYXZhbWVudG8gZG8gdmFsb3IgbmVnb2NpYWRvXG4gICAgICBpZiAodXBkYXRlZC50cmF2YW1lbnRvcy52YWxvck5lZ29jaWFkbykge1xuICAgICAgICAvLyBTZSB2YWxvciBuZWdvY2lhZG8gZXN0w6EgdHJhdmFkbywgYWp1c3RhIG8gZGVzY29udG8gcXVhbmRvIHZhbG9yIGJydXRvIG11ZGFcbiAgICAgICAgaWYgKHVwZGF0ZXMudmFsb3JCcnV0byAhPT0gdW5kZWZpbmVkICYmIHVwZGF0ZXMudmFsb3JCcnV0byA+IDApIHtcbiAgICAgICAgICB1cGRhdGVkLmRlc2NvbnRvID0gKCh1cGRhdGVkLnZhbG9yQnJ1dG8gLSB1cGRhdGVkLnZhbG9yTmVnb2NpYWRvKSAvIHVwZGF0ZWQudmFsb3JCcnV0bykgKiAxMDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvbXBvcnRhbWVudG8gbm9ybWFsOiBjYWxjdWxhIHZhbG9yIG5lZ29jaWFkbyBiYXNlYWRvIG5vIGRlc2NvbnRvXG4gICAgICAgIHVwZGF0ZWQudmFsb3JOZWdvY2lhZG8gPSB1cGRhdGVkLnZhbG9yQnJ1dG8gKiAoMSAtIHVwZGF0ZWQuZGVzY29udG8gLyAxMDApO1xuICAgICAgfVxuICAgICAgXG4gICAgICB1cGRhdGVkLmZvcm1hc1BhZ2FtZW50byA9IHVwZGF0ZWQuZm9ybWFzUGFnYW1lbnRvLm1hcChmb3JtYSA9PiAoe1xuICAgICAgICAuLi5mb3JtYSxcbiAgICAgICAgdmFsb3JSZWNlYmlkbzogY2FsY3VsYXJWYWxvclJlY2ViaWRvRm9ybWEoZm9ybWEpXG4gICAgICB9KSk7XG4gICAgICBcbiAgICAgIHVwZGF0ZWQudmFsb3JSZWNlYmlkb1RvdGFsID0gdXBkYXRlZC5mb3JtYXNQYWdhbWVudG8ucmVkdWNlKChhY2MsIGZvcm1hKSA9PiBhY2MgKyBmb3JtYS52YWxvclJlY2ViaWRvLCAwKTtcbiAgICAgIHVwZGF0ZWQuZGVzY29udG9SZWFsID0gdXBkYXRlZC52YWxvckJydXRvID4gMCA/ICgodXBkYXRlZC52YWxvckJydXRvIC0gdXBkYXRlZC52YWxvclJlY2ViaWRvVG90YWwpIC8gdXBkYXRlZC52YWxvckJydXRvKSAqIDEwMCA6IDA7XG4gICAgICBcbiAgICAgIGNvbnN0IHNvbWFGb3JtYXMgPSB1cGRhdGVkLmZvcm1hc1BhZ2FtZW50by5yZWR1Y2UoKGFjYywgZm9ybWEpID0+IGFjYyArIGZvcm1hLnZhbG9yLCAwKTtcbiAgICAgIHVwZGF0ZWQudmFsb3JSZXN0YW50ZSA9IHVwZGF0ZWQudmFsb3JOZWdvY2lhZG8gLSBzb21hRm9ybWFzO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnU2ltdWxhw6fDo28gYXR1YWxpemFkYTonLCB1cGRhdGVkKTtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0pO1xuICB9LCBbY2FsY3VsYXJWYWxvclJlY2ViaWRvRm9ybWFdKTtcblxuICBjb25zdCBlZGl0YXJWYWxvck5lZ29jaWFkbyA9IHVzZUNhbGxiYWNrKChub3ZvVmFsb3I6IG51bWJlcikgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdFZGl0YW5kbyB2YWxvciBuZWdvY2lhZG8gcGFyYTonLCBub3ZvVmFsb3IpO1xuICAgIFxuICAgIHNldFNpbXVsYWNhbyhwcmV2ID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hc1JlZGlzdHJpYnVpZGFzID0gcmVkaXN0cmlidWlyVmFsb3Jlcyhub3ZvVmFsb3IsIHByZXYuZm9ybWFzUGFnYW1lbnRvKTtcbiAgICAgIFxuICAgICAgaWYgKCFmb3JtYXNSZWRpc3RyaWJ1aWRhcykge1xuICAgICAgICBhbGVydCgnTsOjbyDDqSBwb3Nzw612ZWwgYWx0ZXJhciBvIHZhbG9yLiBUb2RhcyBhcyBmb3JtYXMgZGUgcGFnYW1lbnRvIGVzdMOjbyB0cmF2YWRhcy4nKTtcbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHVwZGF0ZWQgPSB7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIHZhbG9yTmVnb2NpYWRvOiBub3ZvVmFsb3IsXG4gICAgICAgIGZvcm1hc1BhZ2FtZW50bzogZm9ybWFzUmVkaXN0cmlidWlkYXMubWFwKGZvcm1hID0+ICh7XG4gICAgICAgICAgLi4uZm9ybWEsXG4gICAgICAgICAgdmFsb3JSZWNlYmlkbzogY2FsY3VsYXJWYWxvclJlY2ViaWRvRm9ybWEoZm9ybWEpXG4gICAgICAgIH0pKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gUmVjYWxjdWxhciBkZXNjb250b1xuICAgICAgdXBkYXRlZC5kZXNjb250byA9IHVwZGF0ZWQudmFsb3JCcnV0byA+IDAgPyAoKHVwZGF0ZWQudmFsb3JCcnV0byAtIHVwZGF0ZWQudmFsb3JOZWdvY2lhZG8pIC8gdXBkYXRlZC52YWxvckJydXRvKSAqIDEwMCA6IDA7XG4gICAgICBcbiAgICAgIHVwZGF0ZWQudmFsb3JSZWNlYmlkb1RvdGFsID0gdXBkYXRlZC5mb3JtYXNQYWdhbWVudG8ucmVkdWNlKChhY2MsIGZvcm1hKSA9PiBhY2MgKyBmb3JtYS52YWxvclJlY2ViaWRvLCAwKTtcbiAgICAgIHVwZGF0ZWQuZGVzY29udG9SZWFsID0gdXBkYXRlZC52YWxvckJydXRvID4gMCA/ICgodXBkYXRlZC52YWxvckJydXRvIC0gdXBkYXRlZC52YWxvclJlY2ViaWRvVG90YWwpIC8gdXBkYXRlZC52YWxvckJydXRvKSAqIDEwMCA6IDA7XG4gICAgICBcbiAgICAgIGNvbnN0IHNvbWFGb3JtYXMgPSB1cGRhdGVkLmZvcm1hc1BhZ2FtZW50by5yZWR1Y2UoKGFjYywgZm9ybWEpID0+IGFjYyArIGZvcm1hLnZhbG9yLCAwKTtcbiAgICAgIHVwZGF0ZWQudmFsb3JSZXN0YW50ZSA9IHVwZGF0ZWQudmFsb3JOZWdvY2lhZG8gLSBzb21hRm9ybWFzO1xuICAgICAgXG4gICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9KTtcbiAgfSwgW3JlZGlzdHJpYnVpclZhbG9yZXMsIGNhbGN1bGFyVmFsb3JSZWNlYmlkb0Zvcm1hXSk7XG5cbiAgY29uc3QgZWRpdGFyRGVzY29udG9SZWFsID0gdXNlQ2FsbGJhY2soKG5vdm9EZXNjb250bzogbnVtYmVyKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0VkaXRhbmRvIGRlc2NvbnRvIHJlYWwgcGFyYTonLCBub3ZvRGVzY29udG8pO1xuICAgIFxuICAgIHNldFNpbXVsYWNhbyhwcmV2ID0+IHtcbiAgICAgIC8vIENhbGN1bGFyIG5vdm8gdmFsb3IgbmVnb2NpYWRvIGJhc2VhZG8gbm8gZGVzY29udG9cbiAgICAgIGNvbnN0IG5vdm9WYWxvck5lZ29jaWFkbyA9IHByZXYudmFsb3JCcnV0byAqICgxIC0gbm92b0Rlc2NvbnRvIC8gMTAwKTtcbiAgICAgIFxuICAgICAgY29uc3QgZm9ybWFzUmVkaXN0cmlidWlkYXMgPSByZWRpc3RyaWJ1aXJWYWxvcmVzKG5vdm9WYWxvck5lZ29jaWFkbywgcHJldi5mb3JtYXNQYWdhbWVudG8pO1xuICAgICAgXG4gICAgICBpZiAoIWZvcm1hc1JlZGlzdHJpYnVpZGFzKSB7XG4gICAgICAgIGFsZXJ0KCdOw6NvIMOpIHBvc3PDrXZlbCBhbHRlcmFyIG8gZGVzY29udG8uIFRvZGFzIGFzIGZvcm1hcyBkZSBwYWdhbWVudG8gZXN0w6NvIHRyYXZhZGFzLicpO1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgdXBkYXRlZCA9IHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgZGVzY29udG86IG5vdm9EZXNjb250byxcbiAgICAgICAgdmFsb3JOZWdvY2lhZG86IG5vdm9WYWxvck5lZ29jaWFkbyxcbiAgICAgICAgZm9ybWFzUGFnYW1lbnRvOiBmb3JtYXNSZWRpc3RyaWJ1aWRhcy5tYXAoZm9ybWEgPT4gKHtcbiAgICAgICAgICAuLi5mb3JtYSxcbiAgICAgICAgICB2YWxvclJlY2ViaWRvOiBjYWxjdWxhclZhbG9yUmVjZWJpZG9Gb3JtYShmb3JtYSlcbiAgICAgICAgfSkpXG4gICAgICB9O1xuICAgICAgXG4gICAgICB1cGRhdGVkLnZhbG9yUmVjZWJpZG9Ub3RhbCA9IHVwZGF0ZWQuZm9ybWFzUGFnYW1lbnRvLnJlZHVjZSgoYWNjLCBmb3JtYSkgPT4gYWNjICsgZm9ybWEudmFsb3JSZWNlYmlkbywgMCk7XG4gICAgICB1cGRhdGVkLmRlc2NvbnRvUmVhbCA9IHVwZGF0ZWQudmFsb3JCcnV0byA+IDAgPyAoKHVwZGF0ZWQudmFsb3JCcnV0byAtIHVwZGF0ZWQudmFsb3JSZWNlYmlkb1RvdGFsKSAvIHVwZGF0ZWQudmFsb3JCcnV0bykgKiAxMDAgOiAwO1xuICAgICAgXG4gICAgICBjb25zdCBzb21hRm9ybWFzID0gdXBkYXRlZC5mb3JtYXNQYWdhbWVudG8ucmVkdWNlKChhY2MsIGZvcm1hKSA9PiBhY2MgKyBmb3JtYS52YWxvciwgMCk7XG4gICAgICB1cGRhdGVkLnZhbG9yUmVzdGFudGUgPSB1cGRhdGVkLnZhbG9yTmVnb2NpYWRvIC0gc29tYUZvcm1hcztcbiAgICAgIFxuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfSk7XG4gIH0sIFtyZWRpc3RyaWJ1aXJWYWxvcmVzLCBjYWxjdWxhclZhbG9yUmVjZWJpZG9Gb3JtYV0pO1xuXG4gIGNvbnN0IGVkaXRhclZhbG9yQnJ1dG8gPSB1c2VDYWxsYmFjaygobm92b1ZhbG9yOiBudW1iZXIpID0+IHtcbiAgICBjb25zb2xlLmxvZygnRWRpdGFuZG8gdmFsb3IgYnJ1dG8gcGFyYTonLCBub3ZvVmFsb3IpO1xuICAgIHJlY2FsY3VsYXJTaW11bGFjYW8oeyB2YWxvckJydXRvOiBub3ZvVmFsb3IgfSk7XG4gIH0sIFtyZWNhbGN1bGFyU2ltdWxhY2FvXSk7XG5cbiAgY29uc3QgYWRpY2lvbmFyRm9ybWEgPSB1c2VDYWxsYmFjaygoZm9ybWE6IE9taXQ8Rm9ybWFQYWdhbWVudG8sICdpZCcgfCAndmFsb3JSZWNlYmlkbyc+KSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0FkaWNpb25hbmRvIGZvcm1hOicsIGZvcm1hKTtcbiAgICBcbiAgICBzZXRTaW11bGFjYW8ocHJldiA9PiB7XG4gICAgICAvLyBWZXJpZmljYXIgdHJhdmFtZW50byBkZSBkZXNjb250byByZWFsXG4gICAgICBpZiAocHJldi50cmF2YW1lbnRvcy5kZXNjb250b1JlYWwpIHtcbiAgICAgICAgY29uc3Qgbm92YUZvcm1hVGVtcDogRm9ybWFQYWdhbWVudG8gPSB7XG4gICAgICAgICAgLi4uZm9ybWEsXG4gICAgICAgICAgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSxcbiAgICAgICAgICB2YWxvclJlY2ViaWRvOiAwXG4gICAgICAgIH07XG4gICAgICAgIG5vdmFGb3JtYVRlbXAudmFsb3JSZWNlYmlkbyA9IGNhbGN1bGFyVmFsb3JSZWNlYmlkb0Zvcm1hKG5vdmFGb3JtYVRlbXApO1xuICAgICAgICBcbiAgICAgICAgY29uc3Qgbm92b1ZhbG9yUmVjZWJpZG9Ub3RhbCA9IHByZXYudmFsb3JSZWNlYmlkb1RvdGFsICsgbm92YUZvcm1hVGVtcC52YWxvclJlY2ViaWRvO1xuICAgICAgICBjb25zdCBub3ZvRGVzY29udG9SZWFsID0gcHJldi52YWxvckJydXRvID4gMCA/ICgocHJldi52YWxvckJydXRvIC0gbm92b1ZhbG9yUmVjZWJpZG9Ub3RhbCkgLyBwcmV2LnZhbG9yQnJ1dG8pICogMTAwIDogMDtcbiAgICAgICAgXG4gICAgICAgIGlmIChub3ZvRGVzY29udG9SZWFsID4gcHJldi50cmF2YW1lbnRvcy5saW1pdGVEZXNjb250b1JlYWwpIHtcbiAgICAgICAgICBhbGVydChgTsOjbyDDqSBwb3Nzw612ZWwgYWRpY2lvbmFyIGVzdGEgZm9ybWEuIE8gZGVzY29udG8gcmVhbCBleGNlZGVyaWEgbyBsaW1pdGUgZGUgJHtwcmV2LnRyYXZhbWVudG9zLmxpbWl0ZURlc2NvbnRvUmVhbH0lYCk7XG4gICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3Qgbm92YUZvcm1hOiBGb3JtYVBhZ2FtZW50byA9IHtcbiAgICAgICAgLi4uZm9ybWEsXG4gICAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXG4gICAgICAgIHZhbG9yUmVjZWJpZG86IDAsXG4gICAgICAgIHRyYXZhZG86IGZhbHNlXG4gICAgICB9O1xuICAgICAgXG4gICAgICBub3ZhRm9ybWEudmFsb3JSZWNlYmlkbyA9IGNhbGN1bGFyVmFsb3JSZWNlYmlkb0Zvcm1hKG5vdmFGb3JtYSk7XG4gICAgICBcbiAgICAgIGNvbnN0IG5vdmFzRm9ybWFzID0gWy4uLnByZXYuZm9ybWFzUGFnYW1lbnRvLCBub3ZhRm9ybWFdO1xuICAgICAgY29uc3QgdXBkYXRlZCA9IHsgLi4ucHJldiwgZm9ybWFzUGFnYW1lbnRvOiBub3Zhc0Zvcm1hcyB9O1xuICAgICAgXG4gICAgICB1cGRhdGVkLnZhbG9yUmVjZWJpZG9Ub3RhbCA9IG5vdmFzRm9ybWFzLnJlZHVjZSgoYWNjLCBmKSA9PiBhY2MgKyBmLnZhbG9yUmVjZWJpZG8sIDApO1xuICAgICAgdXBkYXRlZC5kZXNjb250b1JlYWwgPSB1cGRhdGVkLnZhbG9yQnJ1dG8gPiAwID8gKCh1cGRhdGVkLnZhbG9yQnJ1dG8gLSB1cGRhdGVkLnZhbG9yUmVjZWJpZG9Ub3RhbCkgLyB1cGRhdGVkLnZhbG9yQnJ1dG8pICogMTAwIDogMDtcbiAgICAgIFxuICAgICAgY29uc3Qgc29tYUZvcm1hcyA9IG5vdmFzRm9ybWFzLnJlZHVjZSgoYWNjLCBmKSA9PiBhY2MgKyBmLnZhbG9yLCAwKTtcbiAgICAgIHVwZGF0ZWQudmFsb3JSZXN0YW50ZSA9IHVwZGF0ZWQudmFsb3JOZWdvY2lhZG8gLSBzb21hRm9ybWFzO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnTm92YSBzaW11bGHDp8OjbyBjb20gZm9ybWEgYWRpY2lvbmFkYTonLCB1cGRhdGVkKTtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0pO1xuICB9LCBbY2FsY3VsYXJWYWxvclJlY2ViaWRvRm9ybWFdKTtcblxuICBjb25zdCBhdHVhbGl6YXJGb3JtYSA9IHVzZUNhbGxiYWNrKChpZDogc3RyaW5nLCBkYWRvc0F0dWFsaXphZG9zOiBPbWl0PEZvcm1hUGFnYW1lbnRvLCAnaWQnIHwgJ3ZhbG9yUmVjZWJpZG8nPikgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdBdHVhbGl6YW5kbyBmb3JtYTonLCBpZCwgZGFkb3NBdHVhbGl6YWRvcyk7XG4gICAgXG4gICAgc2V0U2ltdWxhY2FvKHByZXYgPT4ge1xuICAgICAgY29uc3Qgbm92YXNGb3JtYXMgPSBwcmV2LmZvcm1hc1BhZ2FtZW50by5tYXAoZm9ybWEgPT4ge1xuICAgICAgICBpZiAoZm9ybWEuaWQgPT09IGlkKSB7XG4gICAgICAgICAgLy8gU2UgYSBmb3JtYSBlc3TDoSB0cmF2YWRhLCBuw6NvIHBlcm1pdGUgYWx0ZXJhciBvIHZhbG9yXG4gICAgICAgICAgaWYgKGZvcm1hLnRyYXZhZG8gJiYgZGFkb3NBdHVhbGl6YWRvcy52YWxvciAhPT0gZm9ybWEudmFsb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3JtYSB0cmF2YWRhLCBuw6NvIMOpIHBvc3PDrXZlbCBhbHRlcmFyIG8gdmFsb3InKTtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgZm9ybWFBdHVhbGl6YWRhID0geyAuLi5mb3JtYSwgLi4uZGFkb3NBdHVhbGl6YWRvcyB9O1xuICAgICAgICAgIGZvcm1hQXR1YWxpemFkYS52YWxvclJlY2ViaWRvID0gY2FsY3VsYXJWYWxvclJlY2ViaWRvRm9ybWEoZm9ybWFBdHVhbGl6YWRhKTtcbiAgICAgICAgICByZXR1cm4gZm9ybWFBdHVhbGl6YWRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB1cGRhdGVkID0geyAuLi5wcmV2LCBmb3JtYXNQYWdhbWVudG86IG5vdmFzRm9ybWFzIH07XG4gICAgICBcbiAgICAgIHVwZGF0ZWQudmFsb3JSZWNlYmlkb1RvdGFsID0gbm92YXNGb3JtYXMucmVkdWNlKChhY2MsIGYpID0+IGFjYyArIGYudmFsb3JSZWNlYmlkbywgMCk7XG4gICAgICB1cGRhdGVkLmRlc2NvbnRvUmVhbCA9IHVwZGF0ZWQudmFsb3JCcnV0byA+IDAgPyAoKHVwZGF0ZWQudmFsb3JCcnV0byAtIHVwZGF0ZWQudmFsb3JSZWNlYmlkb1RvdGFsKSAvIHVwZGF0ZWQudmFsb3JCcnV0bykgKiAxMDAgOiAwO1xuICAgICAgXG4gICAgICBjb25zdCBzb21hRm9ybWFzID0gbm92YXNGb3JtYXMucmVkdWNlKChhY2MsIGYpID0+IGFjYyArIGYudmFsb3IsIDApO1xuICAgICAgdXBkYXRlZC52YWxvclJlc3RhbnRlID0gdXBkYXRlZC52YWxvck5lZ29jaWFkbyAtIHNvbWFGb3JtYXM7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdTaW11bGHDp8OjbyBhdHVhbGl6YWRhIGFww7NzIGVkacOnw6NvOicsIHVwZGF0ZWQpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfSk7XG4gIH0sIFtjYWxjdWxhclZhbG9yUmVjZWJpZG9Gb3JtYV0pO1xuXG4gIGNvbnN0IHJlbW92ZXJGb3JtYSA9IHVzZUNhbGxiYWNrKChpZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1JlbW92ZW5kbyBmb3JtYTonLCBpZCk7XG4gICAgXG4gICAgc2V0U2ltdWxhY2FvKHByZXYgPT4ge1xuICAgICAgY29uc3Qgbm92YXNGb3JtYXMgPSBwcmV2LmZvcm1hc1BhZ2FtZW50by5maWx0ZXIoZiA9PiBmLmlkICE9PSBpZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBmb3JtYXNQYWdhbWVudG86IG5vdmFzRm9ybWFzLFxuICAgICAgICB2YWxvclJlY2ViaWRvVG90YWw6IG5vdmFzRm9ybWFzLnJlZHVjZSgoYWNjLCBmKSA9PiBhY2MgKyBmLnZhbG9yUmVjZWJpZG8sIDApLFxuICAgICAgICBkZXNjb250b1JlYWw6IHByZXYudmFsb3JCcnV0byA+IDAgPyAoKHByZXYudmFsb3JCcnV0byAtIG5vdmFzRm9ybWFzLnJlZHVjZSgoYWNjLCBmKSA9PiBhY2MgKyBmLnZhbG9yUmVjZWJpZG8sIDApKSAvIHByZXYudmFsb3JCcnV0bykgKiAxMDAgOiAwLFxuICAgICAgICB2YWxvclJlc3RhbnRlOiBwcmV2LnZhbG9yTmVnb2NpYWRvIC0gbm92YXNGb3JtYXMucmVkdWNlKChhY2MsIGYpID0+IGFjYyArIGYudmFsb3IsIDApXG4gICAgICB9O1xuICAgIH0pO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgbGltcGFyRm9ybWFzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdMaW1wYW5kbyB0b2RhcyBhcyBmb3JtYXMnKTtcbiAgICBzZXRTaW11bGFjYW8ocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIGZvcm1hc1BhZ2FtZW50bzogW10sXG4gICAgICB2YWxvclJlY2ViaWRvVG90YWw6IDAsXG4gICAgICBkZXNjb250b1JlYWw6IHByZXYudmFsb3JCcnV0byA+IDAgPyAxMDAgOiAwLFxuICAgICAgdmFsb3JSZXN0YW50ZTogcHJldi52YWxvck5lZ29jaWFkb1xuICAgIH0pKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGFsdGVybmFyVHJhdmFtZW50byA9IHVzZUNhbGxiYWNrKCh0aXBvOiBrZXlvZiBUcmF2YW1lbnRvQ29uZmlnLCB2YWxvcj86IG51bWJlcikgPT4ge1xuICAgIHNldFNpbXVsYWNhbyhwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgdHJhdmFtZW50b3M6IHtcbiAgICAgICAgLi4ucHJldi50cmF2YW1lbnRvcyxcbiAgICAgICAgW3RpcG9dOiAhcHJldi50cmF2YW1lbnRvc1t0aXBvXSxcbiAgICAgICAgLi4uKHZhbG9yICE9PSB1bmRlZmluZWQgJiYgeyBsaW1pdGVEZXNjb250b1JlYWw6IHZhbG9yIH0pXG4gICAgICB9XG4gICAgfSkpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgYWx0ZXJuYXJUcmF2YW1lbnRvRm9ybWEgPSB1c2VDYWxsYmFjaygoaWQ6IHN0cmluZykgPT4ge1xuICAgIHNldFNpbXVsYWNhbyhwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgZm9ybWFzUGFnYW1lbnRvOiBwcmV2LmZvcm1hc1BhZ2FtZW50by5tYXAoZm9ybWEgPT4gXG4gICAgICAgIGZvcm1hLmlkID09PSBpZCA/IHsgLi4uZm9ybWEsIHRyYXZhZG86ICFmb3JtYS50cmF2YWRvIH0gOiBmb3JtYVxuICAgICAgKVxuICAgIH0pKTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiB7XG4gICAgc2ltdWxhY2FvLFxuICAgIHJlY2FsY3VsYXJTaW11bGFjYW8sXG4gICAgYWRpY2lvbmFyRm9ybWEsXG4gICAgYXR1YWxpemFyRm9ybWEsXG4gICAgcmVtb3ZlckZvcm1hLFxuICAgIGxpbXBhckZvcm1hcyxcbiAgICBhbHRlcm5hclRyYXZhbWVudG8sXG4gICAgYWx0ZXJuYXJUcmF2YW1lbnRvRm9ybWEsXG4gICAgZWRpdGFyVmFsb3JOZWdvY2lhZG8sXG4gICAgZWRpdGFyVmFsb3JCcnV0byxcbiAgICBlZGl0YXJEZXNjb250b1JlYWxcbiAgfTtcbn07XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZVNpbXVsYWRvciIsInNpbXVsYWNhbyIsInNldFNpbXVsYWNhbyIsInZhbG9yQnJ1dG8iLCJkZXNjb250byIsInZhbG9yTmVnb2NpYWRvIiwiZm9ybWFzUGFnYW1lbnRvIiwidmFsb3JSZWNlYmlkb1RvdGFsIiwiZGVzY29udG9SZWFsIiwidmFsb3JSZXN0YW50ZSIsInRyYXZhbWVudG9zIiwibGltaXRlRGVzY29udG9SZWFsIiwiUFJJT1JJREFERV9GT1JNQVMiLCJjYWxjdWxhclZhbG9yUmVjZWJpZG9Gb3JtYSIsImZvcm1hIiwiY29uc29sZSIsImxvZyIsInRpcG8iLCJ2YWxvciIsInBhcmNlbGFzIiwidGF4YUp1cm9zIiwiaSIsInZhbG9yUHJlc2VudGUiLCJNYXRoIiwicG93IiwiZGVmbGFjYW8iLCJqdXJvc0FudGVjaXBhY2FvIiwiZmF0b3JEZWZsYWNhbyIsImZhdG9ySnVyb3MiLCJ2YWxvclJlY2ViaWRvIiwiY3VzdG9DYXBpdGFsIiwiaWMiLCJ2YWxvclByZXNlbnRlQm9sZXRvIiwicmVkaXN0cmlidWlyVmFsb3JlcyIsIm5vdm9WYWxvck5lZ29jaWFkbyIsImZvcm1hc0F0dWFpcyIsInNvbWFBdHVhbCIsInJlZHVjZSIsImFjYyIsImRpZmVyZW5jYSIsImFicyIsImZvcm1hc1RyYXZhZGFzIiwiZmlsdGVyIiwidHJhdmFkbyIsImZvcm1hc05hb1RyYXZhZGFzIiwibGVuZ3RoIiwiZm9ybWFzT3JkZW5hZGFzIiwic29ydCIsImEiLCJiIiwicHJpb3JpZGFkZUEiLCJpbmRleE9mIiwicHJpb3JpZGFkZUIiLCJtYXAiLCJmIiwibm92YXNGb3JtYXMiLCJzb21hRm9ybWFzTmFvVHJhdmFkYXMiLCJhanVzdGVQb3JGb3JtYSIsImZvckVhY2giLCJmb3JtYUluZGV4IiwiZmluZEluZGV4IiwiaWQiLCJub3ZvVmFsb3IiLCJtYXgiLCJwcmltZWlyYUZvcm1hIiwicmVjYWxjdWxhclNpbXVsYWNhbyIsInVwZGF0ZXMiLCJwcmV2IiwidXBkYXRlZCIsInVuZGVmaW5lZCIsInNvbWFGb3JtYXMiLCJlZGl0YXJWYWxvck5lZ29jaWFkbyIsImZvcm1hc1JlZGlzdHJpYnVpZGFzIiwiYWxlcnQiLCJlZGl0YXJEZXNjb250b1JlYWwiLCJub3ZvRGVzY29udG8iLCJlZGl0YXJWYWxvckJydXRvIiwiYWRpY2lvbmFyRm9ybWEiLCJub3ZhRm9ybWFUZW1wIiwiRGF0ZSIsIm5vdyIsInRvU3RyaW5nIiwibm92b1ZhbG9yUmVjZWJpZG9Ub3RhbCIsIm5vdm9EZXNjb250b1JlYWwiLCJub3ZhRm9ybWEiLCJhdHVhbGl6YXJGb3JtYSIsImRhZG9zQXR1YWxpemFkb3MiLCJmb3JtYUF0dWFsaXphZGEiLCJyZW1vdmVyRm9ybWEiLCJsaW1wYXJGb3JtYXMiLCJhbHRlcm5hclRyYXZhbWVudG8iLCJhbHRlcm5hclRyYXZhbWVudG9Gb3JtYSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useSimulador.ts\n"));

/***/ })

});