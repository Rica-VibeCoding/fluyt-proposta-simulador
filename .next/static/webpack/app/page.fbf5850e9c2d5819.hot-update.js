"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useSimulador.ts":
/*!***********************************!*\
  !*** ./src/hooks/useSimulador.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSimulador: () => (/* binding */ useSimulador)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst useSimulador = ()=>{\n    const [simulacao, setSimulacao] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        valorBruto: 0,\n        desconto: 0,\n        valorNegociado: 0,\n        formasPagamento: [],\n        valorRecebidoTotal: 0,\n        descontoReal: 0,\n        valorRestante: 0,\n        travamentos: {\n            valorNegociado: false,\n            descontoReal: false,\n            limiteDescontoReal: 25\n        }\n    });\n    // Prioridade para redistribuição de valores\n    const PRIORIDADE_FORMAS = [\n        'ENTRADA',\n        'BOLETO',\n        'FINANCEIRA',\n        'CARTAO'\n    ];\n    const calcularValorRecebidoForma = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[calcularValorRecebidoForma]\": (forma)=>{\n            console.log('Calculando valor recebido para:', forma);\n            switch(forma.tipo){\n                case 'ENTRADA':\n                    return forma.valor;\n                case 'FINANCEIRA':\n                    if (!forma.parcelas || !forma.taxaJuros) return forma.valor;\n                    const i = forma.taxaJuros / 100;\n                    const parcelas = forma.parcelas;\n                    const valorPresente = forma.valor / Math.pow(1 + i, parcelas);\n                    console.log(\"Financeira: valor=\".concat(forma.valor, \", parcelas=\").concat(parcelas, \", taxa=\").concat(forma.taxaJuros, \"%, VP=\").concat(valorPresente));\n                    return valorPresente;\n                case 'CARTAO':\n                    if (!forma.deflacao || !forma.jurosAntecipacao || !forma.parcelas) return forma.valor;\n                    const fatorDeflacao = 1 - forma.deflacao / 100;\n                    const fatorJuros = 1 - forma.jurosAntecipacao / 100 * forma.parcelas;\n                    const valorRecebido = forma.valor * fatorDeflacao * fatorJuros;\n                    console.log(\"Cart\\xe3o: valor=\".concat(forma.valor, \", defla\\xe7\\xe3o=\").concat(forma.deflacao, \"%, juros=\").concat(forma.jurosAntecipacao, \"%, VR=\").concat(valorRecebido));\n                    return valorRecebido;\n                case 'BOLETO':\n                    if (!forma.parcelas || !forma.custoCapital) return forma.valor;\n                    const ic = forma.custoCapital / 100;\n                    const valorPresenteBoleto = forma.valor / Math.pow(1 + ic, forma.parcelas);\n                    console.log(\"Boleto: valor=\".concat(forma.valor, \", parcelas=\").concat(forma.parcelas, \", custo=\").concat(forma.custoCapital, \"%, VP=\").concat(valorPresenteBoleto));\n                    return valorPresenteBoleto;\n                default:\n                    return forma.valor;\n            }\n        }\n    }[\"useSimulador.useCallback[calcularValorRecebidoForma]\"], []);\n    const redistribuirValores = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[redistribuirValores]\": (novoValorNegociado, formasAtuais)=>{\n            console.log('Redistribuindo valores. Novo valor negociado:', novoValorNegociado);\n            const somaAtual = formasAtuais.reduce({\n                \"useSimulador.useCallback[redistribuirValores].somaAtual\": (acc, forma)=>acc + forma.valor\n            }[\"useSimulador.useCallback[redistribuirValores].somaAtual\"], 0);\n            const diferenca = novoValorNegociado - somaAtual;\n            if (Math.abs(diferenca) < 0.01) {\n                return formasAtuais; // Não há diferença significativa\n            }\n            console.log('Diferença a redistribuir:', diferenca);\n            // Separar formas travadas e não travadas\n            const formasTravadas = formasAtuais.filter({\n                \"useSimulador.useCallback[redistribuirValores].formasTravadas\": (forma)=>forma.travado\n            }[\"useSimulador.useCallback[redistribuirValores].formasTravadas\"]);\n            const formasNaoTravadas = formasAtuais.filter({\n                \"useSimulador.useCallback[redistribuirValores].formasNaoTravadas\": (forma)=>!forma.travado\n            }[\"useSimulador.useCallback[redistribuirValores].formasNaoTravadas\"]);\n            // Se todas estão travadas, não podemos redistribuir\n            if (formasNaoTravadas.length === 0) {\n                console.log('Todas as formas estão travadas');\n                return null; // Indica erro\n            }\n            // Ordenar formas não travadas por prioridade\n            const formasOrdenadas = formasNaoTravadas.sort({\n                \"useSimulador.useCallback[redistribuirValores].formasOrdenadas\": (a, b)=>{\n                    const prioridadeA = PRIORIDADE_FORMAS.indexOf(a.tipo);\n                    const prioridadeB = PRIORIDADE_FORMAS.indexOf(b.tipo);\n                    return prioridadeA - prioridadeB;\n                }\n            }[\"useSimulador.useCallback[redistribuirValores].formasOrdenadas\"]);\n            console.log('Formas ordenadas por prioridade:', formasOrdenadas.map({\n                \"useSimulador.useCallback[redistribuirValores]\": (f)=>f.tipo\n            }[\"useSimulador.useCallback[redistribuirValores]\"]));\n            // Redistribuir a diferença: apenas a primeira forma na ordem de prioridade absorve toda a diferença\n            const novasFormas = [\n                ...formasAtuais\n            ];\n            // Verificar se todas as formas não travadas têm valor zero\n            const somaFormasNaoTravadas = formasOrdenadas.reduce({\n                \"useSimulador.useCallback[redistribuirValores].somaFormasNaoTravadas\": (acc, forma)=>acc + forma.valor\n            }[\"useSimulador.useCallback[redistribuirValores].somaFormasNaoTravadas\"], 0);\n            if (somaFormasNaoTravadas === 0) {\n                // Se todas as formas não travadas têm valor 0, distribui igualmente\n                console.log('Todas as formas não travadas têm valor zero, distribuindo igualmente');\n                const ajustePorForma = diferenca / formasOrdenadas.length;\n                formasOrdenadas.forEach({\n                    \"useSimulador.useCallback[redistribuirValores]\": (forma)=>{\n                        const formaIndex = novasFormas.findIndex({\n                            \"useSimulador.useCallback[redistribuirValores].formaIndex\": (f)=>f.id === forma.id\n                        }[\"useSimulador.useCallback[redistribuirValores].formaIndex\"]);\n                        const novoValor = Math.max(0, ajustePorForma);\n                        novasFormas[formaIndex] = {\n                            ...novasFormas[formaIndex],\n                            valor: novoValor\n                        };\n                    }\n                }[\"useSimulador.useCallback[redistribuirValores]\"]);\n            } else {\n                // Apenas a primeira forma não travada na ordem de prioridade absorve toda a diferença\n                console.log('Ajustando apenas a primeira forma na ordem de prioridade');\n                const primeiraForma = formasOrdenadas[0];\n                const formaIndex = novasFormas.findIndex({\n                    \"useSimulador.useCallback[redistribuirValores].formaIndex\": (f)=>f.id === primeiraForma.id\n                }[\"useSimulador.useCallback[redistribuirValores].formaIndex\"]);\n                const novoValor = Math.max(0, primeiraForma.valor + diferenca);\n                novasFormas[formaIndex] = {\n                    ...novasFormas[formaIndex],\n                    valor: novoValor\n                };\n                console.log(\"Forma \".concat(primeiraForma.tipo, \" ajustada de \").concat(primeiraForma.valor, \" para \").concat(novoValor));\n            }\n            return novasFormas;\n        }\n    }[\"useSimulador.useCallback[redistribuirValores]\"], []);\n    const recalcularSimulacao = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[recalcularSimulacao]\": (updates)=>{\n            console.log('Recalculando simulação com updates:', updates);\n            setSimulacao({\n                \"useSimulador.useCallback[recalcularSimulacao]\": (prev)=>{\n                    const updated = {\n                        ...prev,\n                        ...updates\n                    };\n                    // Lógica de travamento do valor negociado\n                    if (updated.travamentos.valorNegociado) {\n                        // Se valor negociado está travado, ajusta o desconto quando valor bruto muda\n                        if (updates.valorBruto !== undefined && updates.valorBruto > 0) {\n                            updated.desconto = (updated.valorBruto - updated.valorNegociado) / updated.valorBruto * 100;\n                        }\n                    } else {\n                        // Comportamento normal: calcula valor negociado baseado no desconto\n                        updated.valorNegociado = updated.valorBruto * (1 - updated.desconto / 100);\n                    }\n                    updated.formasPagamento = updated.formasPagamento.map({\n                        \"useSimulador.useCallback[recalcularSimulacao]\": (forma)=>({\n                                ...forma,\n                                valorRecebido: calcularValorRecebidoForma(forma)\n                            })\n                    }[\"useSimulador.useCallback[recalcularSimulacao]\"]);\n                    updated.valorRecebidoTotal = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[recalcularSimulacao]\": (acc, forma)=>acc + forma.valorRecebido\n                    }[\"useSimulador.useCallback[recalcularSimulacao]\"], 0);\n                    updated.descontoReal = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorRecebidoTotal) / updated.valorBruto * 100 : 0;\n                    const somaFormas = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[recalcularSimulacao].somaFormas\": (acc, forma)=>acc + forma.valor\n                    }[\"useSimulador.useCallback[recalcularSimulacao].somaFormas\"], 0);\n                    updated.valorRestante = updated.valorNegociado - somaFormas;\n                    console.log('Simulação atualizada:', updated);\n                    return updated;\n                }\n            }[\"useSimulador.useCallback[recalcularSimulacao]\"]);\n        }\n    }[\"useSimulador.useCallback[recalcularSimulacao]\"], [\n        calcularValorRecebidoForma\n    ]);\n    const editarValorNegociado = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[editarValorNegociado]\": (novoValor)=>{\n            console.log('Editando valor negociado para:', novoValor);\n            setSimulacao({\n                \"useSimulador.useCallback[editarValorNegociado]\": (prev)=>{\n                    const formasRedistribuidas = redistribuirValores(novoValor, prev.formasPagamento);\n                    if (!formasRedistribuidas) {\n                        alert('Não é possível alterar o valor. Todas as formas de pagamento estão travadas.');\n                        return prev;\n                    }\n                    const updated = {\n                        ...prev,\n                        valorNegociado: novoValor,\n                        formasPagamento: formasRedistribuidas.map({\n                            \"useSimulador.useCallback[editarValorNegociado]\": (forma)=>({\n                                    ...forma,\n                                    valorRecebido: calcularValorRecebidoForma(forma)\n                                })\n                        }[\"useSimulador.useCallback[editarValorNegociado]\"])\n                    };\n                    // Recalcular desconto\n                    updated.desconto = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorNegociado) / updated.valorBruto * 100 : 0;\n                    updated.valorRecebidoTotal = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[editarValorNegociado]\": (acc, forma)=>acc + forma.valorRecebido\n                    }[\"useSimulador.useCallback[editarValorNegociado]\"], 0);\n                    updated.descontoReal = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorRecebidoTotal) / updated.valorBruto * 100 : 0;\n                    const somaFormas = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[editarValorNegociado].somaFormas\": (acc, forma)=>acc + forma.valor\n                    }[\"useSimulador.useCallback[editarValorNegociado].somaFormas\"], 0);\n                    updated.valorRestante = updated.valorNegociado - somaFormas;\n                    return updated;\n                }\n            }[\"useSimulador.useCallback[editarValorNegociado]\"]);\n        }\n    }[\"useSimulador.useCallback[editarValorNegociado]\"], [\n        redistribuirValores,\n        calcularValorRecebidoForma\n    ]);\n    const editarDescontoReal = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[editarDescontoReal]\": (novoDesconto)=>{\n            console.log('Editando desconto real para:', novoDesconto);\n            setSimulacao({\n                \"useSimulador.useCallback[editarDescontoReal]\": (prev)=>{\n                    // Calcular novo valor negociado baseado no desconto\n                    const novoValorNegociado = prev.valorBruto * (1 - novoDesconto / 100);\n                    const formasRedistribuidas = redistribuirValores(novoValorNegociado, prev.formasPagamento);\n                    if (!formasRedistribuidas) {\n                        alert('Não é possível alterar o desconto. Todas as formas de pagamento estão travadas.');\n                        return prev;\n                    }\n                    const updated = {\n                        ...prev,\n                        desconto: novoDesconto,\n                        valorNegociado: novoValorNegociado,\n                        formasPagamento: formasRedistribuidas.map({\n                            \"useSimulador.useCallback[editarDescontoReal]\": (forma)=>({\n                                    ...forma,\n                                    valorRecebido: calcularValorRecebidoForma(forma)\n                                })\n                        }[\"useSimulador.useCallback[editarDescontoReal]\"])\n                    };\n                    updated.valorRecebidoTotal = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[editarDescontoReal]\": (acc, forma)=>acc + forma.valorRecebido\n                    }[\"useSimulador.useCallback[editarDescontoReal]\"], 0);\n                    updated.descontoReal = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorRecebidoTotal) / updated.valorBruto * 100 : 0;\n                    const somaFormas = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[editarDescontoReal].somaFormas\": (acc, forma)=>acc + forma.valor\n                    }[\"useSimulador.useCallback[editarDescontoReal].somaFormas\"], 0);\n                    updated.valorRestante = updated.valorNegociado - somaFormas;\n                    return updated;\n                }\n            }[\"useSimulador.useCallback[editarDescontoReal]\"]);\n        }\n    }[\"useSimulador.useCallback[editarDescontoReal]\"], [\n        redistribuirValores,\n        calcularValorRecebidoForma\n    ]);\n    const editarValorBruto = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[editarValorBruto]\": (novoValor)=>{\n            console.log('Editando valor bruto para:', novoValor);\n            recalcularSimulacao({\n                valorBruto: novoValor\n            });\n        }\n    }[\"useSimulador.useCallback[editarValorBruto]\"], [\n        recalcularSimulacao\n    ]);\n    const adicionarForma = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[adicionarForma]\": (forma)=>{\n            console.log('Adicionando forma:', forma);\n            setSimulacao({\n                \"useSimulador.useCallback[adicionarForma]\": (prev)=>{\n                    // Verificar travamento de desconto real\n                    if (prev.travamentos.descontoReal) {\n                        const novaFormaTemp = {\n                            ...forma,\n                            id: Date.now().toString(),\n                            valorRecebido: 0\n                        };\n                        novaFormaTemp.valorRecebido = calcularValorRecebidoForma(novaFormaTemp);\n                        const novoValorRecebidoTotal = prev.valorRecebidoTotal + novaFormaTemp.valorRecebido;\n                        const novoDescontoReal = prev.valorBruto > 0 ? (prev.valorBruto - novoValorRecebidoTotal) / prev.valorBruto * 100 : 0;\n                        if (novoDescontoReal > prev.travamentos.limiteDescontoReal) {\n                            alert(\"N\\xe3o \\xe9 poss\\xedvel adicionar esta forma. O desconto real excederia o limite de \".concat(prev.travamentos.limiteDescontoReal, \"%\"));\n                            return prev;\n                        }\n                    }\n                    const novaForma = {\n                        ...forma,\n                        id: Date.now().toString(),\n                        valorRecebido: 0,\n                        travado: false\n                    };\n                    novaForma.valorRecebido = calcularValorRecebidoForma(novaForma);\n                    const novasFormas = [\n                        ...prev.formasPagamento,\n                        novaForma\n                    ];\n                    const updated = {\n                        ...prev,\n                        formasPagamento: novasFormas\n                    };\n                    updated.valorRecebidoTotal = novasFormas.reduce({\n                        \"useSimulador.useCallback[adicionarForma]\": (acc, f)=>acc + f.valorRecebido\n                    }[\"useSimulador.useCallback[adicionarForma]\"], 0);\n                    updated.descontoReal = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorRecebidoTotal) / updated.valorBruto * 100 : 0;\n                    const somaFormas = novasFormas.reduce({\n                        \"useSimulador.useCallback[adicionarForma].somaFormas\": (acc, f)=>acc + f.valor\n                    }[\"useSimulador.useCallback[adicionarForma].somaFormas\"], 0);\n                    updated.valorRestante = updated.valorNegociado - somaFormas;\n                    console.log('Nova simulação com forma adicionada:', updated);\n                    return updated;\n                }\n            }[\"useSimulador.useCallback[adicionarForma]\"]);\n        }\n    }[\"useSimulador.useCallback[adicionarForma]\"], [\n        calcularValorRecebidoForma\n    ]);\n    const atualizarForma = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[atualizarForma]\": (id, dadosAtualizados)=>{\n            console.log('Atualizando forma:', id, dadosAtualizados);\n            setSimulacao({\n                \"useSimulador.useCallback[atualizarForma]\": (prev)=>{\n                    const novasFormas = prev.formasPagamento.map({\n                        \"useSimulador.useCallback[atualizarForma].novasFormas\": (forma)=>{\n                            if (forma.id === id) {\n                                // Se a forma está travada, não permite alterar o valor\n                                if (forma.travado && dadosAtualizados.valor !== forma.valor) {\n                                    console.log('Forma travada, não é possível alterar o valor');\n                                    return forma;\n                                }\n                                const formaAtualizada = {\n                                    ...forma,\n                                    ...dadosAtualizados\n                                };\n                                formaAtualizada.valorRecebido = calcularValorRecebidoForma(formaAtualizada);\n                                return formaAtualizada;\n                            }\n                            return forma;\n                        }\n                    }[\"useSimulador.useCallback[atualizarForma].novasFormas\"]);\n                    const updated = {\n                        ...prev,\n                        formasPagamento: novasFormas\n                    };\n                    updated.valorRecebidoTotal = novasFormas.reduce({\n                        \"useSimulador.useCallback[atualizarForma]\": (acc, f)=>acc + f.valorRecebido\n                    }[\"useSimulador.useCallback[atualizarForma]\"], 0);\n                    updated.descontoReal = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorRecebidoTotal) / updated.valorBruto * 100 : 0;\n                    const somaFormas = novasFormas.reduce({\n                        \"useSimulador.useCallback[atualizarForma].somaFormas\": (acc, f)=>acc + f.valor\n                    }[\"useSimulador.useCallback[atualizarForma].somaFormas\"], 0);\n                    updated.valorRestante = updated.valorNegociado - somaFormas;\n                    console.log('Simulação atualizada após edição:', updated);\n                    return updated;\n                }\n            }[\"useSimulador.useCallback[atualizarForma]\"]);\n        }\n    }[\"useSimulador.useCallback[atualizarForma]\"], [\n        calcularValorRecebidoForma\n    ]);\n    const removerForma = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[removerForma]\": (id)=>{\n            console.log('Removendo forma:', id);\n            setSimulacao({\n                \"useSimulador.useCallback[removerForma]\": (prev)=>{\n                    const novasFormas = prev.formasPagamento.filter({\n                        \"useSimulador.useCallback[removerForma].novasFormas\": (f)=>f.id !== id\n                    }[\"useSimulador.useCallback[removerForma].novasFormas\"]);\n                    return {\n                        ...prev,\n                        formasPagamento: novasFormas,\n                        valorRecebidoTotal: novasFormas.reduce({\n                            \"useSimulador.useCallback[removerForma]\": (acc, f)=>acc + f.valorRecebido\n                        }[\"useSimulador.useCallback[removerForma]\"], 0),\n                        descontoReal: prev.valorBruto > 0 ? (prev.valorBruto - novasFormas.reduce({\n                            \"useSimulador.useCallback[removerForma]\": (acc, f)=>acc + f.valorRecebido\n                        }[\"useSimulador.useCallback[removerForma]\"], 0)) / prev.valorBruto * 100 : 0,\n                        valorRestante: prev.valorNegociado - novasFormas.reduce({\n                            \"useSimulador.useCallback[removerForma]\": (acc, f)=>acc + f.valor\n                        }[\"useSimulador.useCallback[removerForma]\"], 0)\n                    };\n                }\n            }[\"useSimulador.useCallback[removerForma]\"]);\n        }\n    }[\"useSimulador.useCallback[removerForma]\"], []);\n    const limparFormas = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[limparFormas]\": ()=>{\n            console.log('Limpando todas as formas');\n            setSimulacao({\n                \"useSimulador.useCallback[limparFormas]\": (prev)=>({\n                        ...prev,\n                        formasPagamento: [],\n                        valorRecebidoTotal: 0,\n                        descontoReal: prev.valorBruto > 0 ? 100 : 0,\n                        valorRestante: prev.valorNegociado\n                    })\n            }[\"useSimulador.useCallback[limparFormas]\"]);\n        }\n    }[\"useSimulador.useCallback[limparFormas]\"], []);\n    const alternarTravamento = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[alternarTravamento]\": (tipo, valor)=>{\n            setSimulacao({\n                \"useSimulador.useCallback[alternarTravamento]\": (prev)=>({\n                        ...prev,\n                        travamentos: {\n                            ...prev.travamentos,\n                            [tipo]: !prev.travamentos[tipo],\n                            ...valor !== undefined && {\n                                limiteDescontoReal: valor\n                            }\n                        }\n                    })\n            }[\"useSimulador.useCallback[alternarTravamento]\"]);\n        }\n    }[\"useSimulador.useCallback[alternarTravamento]\"], []);\n    const alternarTravamentoForma = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[alternarTravamentoForma]\": (id)=>{\n            setSimulacao({\n                \"useSimulador.useCallback[alternarTravamentoForma]\": (prev)=>({\n                        ...prev,\n                        formasPagamento: prev.formasPagamento.map({\n                            \"useSimulador.useCallback[alternarTravamentoForma]\": (forma)=>forma.id === id ? {\n                                    ...forma,\n                                    travado: !forma.travado\n                                } : forma\n                        }[\"useSimulador.useCallback[alternarTravamentoForma]\"])\n                    })\n            }[\"useSimulador.useCallback[alternarTravamentoForma]\"]);\n        }\n    }[\"useSimulador.useCallback[alternarTravamentoForma]\"], []);\n    return {\n        simulacao,\n        recalcularSimulacao,\n        adicionarForma,\n        atualizarForma,\n        removerForma,\n        limparFormas,\n        alternarTravamento,\n        alternarTravamentoForma,\n        editarValorNegociado,\n        editarValorBruto,\n        editarDescontoReal\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VTaW11bGFkb3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQThDO0FBR3ZDLE1BQU1FLGVBQWU7SUFDMUIsTUFBTSxDQUFDQyxXQUFXQyxhQUFhLEdBQUdKLCtDQUFRQSxDQUFZO1FBQ3BESyxZQUFZO1FBQ1pDLFVBQVU7UUFDVkMsZ0JBQWdCO1FBQ2hCQyxpQkFBaUIsRUFBRTtRQUNuQkMsb0JBQW9CO1FBQ3BCQyxjQUFjO1FBQ2RDLGVBQWU7UUFDZkMsYUFBYTtZQUNYTCxnQkFBZ0I7WUFDaEJHLGNBQWM7WUFDZEcsb0JBQW9CO1FBQ3RCO0lBQ0Y7SUFFQSw0Q0FBNEM7SUFDNUMsTUFBTUMsb0JBQW9CO1FBQUM7UUFBVztRQUFVO1FBQWM7S0FBUztJQUV2RSxNQUFNQyw2QkFBNkJkLGtEQUFXQTtnRUFBQyxDQUFDZTtZQUM5Q0MsUUFBUUMsR0FBRyxDQUFDLG1DQUFtQ0Y7WUFFL0MsT0FBUUEsTUFBTUcsSUFBSTtnQkFDaEIsS0FBSztvQkFDSCxPQUFPSCxNQUFNSSxLQUFLO2dCQUVwQixLQUFLO29CQUNILElBQUksQ0FBQ0osTUFBTUssUUFBUSxJQUFJLENBQUNMLE1BQU1NLFNBQVMsRUFBRSxPQUFPTixNQUFNSSxLQUFLO29CQUMzRCxNQUFNRyxJQUFJUCxNQUFNTSxTQUFTLEdBQUc7b0JBQzVCLE1BQU1ELFdBQVdMLE1BQU1LLFFBQVE7b0JBQy9CLE1BQU1HLGdCQUFnQlIsTUFBTUksS0FBSyxHQUFHSyxLQUFLQyxHQUFHLENBQUMsSUFBSUgsR0FBR0Y7b0JBQ3BESixRQUFRQyxHQUFHLENBQUMscUJBQThDRyxPQUF6QkwsTUFBTUksS0FBSyxFQUFDLGVBQStCSixPQUFsQkssVUFBUyxXQUFpQ0csT0FBeEJSLE1BQU1NLFNBQVMsRUFBQyxVQUFzQixPQUFkRTtvQkFDcEcsT0FBT0E7Z0JBRVQsS0FBSztvQkFDSCxJQUFJLENBQUNSLE1BQU1XLFFBQVEsSUFBSSxDQUFDWCxNQUFNWSxnQkFBZ0Is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UUFDQUM7UUFDQXBCO1FBQ0FLO1FBQ0FGO0lBQ0Y7QUFDRixFQUFFIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHJpY2FyXFxQcm9qZXRvc1xcZmx1eXQtcHJvcG9zdGEtc2ltdWxhZG9yXFxzcmNcXGhvb2tzXFx1c2VTaW11bGFkb3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRm9ybWFQYWdhbWVudG8sIFNpbXVsYWNhbywgVHJhdmFtZW50b0NvbmZpZyB9IGZyb20gJy4uL3R5cGVzL3NpbXVsYWRvcic7XG5cbmV4cG9ydCBjb25zdCB1c2VTaW11bGFkb3IgPSAoKSA9PiB7XG4gIGNvbnN0IFtzaW11bGFjYW8sIHNldFNpbXVsYWNhb10gPSB1c2VTdGF0ZTxTaW11bGFjYW8+KHtcbiAgICB2YWxvckJydXRvOiAwLFxuICAgIGRlc2NvbnRvOiAwLFxuICAgIHZhbG9yTmVnb2NpYWRvOiAwLFxuICAgIGZvcm1hc1BhZ2FtZW50bzogW10sXG4gICAgdmFsb3JSZWNlYmlkb1RvdGFsOiAwLFxuICAgIGRlc2NvbnRvUmVhbDogMCxcbiAgICB2YWxvclJlc3RhbnRlOiAwLFxuICAgIHRyYXZhbWVudG9zOiB7XG4gICAgICB2YWxvck5lZ29jaWFkbzogZmFsc2UsXG4gICAgICBkZXNjb250b1JlYWw6IGZhbHNlLFxuICAgICAgbGltaXRlRGVzY29udG9SZWFsOiAyNVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gUHJpb3JpZGFkZSBwYXJhIHJlZGlzdHJpYnVpw6fDo28gZGUgdmFsb3Jlc1xuICBjb25zdCBQUklPUklEQURFX0ZPUk1BUyA9IFsnRU5UUkFEQScsICdCT0xFVE8nLCAnRklOQU5DRUlSQScsICdDQVJUQU8nXTtcblxuICBjb25zdCBjYWxjdWxhclZhbG9yUmVjZWJpZG9Gb3JtYSA9IHVzZUNhbGxiYWNrKChmb3JtYTogRm9ybWFQYWdhbWVudG8pOiBudW1iZXIgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdDYWxjdWxhbmRvIHZhbG9yIHJlY2ViaWRvIHBhcmE6JywgZm9ybWEpO1xuICAgIFxuICAgIHN3aXRjaCAoZm9ybWEudGlwbykge1xuICAgICAgY2FzZSAnRU5UUkFEQSc6XG4gICAgICAgIHJldHVybiBmb3JtYS52YWxvcjtcbiAgICAgIFxuICAgICAgY2FzZSAnRklOQU5DRUlSQSc6XG4gICAgICAgIGlmICghZm9ybWEucGFyY2VsYXMgfHwgIWZvcm1hLnRheGFKdXJvcykgcmV0dXJuIGZvcm1hLnZhbG9yO1xuICAgICAgICBjb25zdCBpID0gZm9ybWEudGF4YUp1cm9zIC8gMTAwO1xuICAgICAgICBjb25zdCBwYXJjZWxhcyA9IGZvcm1hLnBhcmNlbGFzO1xuICAgICAgICBjb25zdCB2YWxvclByZXNlbnRlID0gZm9ybWEudmFsb3IgLyBNYXRoLnBvdygxICsgaSwgcGFyY2VsYXMpO1xuICAgICAgICBjb25zb2xlLmxvZyhgRmluYW5jZWlyYTogdmFsb3I9JHtmb3JtYS52YWxvcn0sIHBhcmNlbGFzPSR7cGFyY2VsYXN9LCB0YXhhPSR7Zm9ybWEudGF4YUp1cm9zfSUsIFZQPSR7dmFsb3JQcmVzZW50ZX1gKTtcbiAgICAgICAgcmV0dXJuIHZhbG9yUHJlc2VudGU7XG4gICAgICBcbiAgICAgIGNhc2UgJ0NBUlRBTyc6XG4gICAgICAgIGlmICghZm9ybWEuZGVmbGFjYW8gfHwgIWZvcm1hLmp1cm9zQW50ZWNpcGFjYW8gfHwgIWZvcm1hLnBhcmNlbGFzKSByZXR1cm4gZm9ybWEudmFsb3I7XG4gICAgICAgIGNvbnN0IGZhdG9yRGVmbGFjYW8gPSAxIC0gKGZvcm1hLmRlZmxhY2FvIC8gMTAwKTtcbiAgICAgICAgY29uc3QgZmF0b3JKdXJvcyA9IDEgLSAoZm9ybWEuanVyb3NBbnRlY2lwYWNhbyAvIDEwMCAqIGZvcm1hLnBhcmNlbGFzKTtcbiAgICAgICAgY29uc3QgdmFsb3JSZWNlYmlkbyA9IGZvcm1hLnZhbG9yICogZmF0b3JEZWZsYWNhbyAqIGZhdG9ySnVyb3M7XG4gICAgICAgIGNvbnNvbGUubG9nKGBDYXJ0w6NvOiB2YWxvcj0ke2Zvcm1hLnZhbG9yfSwgZGVmbGHDp8Ojbz0ke2Zvcm1hLmRlZmxhY2FvfSUsIGp1cm9zPSR7Zm9ybWEuanVyb3NBbnRlY2lwYWNhb30lLCBWUj0ke3ZhbG9yUmVjZWJpZG99YCk7XG4gICAgICAgIHJldHVybiB2YWxvclJlY2ViaWRvO1xuICAgICAgXG4gICAgICBjYXNlICdCT0xFVE8nOlxuICAgICAgICBpZiAoIWZvcm1hLnBhcmNlbGFzIHx8ICFmb3JtYS5jdXN0b0NhcGl0YWwpIHJldHVybiBmb3JtYS52YWxvcjtcbiAgICAgICAgY29uc3QgaWMgPSBmb3JtYS5jdXN0b0NhcGl0YWwgLyAxMDA7XG4gICAgICAgIGNvbnN0IHZhbG9yUHJlc2VudGVCb2xldG8gPSBmb3JtYS52YWxvciAvIE1hdGgucG93KDEgKyBpYywgZm9ybWEucGFyY2VsYXMpO1xuICAgICAgICBjb25zb2xlLmxvZyhgQm9sZXRvOiB2YWxvcj0ke2Zvcm1hLnZhbG9yfSwgcGFyY2VsYXM9JHtmb3JtYS5wYXJjZWxhc30sIGN1c3RvPSR7Zm9ybWEuY3VzdG9DYXBpdGFsfSUsIFZQPSR7dmFsb3JQcmVzZW50ZUJvbGV0b31gKTtcbiAgICAgICAgcmV0dXJuIHZhbG9yUHJlc2VudGVCb2xldG87XG4gICAgICBcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmb3JtYS52YWxvcjtcbiAgICB9XG4gIH0sIFtdKTtcblxuICBjb25zdCByZWRpc3RyaWJ1aXJWYWxvcmVzID0gdXNlQ2FsbGJhY2soKG5vdm9WYWxvck5lZ29jaWFkbzogbnVtYmVyLCBmb3JtYXNBdHVhaXM6IEZvcm1hUGFnYW1lbnRvW10pID0+IHtcbiAgICBjb25zb2xlLmxvZygnUmVkaXN0cmlidWluZG8gdmFsb3Jlcy4gTm92byB2YWxvciBuZWdvY2lhZG86Jywgbm92b1ZhbG9yTmVnb2NpYWRvKTtcbiAgICBcbiAgICBjb25zdCBzb21hQXR1YWwgPSBmb3JtYXNBdHVhaXMucmVkdWNlKChhY2MsIGZvcm1hKSA9PiBhY2MgKyBmb3JtYS52YWxvciwgMCk7XG4gICAgY29uc3QgZGlmZXJlbmNhID0gbm92b1ZhbG9yTmVnb2NpYWRvIC0gc29tYUF0dWFsO1xuICAgIFxuICAgIGlmIChNYXRoLmFicyhkaWZlcmVuY2EpIDwgMC4wMSkge1xuICAgICAgcmV0dXJuIGZvcm1hc0F0dWFpczsgLy8gTsOjbyBow6EgZGlmZXJlbsOnYSBzaWduaWZpY2F0aXZhXG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdEaWZlcmVuw6dhIGEgcmVkaXN0cmlidWlyOicsIGRpZmVyZW5jYSk7XG4gICAgXG4gICAgLy8gU2VwYXJhciBmb3JtYXMgdHJhdmFkYXMgZSBuw6NvIHRyYXZhZGFzXG4gICAgY29uc3QgZm9ybWFzVHJhdmFkYXMgPSBmb3JtYXNBdHVhaXMuZmlsdGVyKGZvcm1hID0+IGZvcm1hLnRyYXZhZG8pO1xuICAgIGNvbnN0IGZvcm1hc05hb1RyYXZhZGFzID0gZm9ybWFzQXR1YWlzLmZpbHRlcihmb3JtYSA9PiAhZm9ybWEudHJhdmFkbyk7XG4gICAgXG4gICAgLy8gU2UgdG9kYXMgZXN0w6NvIHRyYXZhZGFzLCBuw6NvIHBvZGVtb3MgcmVkaXN0cmlidWlyXG4gICAgaWYgKGZvcm1hc05hb1RyYXZhZGFzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5sb2coJ1RvZGFzIGFzIGZvcm1hcyBlc3TDo28gdHJhdmFkYXMnKTtcbiAgICAgIHJldHVybiBudWxsOyAvLyBJbmRpY2EgZXJyb1xuICAgIH1cbiAgICBcbiAgICAvLyBPcmRlbmFyIGZvcm1hcyBuw6NvIHRyYXZhZGFzIHBvciBwcmlvcmlkYWRlXG4gICAgY29uc3QgZm9ybWFzT3JkZW5hZGFzID0gZm9ybWFzTmFvVHJhdmFkYXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgcHJpb3JpZGFkZUEgPSBQUklPUklEQURFX0ZPUk1BUy5pbmRleE9mKGEudGlwbyk7XG4gICAgICBjb25zdCBwcmlvcmlkYWRlQiA9IFBSSU9SSURBREVfRk9STUFTLmluZGV4T2YoYi50aXBvKTtcbiAgICAgIHJldHVybiBwcmlvcmlkYWRlQSAtIHByaW9yaWRhZGVCO1xuICAgIH0pO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdGb3JtYXMgb3JkZW5hZGFzIHBvciBwcmlvcmlkYWRlOicsIGZvcm1hc09yZGVuYWRhcy5tYXAoZiA9PiBmLnRpcG8pKTtcbiAgICBcbiAgICAvLyBSZWRpc3RyaWJ1aXIgYSBkaWZlcmVuw6dhOiBhcGVuYXMgYSBwcmltZWlyYSBmb3JtYSBuYSBvcmRlbSBkZSBwcmlvcmlkYWRlIGFic29ydmUgdG9kYSBhIGRpZmVyZW7Dp2FcbiAgICBjb25zdCBub3Zhc0Zvcm1hcyA9IFsuLi5mb3JtYXNBdHVhaXNdO1xuICAgIFxuICAgIC8vIFZlcmlmaWNhciBzZSB0b2RhcyBhcyBmb3JtYXMgbsOjbyB0cmF2YWRhcyB0w6ptIHZhbG9yIHplcm9cbiAgICBjb25zdCBzb21hRm9ybWFzTmFvVHJhdmFkYXMgPSBmb3JtYXNPcmRlbmFkYXMucmVkdWNlKChhY2MsIGZvcm1hKSA9PiBhY2MgKyBmb3JtYS52YWxvciwgMCk7XG4gICAgXG4gICAgaWYgKHNvbWFGb3JtYXNOYW9UcmF2YWRhcyA9PT0gMCkge1xuICAgICAgLy8gU2UgdG9kYXMgYXMgZm9ybWFzIG7Do28gdHJhdmFkYXMgdMOqbSB2YWxvciAwLCBkaXN0cmlidWkgaWd1YWxtZW50ZVxuICAgICAgY29uc29sZS5sb2coJ1RvZGFzIGFzIGZvcm1hcyBuw6NvIHRyYXZhZGFzIHTDqm0gdmFsb3IgemVybywgZGlzdHJpYnVpbmRvIGlndWFsbWVudGUnKTtcbiAgICAgIGNvbnN0IGFqdXN0ZVBvckZvcm1hID0gZGlmZXJlbmNhIC8gZm9ybWFzT3JkZW5hZGFzLmxlbmd0aDtcbiAgICAgIGZvcm1hc09yZGVuYWRhcy5mb3JFYWNoKGZvcm1hID0+IHtcbiAgICAgICAgY29uc3QgZm9ybWFJbmRleCA9IG5vdmFzRm9ybWFzLmZpbmRJbmRleChmID0+IGYuaWQgPT09IGZvcm1hLmlkKTtcbiAgICAgICAgY29uc3Qgbm92b1ZhbG9yID0gTWF0aC5tYXgoMCwgYWp1c3RlUG9yRm9ybWEpO1xuICAgICAgICBub3Zhc0Zvcm1hc1tmb3JtYUluZGV4XSA9IHsgLi4ubm92YXNGb3JtYXNbZm9ybWFJbmRleF0sIHZhbG9yOiBub3ZvVmFsb3IgfTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBcGVuYXMgYSBwcmltZWlyYSBmb3JtYSBuw6NvIHRyYXZhZGEgbmEgb3JkZW0gZGUgcHJpb3JpZGFkZSBhYnNvcnZlIHRvZGEgYSBkaWZlcmVuw6dhXG4gICAgICBjb25zb2xlLmxvZygnQWp1c3RhbmRvIGFwZW5hcyBhIHByaW1laXJhIGZvcm1hIG5hIG9yZGVtIGRlIHByaW9yaWRhZGUnKTtcbiAgICAgIGNvbnN0IHByaW1laXJhRm9ybWEgPSBmb3JtYXNPcmRlbmFkYXNbMF07XG4gICAgICBjb25zdCBmb3JtYUluZGV4ID0gbm92YXNGb3JtYXMuZmluZEluZGV4KGYgPT4gZi5pZCA9PT0gcHJpbWVpcmFGb3JtYS5pZCk7XG4gICAgICBjb25zdCBub3ZvVmFsb3IgPSBNYXRoLm1heCgwLCBwcmltZWlyYUZvcm1hLnZhbG9yICsgZGlmZXJlbmNhKTtcbiAgICAgIG5vdmFzRm9ybWFzW2Zvcm1hSW5kZXhdID0geyAuLi5ub3Zhc0Zvcm1hc1tmb3JtYUluZGV4XSwgdmFsb3I6IG5vdm9WYWxvciB9O1xuICAgICAgY29uc29sZS5sb2coYEZvcm1hICR7cHJpbWVpcmFGb3JtYS50aXBvfSBhanVzdGFkYSBkZSAke3ByaW1laXJhRm9ybWEudmFsb3J9IHBhcmEgJHtub3ZvVmFsb3J9YCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBub3Zhc0Zvcm1hcztcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHJlY2FsY3VsYXJTaW11bGFjYW8gPSB1c2VDYWxsYmFjaygodXBkYXRlczogUGFydGlhbDxTaW11bGFjYW8+KSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1JlY2FsY3VsYW5kbyBzaW11bGHDp8OjbyBjb20gdXBkYXRlczonLCB1cGRhdGVzKTtcbiAgICBcbiAgICBzZXRTaW11bGFjYW8ocHJldiA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkID0geyAuLi5wcmV2LCAuLi51cGRhdGVzIH07XG4gICAgICBcbiAgICAgIC8vIEzDs2dpY2EgZGUgdHJhdmFtZW50byBkbyB2YWxvciBuZWdvY2lhZG9cbiAgICAgIGlmICh1cGRhdGVkLnRyYXZhbWVudG9zLnZhbG9yTmVnb2NpYWRvKSB7XG4gICAgICAgIC8vIFNlIHZhbG9yIG5lZ29jaWFkbyBlc3TDoSB0cmF2YWRvLCBhanVzdGEgbyBkZXNjb250byBxdWFuZG8gdmFsb3IgYnJ1dG8gbXVkYVxuICAgICAgICBpZiAodXBkYXRlcy52YWxvckJydXRvICE9PSB1bmRlZmluZWQgJiYgdXBkYXRlcy52YWxvckJydXRvID4gMCkge1xuICAgICAgICAgIHVwZGF0ZWQuZGVzY29udG8gPSAoKHVwZGF0ZWQudmFsb3JCcnV0byAtIHVwZGF0ZWQudmFsb3JOZWdvY2lhZG8pIC8gdXBkYXRlZC52YWxvckJydXRvKSAqIDEwMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29tcG9ydGFtZW50byBub3JtYWw6IGNhbGN1bGEgdmFsb3IgbmVnb2NpYWRvIGJhc2VhZG8gbm8gZGVzY29udG9cbiAgICAgICAgdXBkYXRlZC52YWxvck5lZ29jaWFkbyA9IHVwZGF0ZWQudmFsb3JCcnV0byAqICgxIC0gdXBkYXRlZC5kZXNjb250byAvIDEwMCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHVwZGF0ZWQuZm9ybWFzUGFnYW1lbnRvID0gdXBkYXRlZC5mb3JtYXNQYWdhbWVudG8ubWFwKGZvcm1hID0+ICh7XG4gICAgICAgIC4uLmZvcm1hLFxuICAgICAgICB2YWxvclJlY2ViaWRvOiBjYWxjdWxhclZhbG9yUmVjZWJpZG9Gb3JtYShmb3JtYSlcbiAgICAgIH0pKTtcbiAgICAgIFxuICAgICAgdXBkYXRlZC52YWxvclJlY2ViaWRvVG90YWwgPSB1cGRhdGVkLmZvcm1hc1BhZ2FtZW50by5yZWR1Y2UoKGFjYywgZm9ybWEpID0+IGFjYyArIGZvcm1hLnZhbG9yUmVjZWJpZG8sIDApO1xuICAgICAgdXBkYXRlZC5kZXNjb250b1JlYWwgPSB1cGRhdGVkLnZhbG9yQnJ1dG8gPiAwID8gKCh1cGRhdGVkLnZhbG9yQnJ1dG8gLSB1cGRhdGVkLnZhbG9yUmVjZWJpZG9Ub3RhbCkgLyB1cGRhdGVkLnZhbG9yQnJ1dG8pICogMTAwIDogMDtcbiAgICAgIFxuICAgICAgY29uc3Qgc29tYUZvcm1hcyA9IHVwZGF0ZWQuZm9ybWFzUGFnYW1lbnRvLnJlZHVjZSgoYWNjLCBmb3JtYSkgPT4gYWNjICsgZm9ybWEudmFsb3IsIDApO1xuICAgICAgdXBkYXRlZC52YWxvclJlc3RhbnRlID0gdXBkYXRlZC52YWxvck5lZ29jaWFkbyAtIHNvbWFGb3JtYXM7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdTaW11bGHDp8OjbyBhdHVhbGl6YWRhOicsIHVwZGF0ZWQpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfSk7XG4gIH0sIFtjYWxjdWxhclZhbG9yUmVjZWJpZG9Gb3JtYV0pO1xuXG4gIGNvbnN0IGVkaXRhclZhbG9yTmVnb2NpYWRvID0gdXNlQ2FsbGJhY2soKG5vdm9WYWxvcjogbnVtYmVyKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0VkaXRhbmRvIHZhbG9yIG5lZ29jaWFkbyBwYXJhOicsIG5vdm9WYWxvcik7XG4gICAgXG4gICAgc2V0U2ltdWxhY2FvKHByZXYgPT4ge1xuICAgICAgY29uc3QgZm9ybWFzUmVkaXN0cmlidWlkYXMgPSByZWRpc3RyaWJ1aXJWYWxvcmVzKG5vdm9WYWxvciwgcHJldi5mb3JtYXNQYWdhbWVudG8pO1xuICAgICAgXG4gICAgICBpZiAoIWZvcm1hc1JlZGlzdHJpYnVpZGFzKSB7XG4gICAgICAgIGFsZXJ0KCdOw6NvIMOpIHBvc3PDrXZlbCBhbHRlcmFyIG8gdmFsb3IuIFRvZGFzIGFzIGZvcm1hcyBkZSBwYWdhbWVudG8gZXN0w6NvIHRyYXZhZGFzLicpO1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgdXBkYXRlZCA9IHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgdmFsb3JOZWdvY2lhZG86IG5vdm9WYWxvcixcbiAgICAgICAgZm9ybWFzUGFnYW1lbnRvOiBmb3JtYXNSZWRpc3RyaWJ1aWRhcy5tYXAoZm9ybWEgPT4gKHtcbiAgICAgICAgICAuLi5mb3JtYSxcbiAgICAgICAgICB2YWxvclJlY2ViaWRvOiBjYWxjdWxhclZhbG9yUmVjZWJpZG9Gb3JtYShmb3JtYSlcbiAgICAgICAgfSkpXG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBSZWNhbGN1bGFyIGRlc2NvbnRvXG4gICAgICB1cGRhdGVkLmRlc2NvbnRvID0gdXBkYXRlZC52YWxvckJydXRvID4gMCA/ICgodXBkYXRlZC52YWxvckJydXRvIC0gdXBkYXRlZC52YWxvck5lZ29jaWFkbykgLyB1cGRhdGVkLnZhbG9yQnJ1dG8pICogMTAwIDogMDtcbiAgICAgIFxuICAgICAgdXBkYXRlZC52YWxvclJlY2ViaWRvVG90YWwgPSB1cGRhdGVkLmZvcm1hc1BhZ2FtZW50by5yZWR1Y2UoKGFjYywgZm9ybWEpID0+IGFjYyArIGZvcm1hLnZhbG9yUmVjZWJpZG8sIDApO1xuICAgICAgdXBkYXRlZC5kZXNjb250b1JlYWwgPSB1cGRhdGVkLnZhbG9yQnJ1dG8gPiAwID8gKCh1cGRhdGVkLnZhbG9yQnJ1dG8gLSB1cGRhdGVkLnZhbG9yUmVjZWJpZG9Ub3RhbCkgLyB1cGRhdGVkLnZhbG9yQnJ1dG8pICogMTAwIDogMDtcbiAgICAgIFxuICAgICAgY29uc3Qgc29tYUZvcm1hcyA9IHVwZGF0ZWQuZm9ybWFzUGFnYW1lbnRvLnJlZHVjZSgoYWNjLCBmb3JtYSkgPT4gYWNjICsgZm9ybWEudmFsb3IsIDApO1xuICAgICAgdXBkYXRlZC52YWxvclJlc3RhbnRlID0gdXBkYXRlZC52YWxvck5lZ29jaWFkbyAtIHNvbWFGb3JtYXM7XG4gICAgICBcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0pO1xuICB9LCBbcmVkaXN0cmlidWlyVmFsb3JlcywgY2FsY3VsYXJWYWxvclJlY2ViaWRvRm9ybWFdKTtcblxuICBjb25zdCBlZGl0YXJEZXNjb250b1JlYWwgPSB1c2VDYWxsYmFjaygobm92b0Rlc2NvbnRvOiBudW1iZXIpID0+IHtcbiAgICBjb25zb2xlLmxvZygnRWRpdGFuZG8gZGVzY29udG8gcmVhbCBwYXJhOicsIG5vdm9EZXNjb250byk7XG4gICAgXG4gICAgc2V0U2ltdWxhY2FvKHByZXYgPT4ge1xuICAgICAgLy8gQ2FsY3VsYXIgbm92byB2YWxvciBuZWdvY2lhZG8gYmFzZWFkbyBubyBkZXNjb250b1xuICAgICAgY29uc3Qgbm92b1ZhbG9yTmVnb2NpYWRvID0gcHJldi52YWxvckJydXRvICogKDEgLSBub3ZvRGVzY29udG8gLyAxMDApO1xuICAgICAgXG4gICAgICBjb25zdCBmb3JtYXNSZWRpc3RyaWJ1aWRhcyA9IHJlZGlzdHJpYnVpclZhbG9yZXMobm92b1ZhbG9yTmVnb2NpYWRvLCBwcmV2LmZvcm1hc1BhZ2FtZW50byk7XG4gICAgICBcbiAgICAgIGlmICghZm9ybWFzUmVkaXN0cmlidWlkYXMpIHtcbiAgICAgICAgYWxlcnQoJ07Do28gw6kgcG9zc8OtdmVsIGFsdGVyYXIgbyBkZXNjb250by4gVG9kYXMgYXMgZm9ybWFzIGRlIHBhZ2FtZW50byBlc3TDo28gdHJhdmFkYXMuJyk7XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCB1cGRhdGVkID0ge1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBkZXNjb250bzogbm92b0Rlc2NvbnRvLFxuICAgICAgICB2YWxvck5lZ29jaWFkbzogbm92b1ZhbG9yTmVnb2NpYWRvLFxuICAgICAgICBmb3JtYXNQYWdhbWVudG86IGZvcm1hc1JlZGlzdHJpYnVpZGFzLm1hcChmb3JtYSA9PiAoe1xuICAgICAgICAgIC4uLmZvcm1hLFxuICAgICAgICAgIHZhbG9yUmVjZWJpZG86IGNhbGN1bGFyVmFsb3JSZWNlYmlkb0Zvcm1hKGZvcm1hKVxuICAgICAgICB9KSlcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHVwZGF0ZWQudmFsb3JSZWNlYmlkb1RvdGFsID0gdXBkYXRlZC5mb3JtYXNQYWdhbWVudG8ucmVkdWNlKChhY2MsIGZvcm1hKSA9PiBhY2MgKyBmb3JtYS52YWxvclJlY2ViaWRvLCAwKTtcbiAgICAgIHVwZGF0ZWQuZGVzY29udG9SZWFsID0gdXBkYXRlZC52YWxvckJydXRvID4gMCA/ICgodXBkYXRlZC52YWxvckJydXRvIC0gdXBkYXRlZC52YWxvclJlY2ViaWRvVG90YWwpIC8gdXBkYXRlZC52YWxvckJydXRvKSAqIDEwMCA6IDA7XG4gICAgICBcbiAgICAgIGNvbnN0IHNvbWFGb3JtYXMgPSB1cGRhdGVkLmZvcm1hc1BhZ2FtZW50by5yZWR1Y2UoKGFjYywgZm9ybWEpID0+IGFjYyArIGZvcm1hLnZhbG9yLCAwKTtcbiAgICAgIHVwZGF0ZWQudmFsb3JSZXN0YW50ZSA9IHVwZGF0ZWQudmFsb3JOZWdvY2lhZG8gLSBzb21hRm9ybWFzO1xuICAgICAgXG4gICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9KTtcbiAgfSwgW3JlZGlzdHJpYnVpclZhbG9yZXMsIGNhbGN1bGFyVmFsb3JSZWNlYmlkb0Zvcm1hXSk7XG5cbiAgY29uc3QgZWRpdGFyVmFsb3JCcnV0byA9IHVzZUNhbGxiYWNrKChub3ZvVmFsb3I6IG51bWJlcikgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdFZGl0YW5kbyB2YWxvciBicnV0byBwYXJhOicsIG5vdm9WYWxvcik7XG4gICAgcmVjYWxjdWxhclNpbXVsYWNhbyh7IHZhbG9yQnJ1dG86IG5vdm9WYWxvciB9KTtcbiAgfSwgW3JlY2FsY3VsYXJTaW11bGFjYW9dKTtcblxuICBjb25zdCBhZGljaW9uYXJGb3JtYSA9IHVzZUNhbGxiYWNrKChmb3JtYTogT21pdDxGb3JtYVBhZ2FtZW50bywgJ2lkJyB8ICd2YWxvclJlY2ViaWRvJz4pID0+IHtcbiAgICBjb25zb2xlLmxvZygnQWRpY2lvbmFuZG8gZm9ybWE6JywgZm9ybWEpO1xuICAgIFxuICAgIHNldFNpbXVsYWNhbyhwcmV2ID0+IHtcbiAgICAgIC8vIFZlcmlmaWNhciB0cmF2YW1lbnRvIGRlIGRlc2NvbnRvIHJlYWxcbiAgICAgIGlmIChwcmV2LnRyYXZhbWVudG9zLmRlc2NvbnRvUmVhbCkge1xuICAgICAgICBjb25zdCBub3ZhRm9ybWFUZW1wOiBGb3JtYVBhZ2FtZW50byA9IHtcbiAgICAgICAgICAuLi5mb3JtYSxcbiAgICAgICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLFxuICAgICAgICAgIHZhbG9yUmVjZWJpZG86IDBcbiAgICAgICAgfTtcbiAgICAgICAgbm92YUZvcm1hVGVtcC52YWxvclJlY2ViaWRvID0gY2FsY3VsYXJWYWxvclJlY2ViaWRvRm9ybWEobm92YUZvcm1hVGVtcCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBub3ZvVmFsb3JSZWNlYmlkb1RvdGFsID0gcHJldi52YWxvclJlY2ViaWRvVG90YWwgKyBub3ZhRm9ybWFUZW1wLnZhbG9yUmVjZWJpZG87XG4gICAgICAgIGNvbnN0IG5vdm9EZXNjb250b1JlYWwgPSBwcmV2LnZhbG9yQnJ1dG8gPiAwID8gKChwcmV2LnZhbG9yQnJ1dG8gLSBub3ZvVmFsb3JSZWNlYmlkb1RvdGFsKSAvIHByZXYudmFsb3JCcnV0bykgKiAxMDAgOiAwO1xuICAgICAgICBcbiAgICAgICAgaWYgKG5vdm9EZXNjb250b1JlYWwgPiBwcmV2LnRyYXZhbWVudG9zLmxpbWl0ZURlc2NvbnRvUmVhbCkge1xuICAgICAgICAgIGFsZXJ0KGBOw6NvIMOpIHBvc3PDrXZlbCBhZGljaW9uYXIgZXN0YSBmb3JtYS4gTyBkZXNjb250byByZWFsIGV4Y2VkZXJpYSBvIGxpbWl0ZSBkZSAke3ByZXYudHJhdmFtZW50b3MubGltaXRlRGVzY29udG9SZWFsfSVgKTtcbiAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBub3ZhRm9ybWE6IEZvcm1hUGFnYW1lbnRvID0ge1xuICAgICAgICAuLi5mb3JtYSxcbiAgICAgICAgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSxcbiAgICAgICAgdmFsb3JSZWNlYmlkbzogMCxcbiAgICAgICAgdHJhdmFkbzogZmFsc2VcbiAgICAgIH07XG4gICAgICBcbiAgICAgIG5vdmFGb3JtYS52YWxvclJlY2ViaWRvID0gY2FsY3VsYXJWYWxvclJlY2ViaWRvRm9ybWEobm92YUZvcm1hKTtcbiAgICAgIFxuICAgICAgY29uc3Qgbm92YXNGb3JtYXMgPSBbLi4ucHJldi5mb3JtYXNQYWdhbWVudG8sIG5vdmFGb3JtYV07XG4gICAgICBjb25zdCB1cGRhdGVkID0geyAuLi5wcmV2LCBmb3JtYXNQYWdhbWVudG86IG5vdmFzRm9ybWFzIH07XG4gICAgICBcbiAgICAgIHVwZGF0ZWQudmFsb3JSZWNlYmlkb1RvdGFsID0gbm92YXNGb3JtYXMucmVkdWNlKChhY2MsIGYpID0+IGFjYyArIGYudmFsb3JSZWNlYmlkbywgMCk7XG4gICAgICB1cGRhdGVkLmRlc2NvbnRvUmVhbCA9IHVwZGF0ZWQudmFsb3JCcnV0byA+IDAgPyAoKHVwZGF0ZWQudmFsb3JCcnV0byAtIHVwZGF0ZWQudmFsb3JSZWNlYmlkb1RvdGFsKSAvIHVwZGF0ZWQudmFsb3JCcnV0bykgKiAxMDAgOiAwO1xuICAgICAgXG4gICAgICBjb25zdCBzb21hRm9ybWFzID0gbm92YXNGb3JtYXMucmVkdWNlKChhY2MsIGYpID0+IGFjYyArIGYudmFsb3IsIDApO1xuICAgICAgdXBkYXRlZC52YWxvclJlc3RhbnRlID0gdXBkYXRlZC52YWxvck5lZ29jaWFkbyAtIHNvbWFGb3JtYXM7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdOb3ZhIHNpbXVsYcOnw6NvIGNvbSBmb3JtYSBhZGljaW9uYWRhOicsIHVwZGF0ZWQpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfSk7XG4gIH0sIFtjYWxjdWxhclZhbG9yUmVjZWJpZG9Gb3JtYV0pO1xuXG4gIGNvbnN0IGF0dWFsaXphckZvcm1hID0gdXNlQ2FsbGJhY2soKGlkOiBzdHJpbmcsIGRhZG9zQXR1YWxpemFkb3M6IE9taXQ8Rm9ybWFQYWdhbWVudG8sICdpZCcgfCAndmFsb3JSZWNlYmlkbyc+KSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0F0dWFsaXphbmRvIGZvcm1hOicsIGlkLCBkYWRvc0F0dWFsaXphZG9zKTtcbiAgICBcbiAgICBzZXRTaW11bGFjYW8ocHJldiA9PiB7XG4gICAgICBjb25zdCBub3Zhc0Zvcm1hcyA9IHByZXYuZm9ybWFzUGFnYW1lbnRvLm1hcChmb3JtYSA9PiB7XG4gICAgICAgIGlmIChmb3JtYS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAvLyBTZSBhIGZvcm1hIGVzdMOhIHRyYXZhZGEsIG7Do28gcGVybWl0ZSBhbHRlcmFyIG8gdmFsb3JcbiAgICAgICAgICBpZiAoZm9ybWEudHJhdmFkbyAmJiBkYWRvc0F0dWFsaXphZG9zLnZhbG9yICE9PSBmb3JtYS52YWxvcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0Zvcm1hIHRyYXZhZGEsIG7Do28gw6kgcG9zc8OtdmVsIGFsdGVyYXIgbyB2YWxvcicpO1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBmb3JtYUF0dWFsaXphZGEgPSB7IC4uLmZvcm1hLCAuLi5kYWRvc0F0dWFsaXphZG9zIH07XG4gICAgICAgICAgZm9ybWFBdHVhbGl6YWRhLnZhbG9yUmVjZWJpZG8gPSBjYWxjdWxhclZhbG9yUmVjZWJpZG9Gb3JtYShmb3JtYUF0dWFsaXphZGEpO1xuICAgICAgICAgIHJldHVybiBmb3JtYUF0dWFsaXphZGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHVwZGF0ZWQgPSB7IC4uLnByZXYsIGZvcm1hc1BhZ2FtZW50bzogbm92YXNGb3JtYXMgfTtcbiAgICAgIFxuICAgICAgdXBkYXRlZC52YWxvclJlY2ViaWRvVG90YWwgPSBub3Zhc0Zvcm1hcy5yZWR1Y2UoKGFjYywgZikgPT4gYWNjICsgZi52YWxvclJlY2ViaWRvLCAwKTtcbiAgICAgIHVwZGF0ZWQuZGVzY29udG9SZWFsID0gdXBkYXRlZC52YWxvckJydXRvID4gMCA/ICgodXBkYXRlZC52YWxvckJydXRvIC0gdXBkYXRlZC52YWxvclJlY2ViaWRvVG90YWwpIC8gdXBkYXRlZC52YWxvckJydXRvKSAqIDEwMCA6IDA7XG4gICAgICBcbiAgICAgIGNvbnN0IHNvbWFGb3JtYXMgPSBub3Zhc0Zvcm1hcy5yZWR1Y2UoKGFjYywgZikgPT4gYWNjICsgZi52YWxvciwgMCk7XG4gICAgICB1cGRhdGVkLnZhbG9yUmVzdGFudGUgPSB1cGRhdGVkLnZhbG9yTmVnb2NpYWRvIC0gc29tYUZvcm1hcztcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1NpbXVsYcOnw6NvIGF0dWFsaXphZGEgYXDDs3MgZWRpw6fDo286JywgdXBkYXRlZCk7XG4gICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9KTtcbiAgfSwgW2NhbGN1bGFyVmFsb3JSZWNlYmlkb0Zvcm1hXSk7XG5cbiAgY29uc3QgcmVtb3ZlckZvcm1hID0gdXNlQ2FsbGJhY2soKGlkOiBzdHJpbmcpID0+IHtcbiAgICBjb25zb2xlLmxvZygnUmVtb3ZlbmRvIGZvcm1hOicsIGlkKTtcbiAgICBcbiAgICBzZXRTaW11bGFjYW8ocHJldiA9PiB7XG4gICAgICBjb25zdCBub3Zhc0Zvcm1hcyA9IHByZXYuZm9ybWFzUGFnYW1lbnRvLmZpbHRlcihmID0+IGYuaWQgIT09IGlkKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIGZvcm1hc1BhZ2FtZW50bzogbm92YXNGb3JtYXMsXG4gICAgICAgIHZhbG9yUmVjZWJpZG9Ub3RhbDogbm92YXNGb3JtYXMucmVkdWNlKChhY2MsIGYpID0+IGFjYyArIGYudmFsb3JSZWNlYmlkbywgMCksXG4gICAgICAgIGRlc2NvbnRvUmVhbDogcHJldi52YWxvckJydXRvID4gMCA/ICgocHJldi52YWxvckJydXRvIC0gbm92YXNGb3JtYXMucmVkdWNlKChhY2MsIGYpID0+IGFjYyArIGYudmFsb3JSZWNlYmlkbywgMCkpIC8gcHJldi52YWxvckJydXRvKSAqIDEwMCA6IDAsXG4gICAgICAgIHZhbG9yUmVzdGFudGU6IHByZXYudmFsb3JOZWdvY2lhZG8gLSBub3Zhc0Zvcm1hcy5yZWR1Y2UoKGFjYywgZikgPT4gYWNjICsgZi52YWxvciwgMClcbiAgICAgIH07XG4gICAgfSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBsaW1wYXJGb3JtYXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0xpbXBhbmRvIHRvZGFzIGFzIGZvcm1hcycpO1xuICAgIHNldFNpbXVsYWNhbyhwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgZm9ybWFzUGFnYW1lbnRvOiBbXSxcbiAgICAgIHZhbG9yUmVjZWJpZG9Ub3RhbDogMCxcbiAgICAgIGRlc2NvbnRvUmVhbDogcHJldi52YWxvckJydXRvID4gMCA/IDEwMCA6IDAsXG4gICAgICB2YWxvclJlc3RhbnRlOiBwcmV2LnZhbG9yTmVnb2NpYWRvXG4gICAgfSkpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgYWx0ZXJuYXJUcmF2YW1lbnRvID0gdXNlQ2FsbGJhY2soKHRpcG86IGtleW9mIFRyYXZhbWVudG9Db25maWcsIHZhbG9yPzogbnVtYmVyKSA9PiB7XG4gICAgc2V0U2ltdWxhY2FvKHByZXYgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICB0cmF2YW1lbnRvczoge1xuICAgICAgICAuLi5wcmV2LnRyYXZhbWVudG9zLFxuICAgICAgICBbdGlwb106ICFwcmV2LnRyYXZhbWVudG9zW3RpcG9dLFxuICAgICAgICAuLi4odmFsb3IgIT09IHVuZGVmaW5lZCAmJiB7IGxpbWl0ZURlc2NvbnRvUmVhbDogdmFsb3IgfSlcbiAgICAgIH1cbiAgICB9KSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBhbHRlcm5hclRyYXZhbWVudG9Gb3JtYSA9IHVzZUNhbGxiYWNrKChpZDogc3RyaW5nKSA9PiB7XG4gICAgc2V0U2ltdWxhY2FvKHByZXYgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICBmb3JtYXNQYWdhbWVudG86IHByZXYuZm9ybWFzUGFnYW1lbnRvLm1hcChmb3JtYSA9PiBcbiAgICAgICAgZm9ybWEuaWQgPT09IGlkID8geyAuLi5mb3JtYSwgdHJhdmFkbzogIWZvcm1hLnRyYXZhZG8gfSA6IGZvcm1hXG4gICAgICApXG4gICAgfSkpO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIHtcbiAgICBzaW11bGFjYW8sXG4gICAgcmVjYWxjdWxhclNpbXVsYWNhbyxcbiAgICBhZGljaW9uYXJGb3JtYSxcbiAgICBhdHVhbGl6YXJGb3JtYSxcbiAgICByZW1vdmVyRm9ybWEsXG4gICAgbGltcGFyRm9ybWFzLFxuICAgIGFsdGVybmFyVHJhdmFtZW50byxcbiAgICBhbHRlcm5hclRyYXZhbWVudG9Gb3JtYSxcbiAgICBlZGl0YXJWYWxvck5lZ29jaWFkbyxcbiAgICBlZGl0YXJWYWxvckJydXRvLFxuICAgIGVkaXRhckRlc2NvbnRvUmVhbFxuICB9O1xufTtcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlU2ltdWxhZG9yIiwic2ltdWxhY2FvIiwic2V0U2ltdWxhY2FvIiwidmFsb3JCcnV0byIsImRlc2NvbnRvIiwidmFsb3JOZWdvY2lhZG8iLCJmb3JtYXNQYWdhbWVudG8iLCJ2YWxvclJlY2ViaWRvVG90YWwiLCJkZXNjb250b1JlYWwiLCJ2YWxvclJlc3RhbnRlIiwidHJhdmFtZW50b3MiLCJsaW1pdGVEZXNjb250b1JlYWwiLCJQUklPUklEQURFX0ZPUk1BUyIsImNhbGN1bGFyVmFsb3JSZWNlYmlkb0Zvcm1hIiwiZm9ybWEiLCJjb25zb2xlIiwibG9nIiwidGlwbyIsInZhbG9yIiwicGFyY2VsYXMiLCJ0YXhhSnVyb3MiLCJpIiwidmFsb3JQcmVzZW50ZSIsIk1hdGgiLCJwb3ciLCJkZWZsYWNhbyIsImp1cm9zQW50ZWNpcGFjYW8iLCJmYXRvckRlZmxhY2FvIiwiZmF0b3JKdXJvcyIsInZhbG9yUmVjZWJpZG8iLCJjdXN0b0NhcGl0YWwiLCJpYyIsInZhbG9yUHJlc2VudGVCb2xldG8iLCJyZWRpc3RyaWJ1aXJWYWxvcmVzIiwibm92b1ZhbG9yTmVnb2NpYWRvIiwiZm9ybWFzQXR1YWlzIiwic29tYUF0dWFsIiwicmVkdWNlIiwiYWNjIiwiZGlmZXJlbmNhIiwiYWJzIiwiZm9ybWFzVHJhdmFkYXMiLCJmaWx0ZXIiLCJ0cmF2YWRvIiwiZm9ybWFzTmFvVHJhdmFkYXMiLCJsZW5ndGgiLCJmb3JtYXNPcmRlbmFkYXMiLCJzb3J0IiwiYSIsImIiLCJwcmlvcmlkYWRlQSIsImluZGV4T2YiLCJwcmlvcmlkYWRlQiIsIm1hcCIsImYiLCJub3Zhc0Zvcm1hcyIsInNvbWFGb3JtYXNOYW9UcmF2YWRhcyIsImFqdXN0ZVBvckZvcm1hIiwiZm9yRWFjaCIsImZvcm1hSW5kZXgiLCJmaW5kSW5kZXgiLCJpZCIsIm5vdm9WYWxvciIsIm1heCIsInByaW1laXJhRm9ybWEiLCJyZWNhbGN1bGFyU2ltdWxhY2FvIiwidXBkYXRlcyIsInByZXYiLCJ1cGRhdGVkIiwidW5kZWZpbmVkIiwic29tYUZvcm1hcyIsImVkaXRhclZhbG9yTmVnb2NpYWRvIiwiZm9ybWFzUmVkaXN0cmlidWlkYXMiLCJhbGVydCIsImVkaXRhckRlc2NvbnRvUmVhbCIsIm5vdm9EZXNjb250byIsImVkaXRhclZhbG9yQnJ1dG8iLCJhZGljaW9uYXJGb3JtYSIsIm5vdmFGb3JtYVRlbXAiLCJEYXRlIiwibm93IiwidG9TdHJpbmciLCJub3ZvVmFsb3JSZWNlYmlkb1RvdGFsIiwibm92b0Rlc2NvbnRvUmVhbCIsIm5vdmFGb3JtYSIsImF0dWFsaXphckZvcm1hIiwiZGFkb3NBdHVhbGl6YWRvcyIsImZvcm1hQXR1YWxpemFkYSIsInJlbW92ZXJGb3JtYSIsImxpbXBhckZvcm1hcyIsImFsdGVybmFyVHJhdmFtZW50byIsImFsdGVybmFyVHJhdmFtZW50b0Zvcm1hIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useSimulador.ts\n"));

/***/ })

});