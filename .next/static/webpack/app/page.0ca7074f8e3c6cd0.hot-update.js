"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useSimulador.ts":
/*!***********************************!*\
  !*** ./src/hooks/useSimulador.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSimulador: () => (/* binding */ useSimulador)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst useSimulador = ()=>{\n    const [simulacao, setSimulacao] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        valorBruto: 0,\n        desconto: 0,\n        valorNegociado: 0,\n        formasPagamento: [],\n        valorRecebidoTotal: 0,\n        descontoReal: 0,\n        valorRestante: 0,\n        travamentos: {\n            valorNegociado: false,\n            descontoReal: false,\n            limiteDescontoReal: 25\n        }\n    });\n    // Prioridade para redistribuição de valores\n    const PRIORIDADE_FORMAS = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useSimulador.useMemo[PRIORIDADE_FORMAS]\": ()=>[\n                'ENTRADA',\n                'BOLETO',\n                'FINANCEIRA',\n                'CARTAO'\n            ]\n    }[\"useSimulador.useMemo[PRIORIDADE_FORMAS]\"], []);\n    const calcularValorRecebidoForma = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[calcularValorRecebidoForma]\": (forma)=>{\n            console.log('Calculando valor recebido para:', forma);\n            switch(forma.tipo){\n                case 'ENTRADA':\n                    return forma.valor;\n                case 'FINANCEIRA':\n                    {\n                        if (!forma.parcelas || !forma.taxaJuros) return forma.valor;\n                        const i = forma.taxaJuros / 100;\n                        const parcelas = forma.parcelas;\n                        const valorPresente = forma.valor / Math.pow(1 + i, parcelas);\n                        console.log(\"Financeira: valor=\".concat(forma.valor, \", parcelas=\").concat(parcelas, \", taxa=\").concat(forma.taxaJuros, \"%, VP=\").concat(valorPresente));\n                        return valorPresente;\n                    }\n                case 'CARTAO':\n                    {\n                        if (!forma.deflacao || !forma.jurosAntecipacao || !forma.parcelas) return forma.valor;\n                        const fatorDeflacao = 1 - forma.deflacao / 100;\n                        const fatorJuros = 1 - forma.jurosAntecipacao / 100 * forma.parcelas;\n                        const valorRecebido = forma.valor * fatorDeflacao * fatorJuros;\n                        console.log(\"Cart\\xe3o: valor=\".concat(forma.valor, \", defla\\xe7\\xe3o=\").concat(forma.deflacao, \"%, juros=\").concat(forma.jurosAntecipacao, \"%, VR=\").concat(valorRecebido));\n                        return valorRecebido;\n                    }\n                case 'BOLETO':\n                    {\n                        if (!forma.parcelas || !forma.custoCapital) return forma.valor;\n                        const ic = forma.custoCapital / 100;\n                        const valorPresenteBoleto = forma.valor / Math.pow(1 + ic, forma.parcelas);\n                        console.log(\"Boleto: valor=\".concat(forma.valor, \", parcelas=\").concat(forma.parcelas, \", custo=\").concat(forma.custoCapital, \"%, VP=\").concat(valorPresenteBoleto));\n                        return valorPresenteBoleto;\n                    }\n                default:\n                    return forma.valor;\n            }\n        }\n    }[\"useSimulador.useCallback[calcularValorRecebidoForma]\"], []);\n    const redistribuirValores = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[redistribuirValores]\": (novoValorNegociado, formasAtuais)=>{\n            console.log('Redistribuindo valores. Novo valor negociado:', novoValorNegociado);\n            const somaAtual = formasAtuais.reduce({\n                \"useSimulador.useCallback[redistribuirValores].somaAtual\": (acc, forma)=>acc + forma.valor\n            }[\"useSimulador.useCallback[redistribuirValores].somaAtual\"], 0);\n            const diferenca = novoValorNegociado - somaAtual;\n            if (Math.abs(diferenca) < 0.01) {\n                return formasAtuais; // Não há diferença significativa\n            }\n            console.log('Diferença a redistribuir:', diferenca);\n            // Separar formas travadas e não travadas\n            const formasTravadas = formasAtuais.filter({\n                \"useSimulador.useCallback[redistribuirValores].formasTravadas\": (forma)=>forma.travado\n            }[\"useSimulador.useCallback[redistribuirValores].formasTravadas\"]);\n            const formasNaoTravadas = formasAtuais.filter({\n                \"useSimulador.useCallback[redistribuirValores].formasNaoTravadas\": (forma)=>!forma.travado\n            }[\"useSimulador.useCallback[redistribuirValores].formasNaoTravadas\"]);\n            // Se todas estão travadas, não podemos redistribuir\n            if (formasNaoTravadas.length === 0) {\n                console.log('Todas as formas estão travadas');\n                return null; // Indica erro\n            }\n            // Ordenar formas não travadas por prioridade\n            const formasOrdenadas = formasNaoTravadas.sort({\n                \"useSimulador.useCallback[redistribuirValores].formasOrdenadas\": (a, b)=>{\n                    const prioridadeA = PRIORIDADE_FORMAS.indexOf(a.tipo);\n                    const prioridadeB = PRIORIDADE_FORMAS.indexOf(b.tipo);\n                    return prioridadeA - prioridadeB;\n                }\n            }[\"useSimulador.useCallback[redistribuirValores].formasOrdenadas\"]);\n            console.log('Formas ordenadas por prioridade:', formasOrdenadas.map({\n                \"useSimulador.useCallback[redistribuirValores]\": (f)=>f.tipo\n            }[\"useSimulador.useCallback[redistribuirValores]\"]));\n            // Redistribuir a diferença: apenas a primeira forma na ordem de prioridade absorve toda a diferença\n            const novasFormas = [\n                ...formasAtuais\n            ];\n            // Verificar se todas as formas não travadas têm valor zero\n            const somaFormasNaoTravadas = formasOrdenadas.reduce({\n                \"useSimulador.useCallback[redistribuirValores].somaFormasNaoTravadas\": (acc, forma)=>acc + forma.valor\n            }[\"useSimulador.useCallback[redistribuirValores].somaFormasNaoTravadas\"], 0);\n            if (somaFormasNaoTravadas === 0) {\n                // Se todas as formas não travadas têm valor 0, distribui igualmente\n                console.log('Todas as formas não travadas têm valor zero, distribuindo igualmente');\n                const ajustePorForma = diferenca / formasOrdenadas.length;\n                formasOrdenadas.forEach({\n                    \"useSimulador.useCallback[redistribuirValores]\": (forma)=>{\n                        const formaIndex = novasFormas.findIndex({\n                            \"useSimulador.useCallback[redistribuirValores].formaIndex\": (f)=>f.id === forma.id\n                        }[\"useSimulador.useCallback[redistribuirValores].formaIndex\"]);\n                        const novoValor = ajustePorForma;\n                        novasFormas[formaIndex] = {\n                            ...novasFormas[formaIndex],\n                            valor: Math.max(0, novoValor)\n                        };\n                        console.log(\"Forma \".concat(forma.tipo, \" ajustada para: \").concat(novoValor, \" (final: \").concat(Math.max(0, novoValor), \")\"));\n                    }\n                }[\"useSimulador.useCallback[redistribuirValores]\"]);\n            } else {\n                // Apenas a primeira forma não travada na ordem de prioridade absorve toda a diferença\n                console.log('Ajustando apenas a primeira forma na ordem de prioridade');\n                const primeiraForma = formasOrdenadas[0];\n                const formaIndex = novasFormas.findIndex({\n                    \"useSimulador.useCallback[redistribuirValores].formaIndex\": (f)=>f.id === primeiraForma.id\n                }[\"useSimulador.useCallback[redistribuirValores].formaIndex\"]);\n                const valorCalculado = primeiraForma.valor + diferenca;\n                const novoValor = Math.max(0, valorCalculado);\n                novasFormas[formaIndex] = {\n                    ...novasFormas[formaIndex],\n                    valor: novoValor\n                };\n                console.log(\"Forma \".concat(primeiraForma.tipo, \" ajustada de \").concat(primeiraForma.valor, \" para \").concat(valorCalculado, \" (final: \").concat(novoValor, \")\"));\n                // Se o valor ficou negativo, indicar impossibilidade\n                if (valorCalculado < 0) {\n                    console.log(\"⚠️ Valor negativo detectado (\".concat(valorCalculado, \"), pode estar no limite de desconto real\"));\n                }\n            }\n            return novasFormas;\n        }\n    }[\"useSimulador.useCallback[redistribuirValores]\"], [\n        PRIORIDADE_FORMAS\n    ]);\n    const recalcularSimulacao = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[recalcularSimulacao]\": (updates)=>{\n            console.log('Recalculando simulação com updates:', updates);\n            setSimulacao({\n                \"useSimulador.useCallback[recalcularSimulacao]\": (prev)=>{\n                    const updated = {\n                        ...prev,\n                        ...updates\n                    };\n                    // Verificar se o desconto real está travado\n                    if (updated.travamentos.descontoRealFixo) {\n                        const descontoRealFixo = updated.travamentos.valorDescontoRealFixo;\n                        console.log(\"Desconto real travado em \".concat(descontoRealFixo, \"%, ajustando valor negociado\"));\n                        // Calcular o valor recebido necessário para manter o desconto fixo\n                        const valorRecebidoNecessario = updated.valorBruto * (1 - descontoRealFixo / 100);\n                        // Encontrar o valor negociado que resulte nesse valor recebido\n                        // ... implementar lógica de busca reversa\n                        return updated;\n                    }\n                    // Lógica de travamento do valor negociado\n                    if (updated.travamentos.valorNegociado) {\n                        // Se valor negociado está travado, ajusta o desconto quando valor bruto muda\n                        if (updates.valorBruto !== undefined && updates.valorBruto > 0) {\n                            updated.desconto = (updated.valorBruto - updated.valorNegociado) / updated.valorBruto * 100;\n                        }\n                    } else {\n                        // Comportamento normal: calcula valor negociado baseado no desconto\n                        updated.valorNegociado = updated.valorBruto * (1 - updated.desconto / 100);\n                    }\n                    updated.formasPagamento = updated.formasPagamento.map({\n                        \"useSimulador.useCallback[recalcularSimulacao]\": (forma)=>({\n                                ...forma,\n                                valorRecebido: calcularValorRecebidoForma(forma)\n                            })\n                    }[\"useSimulador.useCallback[recalcularSimulacao]\"]);\n                    updated.valorRecebidoTotal = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[recalcularSimulacao]\": (acc, forma)=>acc + forma.valorRecebido\n                    }[\"useSimulador.useCallback[recalcularSimulacao]\"], 0);\n                    updated.descontoReal = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorRecebidoTotal) / updated.valorBruto * 100 : 0;\n                    const somaFormas = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[recalcularSimulacao].somaFormas\": (acc, forma)=>acc + forma.valor\n                    }[\"useSimulador.useCallback[recalcularSimulacao].somaFormas\"], 0);\n                    updated.valorRestante = updated.valorNegociado - somaFormas;\n                    console.log('Simulação atualizada:', updated);\n                    return updated;\n                }\n            }[\"useSimulador.useCallback[recalcularSimulacao]\"]);\n        }\n    }[\"useSimulador.useCallback[recalcularSimulacao]\"], [\n        calcularValorRecebidoForma\n    ]);\n    const editarValorNegociado = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[editarValorNegociado]\": (novoValor)=>{\n            console.log('Editando valor negociado para:', novoValor);\n            setSimulacao({\n                \"useSimulador.useCallback[editarValorNegociado]\": (prev)=>{\n                    const formasRedistribuidas = redistribuirValores(novoValor, prev.formasPagamento);\n                    if (!formasRedistribuidas) {\n                        alert('Não é possível alterar o valor. Todas as formas de pagamento estão travadas.');\n                        return prev;\n                    }\n                    const updated = {\n                        ...prev,\n                        valorNegociado: novoValor,\n                        formasPagamento: formasRedistribuidas.map({\n                            \"useSimulador.useCallback[editarValorNegociado]\": (forma)=>({\n                                    ...forma,\n                                    valorRecebido: calcularValorRecebidoForma(forma)\n                                })\n                        }[\"useSimulador.useCallback[editarValorNegociado]\"])\n                    };\n                    // Recalcular desconto\n                    updated.desconto = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorNegociado) / updated.valorBruto * 100 : 0;\n                    updated.valorRecebidoTotal = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[editarValorNegociado]\": (acc, forma)=>acc + forma.valorRecebido\n                    }[\"useSimulador.useCallback[editarValorNegociado]\"], 0);\n                    updated.descontoReal = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorRecebidoTotal) / updated.valorBruto * 100 : 0;\n                    const somaFormas = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[editarValorNegociado].somaFormas\": (acc, forma)=>acc + forma.valor\n                    }[\"useSimulador.useCallback[editarValorNegociado].somaFormas\"], 0);\n                    updated.valorRestante = updated.valorNegociado - somaFormas;\n                    return updated;\n                }\n            }[\"useSimulador.useCallback[editarValorNegociado]\"]);\n        }\n    }[\"useSimulador.useCallback[editarValorNegociado]\"], [\n        redistribuirValores,\n        calcularValorRecebidoForma\n    ]);\n    const editarDescontoReal = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[editarDescontoReal]\": (novoDescontoReal, shouldLock)=>{\n            console.log('Editando desconto real para:', novoDescontoReal, 'Travar:', shouldLock);\n            setSimulacao({\n                \"useSimulador.useCallback[editarDescontoReal]\": (prev)=>{\n                    // Se shouldLock é verdadeiro, ativar o travamento\n                    if (shouldLock) {\n                        return {\n                            ...prev,\n                            travamentos: {\n                                ...prev.travamentos,\n                                descontoRealFixo: true,\n                                valorDescontoRealFixo: novoDescontoReal\n                            }\n                        };\n                    }\n                    // Lógica existente da busca binária...\n                    const calcularDescontoRealParaValor = {\n                        \"useSimulador.useCallback[editarDescontoReal].calcularDescontoRealParaValor\": (valorNegociado)=>{\n                            const formasTemp = redistribuirValores(valorNegociado, prev.formasPagamento);\n                            if (!formasTemp) return -1;\n                            const valorRecebidoTemp = formasTemp.reduce({\n                                \"useSimulador.useCallback[editarDescontoReal].calcularDescontoRealParaValor.valorRecebidoTemp\": (acc, forma)=>{\n                                    const formaComRecebido = {\n                                        ...forma,\n                                        valorRecebido: calcularValorRecebidoForma(forma)\n                                    };\n                                    return acc + formaComRecebido.valorRecebido;\n                                }\n                            }[\"useSimulador.useCallback[editarDescontoReal].calcularDescontoRealParaValor.valorRecebidoTemp\"], 0);\n                            return prev.valorBruto > 0 ? (prev.valorBruto - valorRecebidoTemp) / prev.valorBruto * 100 : 0;\n                        }\n                    }[\"useSimulador.useCallback[editarDescontoReal].calcularDescontoRealParaValor\"];\n                    // Busca binária para encontrar o valor negociado que resulta no desconto real desejado\n                    let valorMin = 0;\n                    let valorMax = prev.valorBruto;\n                    let valorNegociadoOtimo = prev.valorNegociado;\n                    let melhorDiferenca = Infinity;\n                    let melhorDesconto = prev.descontoReal;\n                    console.log(\"\\uD83C\\uDFAF Iniciando busca bin\\xe1ria para desconto real: \".concat(novoDescontoReal, \"%\"));\n                    console.log(\"Desconto real atual: \".concat(prev.descontoReal, \"%\"));\n                    console.log(\"Intervalo inicial: \".concat(valorMin, \" - \").concat(valorMax));\n                    // Máximo de 25 iterações para maior precisão\n                    for(let i = 0; i < 25; i++){\n                        const valorTeste = (valorMin + valorMax) / 2;\n                        const descontoRealCalculado = calcularDescontoRealParaValor(valorTeste);\n                        console.log(\"Itera\\xe7\\xe3o \".concat(i + 1, \": valorTeste=\").concat(valorTeste.toFixed(2), \", desconto=\").concat(descontoRealCalculado.toFixed(2), \"%\"));\n                        if (descontoRealCalculado === -1) {\n                            // Erro na redistribuição, tentar valor maior\n                            console.log('❌ Erro na redistribuição, ajustando valor mínimo');\n                            valorMin = valorTeste;\n                            continue;\n                        }\n                        const diferenca = Math.abs(descontoRealCalculado - novoDescontoReal);\n                        // Se encontrou um resultado melhor, guardar\n                        if (diferenca < melhorDiferenca) {\n                            melhorDiferenca = diferenca;\n                            valorNegociadoOtimo = valorTeste;\n                            melhorDesconto = descontoRealCalculado;\n                            console.log(\"✅ Novo melhor resultado: desconto=\".concat(melhorDesconto.toFixed(2), \"%, diferen\\xe7a=\").concat(melhorDiferenca.toFixed(2)));\n                        }\n                        // Se a diferença é muito pequena, parar\n                        if (diferenca < 0.05) {\n                            console.log(\"\\uD83C\\uDFAF Precis\\xe3o atingida! Parando busca.\");\n                            break;\n                        }\n                        // Detectar se estamos no limite físico\n                        if (i > 10 && melhorDiferenca > 2) {\n                            console.log(\"⚠️ Poss\\xedvel limite f\\xedsico detectado. Melhor desconto poss\\xedvel: \".concat(melhorDesconto.toFixed(2), \"%\"));\n                            break;\n                        }\n                        // Ajustar os limites da busca\n                        if (descontoRealCalculado < novoDescontoReal) {\n                            // Desconto calculado é menor que o desejado, precisamos diminuir valor negociado\n                            valorMax = valorTeste;\n                            console.log(\"\\uD83D\\uDCC9 Desconto baixo (\".concat(descontoRealCalculado.toFixed(2), \"% < \").concat(novoDescontoReal, \"%), diminuindo valorMax para \").concat(valorMax.toFixed(2)));\n                        } else {\n                            // Desconto calculado é maior que o desejado, precisamos aumentar valor negociado\n                            valorMin = valorTeste;\n                            console.log(\"\\uD83D\\uDCC8 Desconto alto (\".concat(descontoRealCalculado.toFixed(2), \"% > \").concat(novoDescontoReal, \"%), aumentando valorMin para \").concat(valorMin.toFixed(2)));\n                        }\n                        // Verificar se o intervalo ficou muito pequeno\n                        if (Math.abs(valorMax - valorMin) < 100) {\n                            console.log(\"\\uD83D\\uDD0D Intervalo muito pequeno (\".concat(Math.abs(valorMax - valorMin).toFixed(2), \"), finalizando busca\"));\n                            break;\n                        }\n                    }\n                    console.log(\"\\uD83C\\uDFC1 Busca finalizada:\");\n                    console.log(\"   Valor negociado \\xf3timo: \".concat(valorNegociadoOtimo.toFixed(2)));\n                    console.log(\"   Desconto real resultante: \".concat(melhorDesconto.toFixed(2), \"%\"));\n                    console.log(\"   Diferen\\xe7a do objetivo: \".concat(melhorDiferenca.toFixed(2)));\n                    // Se a diferença ainda é muito grande, avisar o usuário\n                    if (melhorDiferenca > 1) {\n                        console.log(\"⚠️ N\\xe3o foi poss\\xedvel atingir exatamente \".concat(novoDescontoReal, \"%. Melhor resultado: \").concat(melhorDesconto.toFixed(1), \"%\"));\n                        const confirmar = confirm(\"N\\xe3o foi poss\\xedvel atingir exatamente \".concat(novoDescontoReal, \"% de desconto real.\\nMelhor resultado poss\\xedvel: \").concat(melhorDesconto.toFixed(1), \"%\\n\\nDeseja aplicar mesmo assim?\"));\n                        if (!confirmar) {\n                            return prev;\n                        }\n                    }\n                    // Aplicar o valor negociado ótimo encontrado\n                    const formasRedistribuidas = redistribuirValores(valorNegociadoOtimo, prev.formasPagamento);\n                    if (!formasRedistribuidas) {\n                        alert('Não é possível alterar o desconto real. Todas as formas de pagamento estão travadas.');\n                        return prev;\n                    }\n                    // No final, atualizar o travamento se necessário\n                    const updated = {\n                        ...prev,\n                        valorNegociado: valorNegociadoOtimo,\n                        formasPagamento: formasRedistribuidas.map({\n                            \"useSimulador.useCallback[editarDescontoReal]\": (forma)=>({\n                                    ...forma,\n                                    valorRecebido: calcularValorRecebidoForma(forma)\n                                })\n                        }[\"useSimulador.useCallback[editarDescontoReal]\"]),\n                        travamentos: {\n                            ...prev.travamentos,\n                            descontoRealFixo: shouldLock || false,\n                            valorDescontoRealFixo: shouldLock ? novoDescontoReal : prev.travamentos.valorDescontoRealFixo\n                        }\n                    };\n                    // Recalcular valores derivados\n                    updated.valorRecebidoTotal = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[editarDescontoReal]\": (acc, forma)=>acc + forma.valorRecebido\n                    }[\"useSimulador.useCallback[editarDescontoReal]\"], 0);\n                    updated.descontoReal = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorRecebidoTotal) / updated.valorBruto * 100 : 0;\n                    const somaFormas = updated.formasPagamento.reduce({\n                        \"useSimulador.useCallback[editarDescontoReal].somaFormas\": (acc, forma)=>acc + forma.valor\n                    }[\"useSimulador.useCallback[editarDescontoReal].somaFormas\"], 0);\n                    updated.valorRestante = updated.valorNegociado - somaFormas;\n                    console.log('Simulação atualizada via desconto real:', updated);\n                    console.log(\"Desconto real resultante: \".concat(updated.descontoReal, \"%\"));\n                    return updated;\n                }\n            }[\"useSimulador.useCallback[editarDescontoReal]\"]);\n        }\n    }[\"useSimulador.useCallback[editarDescontoReal]\"], [\n        redistribuirValores,\n        calcularValorRecebidoForma\n    ]);\n    const editarValorBruto = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[editarValorBruto]\": (novoValor)=>{\n            console.log('Editando valor bruto para:', novoValor);\n            recalcularSimulacao({\n                valorBruto: novoValor\n            });\n        }\n    }[\"useSimulador.useCallback[editarValorBruto]\"], [\n        recalcularSimulacao\n    ]);\n    const adicionarForma = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[adicionarForma]\": (forma)=>{\n            console.log('Adicionando forma:', forma);\n            setSimulacao({\n                \"useSimulador.useCallback[adicionarForma]\": (prev)=>{\n                    // Verificar travamento de desconto real\n                    if (prev.travamentos.descontoReal) {\n                        const novaFormaTemp = {\n                            ...forma,\n                            id: Date.now().toString(),\n                            valorRecebido: 0\n                        };\n                        novaFormaTemp.valorRecebido = calcularValorRecebidoForma(novaFormaTemp);\n                        const novoValorRecebidoTotal = prev.valorRecebidoTotal + novaFormaTemp.valorRecebido;\n                        const novoDescontoReal = prev.valorBruto > 0 ? (prev.valorBruto - novoValorRecebidoTotal) / prev.valorBruto * 100 : 0;\n                        if (novoDescontoReal > prev.travamentos.limiteDescontoReal) {\n                            alert(\"N\\xe3o \\xe9 poss\\xedvel adicionar esta forma. O desconto real excederia o limite de \".concat(prev.travamentos.limiteDescontoReal, \"%\"));\n                            return prev;\n                        }\n                    }\n                    const novaForma = {\n                        ...forma,\n                        id: Date.now().toString(),\n                        valorRecebido: 0,\n                        travado: false\n                    };\n                    novaForma.valorRecebido = calcularValorRecebidoForma(novaForma);\n                    const novasFormas = [\n                        ...prev.formasPagamento,\n                        novaForma\n                    ];\n                    const updated = {\n                        ...prev,\n                        formasPagamento: novasFormas\n                    };\n                    updated.valorRecebidoTotal = novasFormas.reduce({\n                        \"useSimulador.useCallback[adicionarForma]\": (acc, f)=>acc + f.valorRecebido\n                    }[\"useSimulador.useCallback[adicionarForma]\"], 0);\n                    updated.descontoReal = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorRecebidoTotal) / updated.valorBruto * 100 : 0;\n                    const somaFormas = novasFormas.reduce({\n                        \"useSimulador.useCallback[adicionarForma].somaFormas\": (acc, f)=>acc + f.valor\n                    }[\"useSimulador.useCallback[adicionarForma].somaFormas\"], 0);\n                    updated.valorRestante = updated.valorNegociado - somaFormas;\n                    console.log('Nova simulação com forma adicionada:', updated);\n                    return updated;\n                }\n            }[\"useSimulador.useCallback[adicionarForma]\"]);\n        }\n    }[\"useSimulador.useCallback[adicionarForma]\"], [\n        calcularValorRecebidoForma\n    ]);\n    const atualizarForma = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[atualizarForma]\": (id, dadosAtualizados)=>{\n            console.log('Atualizando forma:', id, dadosAtualizados);\n            setSimulacao({\n                \"useSimulador.useCallback[atualizarForma]\": (prev)=>{\n                    const novasFormas = prev.formasPagamento.map({\n                        \"useSimulador.useCallback[atualizarForma].novasFormas\": (forma)=>{\n                            if (forma.id === id) {\n                                // Se a forma está travada, não permite alterar o valor\n                                if (forma.travado && dadosAtualizados.valor !== forma.valor) {\n                                    console.log('Forma travada, não é possível alterar o valor');\n                                    return forma;\n                                }\n                                const formaAtualizada = {\n                                    ...forma,\n                                    ...dadosAtualizados\n                                };\n                                formaAtualizada.valorRecebido = calcularValorRecebidoForma(formaAtualizada);\n                                return formaAtualizada;\n                            }\n                            return forma;\n                        }\n                    }[\"useSimulador.useCallback[atualizarForma].novasFormas\"]);\n                    const updated = {\n                        ...prev,\n                        formasPagamento: novasFormas\n                    };\n                    updated.valorRecebidoTotal = novasFormas.reduce({\n                        \"useSimulador.useCallback[atualizarForma]\": (acc, f)=>acc + f.valorRecebido\n                    }[\"useSimulador.useCallback[atualizarForma]\"], 0);\n                    updated.descontoReal = updated.valorBruto > 0 ? (updated.valorBruto - updated.valorRecebidoTotal) / updated.valorBruto * 100 : 0;\n                    const somaFormas = novasFormas.reduce({\n                        \"useSimulador.useCallback[atualizarForma].somaFormas\": (acc, f)=>acc + f.valor\n                    }[\"useSimulador.useCallback[atualizarForma].somaFormas\"], 0);\n                    updated.valorRestante = updated.valorNegociado - somaFormas;\n                    console.log('Simulação atualizada após edição:', updated);\n                    return updated;\n                }\n            }[\"useSimulador.useCallback[atualizarForma]\"]);\n        }\n    }[\"useSimulador.useCallback[atualizarForma]\"], [\n        calcularValorRecebidoForma\n    ]);\n    const removerForma = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[removerForma]\": (id)=>{\n            console.log('Removendo forma:', id);\n            setSimulacao({\n                \"useSimulador.useCallback[removerForma]\": (prev)=>{\n                    const novasFormas = prev.formasPagamento.filter({\n                        \"useSimulador.useCallback[removerForma].novasFormas\": (f)=>f.id !== id\n                    }[\"useSimulador.useCallback[removerForma].novasFormas\"]);\n                    return {\n                        ...prev,\n                        formasPagamento: novasFormas,\n                        valorRecebidoTotal: novasFormas.reduce({\n                            \"useSimulador.useCallback[removerForma]\": (acc, f)=>acc + f.valorRecebido\n                        }[\"useSimulador.useCallback[removerForma]\"], 0),\n                        descontoReal: prev.valorBruto > 0 ? (prev.valorBruto - novasFormas.reduce({\n                            \"useSimulador.useCallback[removerForma]\": (acc, f)=>acc + f.valorRecebido\n                        }[\"useSimulador.useCallback[removerForma]\"], 0)) / prev.valorBruto * 100 : 0,\n                        valorRestante: prev.valorNegociado - novasFormas.reduce({\n                            \"useSimulador.useCallback[removerForma]\": (acc, f)=>acc + f.valor\n                        }[\"useSimulador.useCallback[removerForma]\"], 0)\n                    };\n                }\n            }[\"useSimulador.useCallback[removerForma]\"]);\n        }\n    }[\"useSimulador.useCallback[removerForma]\"], []);\n    const limparFormas = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[limparFormas]\": ()=>{\n            console.log('Limpando todas as formas');\n            setSimulacao({\n                \"useSimulador.useCallback[limparFormas]\": (prev)=>({\n                        ...prev,\n                        formasPagamento: [],\n                        valorRecebidoTotal: 0,\n                        descontoReal: prev.valorBruto > 0 ? 100 : 0,\n                        valorRestante: prev.valorNegociado\n                    })\n            }[\"useSimulador.useCallback[limparFormas]\"]);\n        }\n    }[\"useSimulador.useCallback[limparFormas]\"], []);\n    const alternarTravamento = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[alternarTravamento]\": (tipo, valor)=>{\n            setSimulacao({\n                \"useSimulador.useCallback[alternarTravamento]\": (prev)=>({\n                        ...prev,\n                        travamentos: {\n                            ...prev.travamentos,\n                            [tipo]: !prev.travamentos[tipo],\n                            ...valor !== undefined && {\n                                limiteDescontoReal: valor\n                            }\n                        }\n                    })\n            }[\"useSimulador.useCallback[alternarTravamento]\"]);\n        }\n    }[\"useSimulador.useCallback[alternarTravamento]\"], []);\n    const alternarTravamentoForma = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSimulador.useCallback[alternarTravamentoForma]\": (id)=>{\n            setSimulacao({\n                \"useSimulador.useCallback[alternarTravamentoForma]\": (prev)=>({\n                        ...prev,\n                        formasPagamento: prev.formasPagamento.map({\n                            \"useSimulador.useCallback[alternarTravamentoForma]\": (forma)=>forma.id === id ? {\n                                    ...forma,\n                                    travado: !forma.travado\n                                } : forma\n                        }[\"useSimulador.useCallback[alternarTravamentoForma]\"])\n                    })\n            }[\"useSimulador.useCallback[alternarTravamentoForma]\"]);\n        }\n    }[\"useSimulador.useCallback[alternarTravamentoForma]\"], []);\n    return {\n        simulacao,\n        recalcularSimulacao,\n        adicionarForma,\n        atualizarForma,\n        removerForma,\n        limparFormas,\n        alternarTravamento,\n        alternarTravamentoForma,\n        editarValorNegociado,\n        editarValorBruto,\n        editarDescontoReal\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VTaW11bGFkb3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXVEO0FBR2hELE1BQU1HLGVBQWU7SUFDMUIsTUFBTSxDQUFDQyxXQUFXQyxhQUFhLEdBQUdMLCtDQUFRQSxDQUFZO1FBQ3BETSxZQUFZO1FBQ1pDLFVBQVU7UUFDVkMsZ0JBQWdCO1FBQ2hCQyxpQkFBaUIsRUFBRTtRQUNuQkMsb0JBQW9CO1FBQ3BCQyxjQUFjO1FBQ2RDLGVBQWU7UUFDZkMsYUFBYTtZQUNYTCxnQkFBZ0I7WUFDaEJHLGNBQWM7WUFDZEcsb0JBQW9CO1FBQ3RCO0lBQ0Y7SUFFQSw0Q0FBNEM7SUFDNUMsTUFBTUMsb0JBQW9CYiw4Q0FBT0E7bURBQUMsSUFBTTtnQkFBQztnQkFBVztnQkFBVTtnQkFBYzthQUFTO2tEQUFFLEVBQUU7SUFFekYsTUFBTWMsNkJBQTZCZixrREFBV0E7Z0VBQUMsQ0FBQ2dCO1lBQzlDQyxRQUFRQyxHQUFHLENBQUMsbUNBQW1DRjtZQUUvQyxPQUFRQSxNQUFNRyxJQUFJO2dCQUNoQixLQUFLO29CQUNILE9BQU9ILE1BQU1JLEtBQUs7Z0JBRXBCLEtBQUs7b0JBQWM7d0JBQ2pCLElBQUksQ0FBQ0osTUFBTUssUUFBUSxJQUFJLENBQUNMLE1BQU1NLFNBQVMsRUFBRSxPQUFPTixNQUFNSSxLQUFLO3dCQUMzRCxNQUFNRyxJQUFJUCxNQUFNTSxTQUFTLEdBQUc7d0JBQzVCLE1BQU1ELFdBQVdMLE1BQU1LLFFBQVE7d0JBQy9CLE1BQU1HLGdCQUFnQlIsTUFBTUksS0FBSyxHQUFHSyxLQUFLQyxHQUFHLENBQUMsSUFBSUgsR0FBR0Y7d0JBQ3BESixRQUFRQyxHQUFHLENBQUMscUJBQThDRyxPQUF6QkwsTUFBTUksS0FBSyxFQUFDLGVBQStCSixPQUFsQkssVUFBUyxXQUFpQ0csT0FBeEJSLE1BQU1NLFNBQVMsRUFBQyxVQUFzQixPQUFkRTt3QkFDcEcsT0FBT0E7b0JBQ1Q7Z0JBRUEsS0FBSztvQkFBVTt3QkFDYixJQUFJLENBQUNSLE1BQU1XLFFBQVEsSUFBSSxDQUFDWCxNQUFNWSxnQkFBZ0IsSUFBSSxDQUFDWixNQUFNSyxRQUFRLEVBQUUsT0FBT0wsTUFBTUksS0FBSzt3QkFDckYsTUFBTVMsZ0JBQWdCLElBQUtiLE1BQU1XLFFBQVEsR0FBRzt3QkFDNUMsTUFBTUcsYUFBYSxJQUFLZCxNQUFNWSxnQkFBZ0IsR0FBRyxNQUFNWixNQUFNSyxRQUFRO3dCQUNyRSxNQUFNVSxnQkFBZ0JmLE1BQU1JLEtBQUssR0FBR1MsZ0JBQWdCQzt3QkFDcERiLFFBQVFDLEdBQUcsQ0FBQyxvQkFBMENGLE9BQXpCQSxNQUFNSSxLQUFLLEVBQUMscUJBQXVDSixPQUExQkEsTUFBTVcsUUFBUSxFQUFDLGFBQTBDSSxPQUEvQmYsTUFBTVksZ0JBQWdCLEVBQUMsVUFBc0IsT0FBZEc7d0JBQy9HLE9BQU9BO29CQUNUO2dCQUVBLEtBQUs7b0JBQVU7d0JBQ2IsSUFBSSxDQUFDZixNQUFNSyxRQUFRLElBQUksQ0FBQ0wsTUFBTWdCLFlBQVksRUFBRSxPQUFPaEIsTUFBTUksS0FBSzt3QkFDOUQsTUFBTWEsS0FBS2pCLE1BQU1nQixZQUFZLEdBQUc7d0JBQ2hDLE1BQU1FLHNCQUFzQmxCLE1BQU1JLEtBQUssR0FBR0ssS0FBS0MsR0FBRyxDQUFDLElBQUlPLElBQUlqQixNQUFNSyxRQUFRO3dCQUN6RUosUUFBUUMsR0FBRyxDQUFDLGlCQUEwQ0YsT0FBekJBLE1BQU1JLEtBQUssRUFBQyxlQUFzQ0osT0FBekJBLE1BQU1LLFFBQVEsRUFBQyxZQUFxQ2EsT0FBM0JsQixNQUFNZ0IsWUFBWSxFQUFDLFVBQTRCLE9BQXBCRTt3QkFDMUcsT0FBT0E7b0JBQ1Q7Z0JBRUE7b0JBQ0UsT0FBT2xCLE1BQU1JLEtBQUs7WUFDdEI7UUFDRjsrREFBRyxFQUFFO0lBRUwsTUFBTWUsc0JBQXNCbkMsa0RBQVdBO3lEQUFDLENBQUNvQyxvQkFBNEJDO1lBQ25FcEIsUUFBUUMsR0FBRyxDQUFDLGlEQUFpRGtCO1lBRTdELE1BQU1FLFlBQVlELGFBQWFFLE1BQU07MkVBQUMsQ0FBQ0MsS0FBS3hCLFFBQVV3QixNQUFNeEIsTUFBTUksS0FBSzswRUFBRTtZQUN6RSxNQUFNcUIsWUFBWUwscUJBQXFCRTtZQUV2QyxJQUFJYixLQUFLaUIsR0FBRyxDQUFDRCxhQUFhLE1BQU07Z0JBQzlCLE9BQU9KLGNBQWMsaUNBQWlDO1lBQ3hEO1lBRUFwQixRQUFRQyxHQUFHLENBQUMsNkJBQTZCdUI7WUFFekMseUNBQXlDO1lBQ3pDLE1BQU1FLGlCQUFpQk4sYUFBYU8sTUFBTTtnRkFBQzVCLENBQUFBLFFBQVNBLE1BQU02QixPQUFPOztZQUNqRSxNQUFNQyxvQkFBb0JULGFBQWFPLE1BQU07bUZBQUM1QixDQUFBQSxRQUFTLENBQUNBLE1BQU02QixPQUFPOztZQUVyRSxvREFBb0Q7WUFDcEQsSUFBSUMsa0JBQWtCQyxNQUFNLEtBQUssR0FBRztnQkFDbEM5QixRQUFRQyxHQUFHLENBQUM7Z0JBQ1osT0FBTyxNQUFNLGNBQWM7WUFDN0I7WUFFQSw2Q0FBNkM7WUFDN0MsTUFBTThCLGtCQUFrQkYsa0JBQWtCRyxJQUFJO2lGQUFDLENBQUNDLEdBQUdDO29CQUNqRCxNQUFNQyxjQUFjdEMsa0JBQWtCdUMsT0FBTyxDQUFDSCxFQUFFL0IsSUFBSTtvQkFDcEQsTUFBTW1DLGNBQWN4QyxrQkFBa0J1QyxPQUFPLENBQUNGLEVBQUVoQyxJQUFJO29CQUNwRCxPQUFPaUMsY0FBY0U7Z0JBQ3ZCOztZQUVBckMsUUFBUUMsR0FBRyxDQUFDLG9DQUFvQzhCLGdCQUFnQk8sR0FBRztpRUFBQ0MsQ0FBQUEsSUFBS0EsRUFBRXJDLElBQUk7O1lBRS9FLG9HQUFvRztZQUNwRyxNQUFNc0MsY0FBYzttQkFBSXBCO2FBQWE7WUFFckMsMkRBQTJEO1lBQzNELE1BQU1xQix3QkFBd0JWLGdCQUFnQlQsTUFBTTt1RkFBQyxDQUFDQyxLQUFLeEIsUUFBVXdCLE1BQU14QixNQUFNSSxLQUFLO3NGQUFFO1lBRXhGLElBQUlzQywwQkFBMEIsR0FBRztnQkFDL0Isb0VBQW9FO2dCQUNwRXpDLFFBQVFDLEdBQUcsQ0FBQztnQkFDWixNQUFNeUMsaUJBQWlCbEIsWUFBWU8sZ0JBQWdCRCxNQUFNO2dCQUN6REMsZ0JBQWdCWSxPQUFPO3FFQUFDNUMsQ0FBQUE7d0JBQ3RCLE1BQU02QyxhQUFhSixZQUFZSyxTQUFTO3dGQUFDTixDQUFBQSxJQUFLQSxFQUFFTyxFQUFFLEtBQUsvQyxNQUFNK0MsRUFBRTs7d0JBQy9ELE1BQU1DLFlBQVlMO3dCQUNsQkYsV0FBVyxDQUFDSSxXQUFXLEdBQUc7NEJBQUUsR0FBR0osV0FBVyxDQUFDSSxXQUFXOzRCQUFFekMsT0FBT0ssS0FBS3dDLEdBQUcsQ0FBQyxHQUFHRDt3QkFBVzt3QkFDdEYvQyxRQUFRQyxHQUFHLENBQUMsU0FBc0M4QyxPQUE3QmhELE1BQU1HLElBQUksRUFBQyxvQkFBdUNNLE9BQXJCdUMsV0FBVSxhQUFrQyxPQUF2QnZDLEtBQUt3QyxHQUFHLENBQUMsR0FBR0QsWUFBVztvQkFDaEc7O1lBQ0YsT0FBTztnQkFDTCxzRkFBc0Y7Z0JBQ3RGL0MsUUFBUUMsR0FBRyxDQUFDO2dCQUNaLE1BQU1nRCxnQkFBZ0JsQixlQUFlLENBQUMsRUFBRTtnQkFDeEMsTUFBTWEsYUFBYUosWUFBWUssU0FBUztnRkFBQ04sQ0FBQUEsSUFBS0EsRUFBRU8sRUFBRSxLQUFLRyxjQUFjSCxFQUFFOztnQkFDdkUsTUFBTUksaUJBQWlCRCxjQUFjOUMsS0FBSyxHQUFHcUI7Z0JBQzdDLE1BQU11QixZQUFZdkMsS0FBS3dDLEdBQUcsQ0FBQyxHQUFHRTtnQkFDOUJWLFdBQVcsQ0FBQ0ksV0FBVyxHQUFHO29CQUFFLEdBQUdKLFdBQVcsQ0FBQ0ksV0FBVztvQkFBRXpDLE9BQU80QztnQkFBVTtnQkFDekUvQyxRQUFRQyxHQUFHLENBQUMsU0FBMkNnRCxPQUFsQ0EsY0FBYy9DLElBQUksRUFBQyxpQkFBMkNnRCxPQUE1QkQsY0FBYzlDLEtBQUssRUFBQyxVQUFrQzRDLE9BQTFCRyxnQkFBZSxhQUFxQixPQUFWSCxXQUFVO2dCQUV2SCxxREFBcUQ7Z0JBQ3JELElBQUlHLGlCQUFpQixHQUFHO29CQUN0QmxELFFBQVFDLEdBQUcsQ0FBQyxnQ0FBK0MsT0FBZmlELGdCQUFlO2dCQUM3RDtZQUNGO1lBRUEsT0FBT1Y7UUFDVDt3REFBRztRQUFDM0M7S0FBa0I7SUFFdEIsTUFBTXNELHNCQUFzQnBFLGtEQUFXQTt5REFBQyxDQUFDcUU7WUFDdkNwRCxRQUFRQyxHQUFHLENBQUMsdUNBQXVDbUQ7WUFFbkRqRTtpRUFBYWtFLENBQUFBO29CQUNYLE1BQU1DLFVBQVU7d0JBQUUsR0FBR0QsSUFBSTt3QkFBRSxHQUFHRCxPQUFPO29CQUFDO29CQUV0Qyw0Q0FBNEM7b0JBQzVDLElBQUlFLFFBQVEzRCxXQUFXLENBQUM0RCxnQkFBZ0IsRUFBRTt3QkFDeEMsTUFBTUEsbUJBQW1CRCxRQUFRM0QsV0FBVyxDQUFDNkQscUJBQXFCO3dCQUNsRXhELFFBQVFDLEdBQUcsQ0FBQyw0QkFBNkMsT0FBakJzRCxrQkFBaUI7d0JBRXpELG1FQUFtRTt3QkFDbkUsTUFBTUUsMEJBQTBCSCxRQUFRbEUsVUFBVSxHQUFJLEtBQUltRSxtQkFBbUIsR0FBRTt3QkFFL0UsK0RBQStEO3dCQUMvRCwwQ0FBMEM7d0JBRTFDLE9BQU9EO29CQUNUO29CQUVBLDBDQUEwQztvQkFDMUMsSUFBSUEsUUFBUTNELFdBQVcsQ0FBQ0wsY0FBYyxFQUFFO3dCQUN0Qyw2RUFBNkU7d0JBQzdFLElBQUk4RCxRQUFRaEUsVUFBVSxLQUFLc0UsYUFBYU4sUUFBUWhFLFVBQVUsR0FBRyxHQUFHOzRCQUM5RGtFLFFBQVFqRSxRQUFRLEdBQUcsQ0FBRWlFLFFBQVFsRSxVQUFVLEdBQUdrRSxRQUFRaEUsY0FBYyxJQUFJZ0UsUUFBUWxFLFVBQVUsR0FBSTt3QkFDNUY7b0JBQ0YsT0FBTzt3QkFDTCxvRUFBb0U7d0JBQ3BFa0UsUUFBUWhFLGNBQWMsR0FBR2dFLFFBQVFsRSxVQUFVLEdBQUksS0FBSWtFLFFBQVFqRSxRQUFRLEdBQUcsR0FBRTtvQkFDMUU7b0JBRUFpRSxRQUFRL0QsZUFBZSxHQUFHK0QsUUFBUS9ELGVBQWUsQ0FBQytDLEdBQUc7eUVBQUN2QyxDQUFBQSxRQUFVO2dDQUM5RCxHQUFHQSxLQUFLO2dDQUNSZSxlQUFlaEIsMkJBQTJCQzs0QkFDNUM7O29CQUVBdUQsUUFBUTlELGtCQUFrQixHQUFHOEQsUUFBUS9ELGVBQWUsQ0FBQytCLE1BQU07eUVBQUMsQ0FBQ0MsS0FBS3hCLFFBQVV3QixNQUFNeEIsTUFBTWUsYUFBYTt3RUFBRTtvQkFDdkd3QyxRQUFRN0QsWUFBWSxHQUFHNkQsUUFBUWxFLFVBQVUsR0FBRyxJQUFJLENBQUVrRSxRQUFRbEUsVUFBVSxHQUFHa0UsUUFBUTlELGtCQUFrQixJQUFJOEQsUUFBUWxFLFVBQVUsR0FBSSxNQUFNO29CQUVqSSxNQUFNdUUsYUFBYUwsUUFBUS9ELGVBQWUsQ0FBQytCLE1BQU07b0ZBQUMsQ0FBQ0MsS0FBS3hCLFFBQVV3QixNQUFNeEIsTUFBTUksS0FBSzttRkFBRTtvQkFDckZtRCxRQUFRNUQsYUFBYSxHQUFHNEQsUUFBUWhFLGNBQWMsR0FBR3FFO29CQUVqRDNELFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUJxRDtvQkFDckMsT0FBT0E7Z0JBQ1Q7O1FBQ0Y7d0RBQUc7UUFBQ3hEO0tBQTJCO0lBRS9CLE1BQU04RCx1QkFBdUI3RSxrREFBV0E7MERBQUMsQ0FBQ2dFO1lBQ3hDL0MsUUFBUUMsR0FBRyxDQUFDLGtDQUFrQzhDO1lBRTlDNUQ7a0VBQWFrRSxDQUFBQTtvQkFDWCxNQUFNUSx1QkFBdUIzQyxvQkFBb0I2QixXQUFXTSxLQUFLOUQsZUFBZTtvQkFFaEYsSUFBSSxDQUFDc0Usc0JBQXNCO3dCQUN6QkMsTUFBTTt3QkFDTixPQUFPVDtvQkFDVDtvQkFFQSxNQUFNQyxVQUFVO3dCQUNkLEdBQUdELElBQUk7d0JBQ1AvRCxnQkFBZ0J5RDt3QkFDaEJ4RCxpQkFBaUJzRSxxQkFBcUJ2QixHQUFHOzhFQUFDdkMsQ0FBQUEsUUFBVTtvQ0FDbEQsR0FBR0EsS0FBSztvQ0FDUmUsZUFBZWhCLDJCQUEyQkM7Z0NBQzVDOztvQkFDRjtvQkFFQSxzQkFBc0I7b0JBQ3RCdUQsUUFBUWpFLFFBQVEsR0FBR2lFLFFBQVFsRSxVQUFVLEdBQUcsSUFBSSxDQUFFa0UsUUFBUWxFLFVBQVUsR0FBR2tFLFFBQVFoRSxjQUFjLElBQUlnRSxRQUFRbEUsVUFBVSxHQUFJLE1BQU07b0JBRXpIa0UsUUFBUTlELGtCQUFrQixHQUFHOEQsUUFBUS9ELGVBQWUsQ0FBQytCLE1BQU07MEVBQUMsQ0FBQ0MsS0FBS3hCLFFBQVV3QixNQUFNeEIsTUFBTWUsYUFBYTt5RUFBRTtvQkFDdkd3QyxRQUFRN0QsWUFBWSxHQUFHNkQsUUFBUWxFLFVBQVUsR0FBRyxJQUFJLENBQUVrRSxRQUFRbEUsVUFBVSxHQUFHa0UsUUFBUTlELGtCQUFrQixJQUFJOEQsUUFBUWxFLFVBQVUsR0FBSSxNQUFNO29CQUVqSSxNQUFNdUUsYUFBYUwsUUFBUS9ELGVBQWUsQ0FBQytCLE1BQU07cUZBQUMsQ0FBQ0MsS0FBS3hCLFFBQVV3QixNQUFNeEIsTUFBTUksS0FBSztvRkFBRTtvQkFDckZtRCxRQUFRNUQsYUFBYSxHQUFHNEQsUUFBUWhFLGNBQWMsR0FBR3FFO29CQUVqRCxPQUFPTDtnQkFDVDs7UUFDRjt5REFBRztRQUFDcEM7UUFBcUJwQjtLQUEyQjtJQUVwRCxNQUFNaUUscUJBQXFCaEYsa0RBQVdBO3dEQUFDLENBQUNpRixrQkFBMEJDO1lBQ2hFakUsUUFBUUMsR0FBRyxDQUFDLGdDQUFnQytELGtCQUFrQixXQUFXQztZQUV6RTlFO2dFQUFha0UsQ0FBQUE7b0JBQ1gsa0RBQWtEO29CQUNsRCxJQUFJWSxZQUFZO3dCQUNkLE9BQU87NEJBQ0wsR0FBR1osSUFBSTs0QkFDUDFELGFBQWE7Z0NBQ1gsR0FBRzBELEtBQUsxRCxXQUFXO2dDQUNuQjRELGtCQUFrQjtnQ0FDbEJDLHVCQUF1QlE7NEJBQ3pCO3dCQUNGO29CQUNGO29CQUVBLHVDQUF1QztvQkFDdkMsTUFBTUU7c0dBQWdDLENBQUM1RTs0QkFDckMsTUFBTTZFLGFBQWFqRCxvQkFBb0I1QixnQkFBZ0IrRCxLQUFLOUQsZUFBZTs0QkFDM0UsSUFBSSxDQUFDNEUsWUFBWSxPQUFPLENBQUM7NEJBRXpCLE1BQU1DLG9CQUFvQkQsV0FBVzdDLE1BQU07Z0lBQUMsQ0FBQ0MsS0FBS3hCO29DQUNoRCxNQUFNc0UsbUJBQW1CO3dDQUFFLEdBQUd0RSxLQUFLO3dDQUFFZSxlQUFlaEIsMkJBQTJCQztvQ0FBTztvQ0FDdEYsT0FBT3dCLE1BQU04QyxpQkFBaUJ2RCxhQUFhO2dDQUM3QzsrSEFBRzs0QkFFSCxPQUFPdUMsS0FBS2pFLFVBQVUsR0FBRyxJQUFJLENBQUVpRSxLQUFLakUsVUFBVSxHQUFHZ0YsaUJBQWdCLElBQUtmLEtBQUtqRSxVQUFVLEdBQUksTUFBTTt3QkFDakc7O29CQUVBLHVGQUF1RjtvQkFDdkYsSUFBSWtGLFdBQVc7b0JBQ2YsSUFBSUMsV0FBV2xCLEtBQUtqRSxVQUFVO29CQUM5QixJQUFJb0Ysc0JBQXNCbkIsS0FBSy9ELGNBQWM7b0JBQzdDLElBQUltRixrQkFBa0JDO29CQUN0QixJQUFJQyxpQkFBaUJ0QixLQUFLNUQsWUFBWTtvQkFFdENPLFFBQVFDLEdBQUcsQ0FBQywrREFBbUUsT0FBakIrRCxrQkFBaUI7b0JBQy9FaEUsUUFBUUMsR0FBRyxDQUFDLHdCQUEwQyxPQUFsQm9ELEtBQUs1RCxZQUFZLEVBQUM7b0JBQ3RETyxRQUFRQyxHQUFHLENBQUMsc0JBQW9Dc0UsT0FBZEQsVUFBUyxPQUFjLE9BQVRDO29CQUVoRCw2Q0FBNkM7b0JBQzdDLElBQUssSUFBSWpFLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO3dCQUMzQixNQUFNc0UsYUFBYSxDQUFDTixXQUFXQyxRQUFPLElBQUs7d0JBQzNDLE1BQU1NLHdCQUF3QlgsOEJBQThCVTt3QkFFNUQ1RSxRQUFRQyxHQUFHLENBQUMsa0JBQWlDMkUsT0FBckJ0RSxJQUFJLEdBQUUsaUJBQWtEdUUsT0FBbkNELFdBQVdFLE9BQU8sQ0FBQyxJQUFHLGVBQThDLE9BQWpDRCxzQkFBc0JDLE9BQU8sQ0FBQyxJQUFHO3dCQUVqSCxJQUFJRCwwQkFBMEIsQ0FBQyxHQUFHOzRCQUNoQyw2Q0FBNkM7NEJBQzdDN0UsUUFBUUMsR0FBRyxDQUFDOzRCQUNacUUsV0FBV007NEJBQ1g7d0JBQ0Y7d0JBRUEsTUFBTXBELFlBQVloQixLQUFLaUIsR0FBRyxDQUFDb0Qsd0JBQXdCYjt3QkFFbkQsNENBQTRDO3dCQUM1QyxJQUFJeEMsWUFBWWlELGlCQUFpQjs0QkFDL0JBLGtCQUFrQmpEOzRCQUNsQmdELHNCQUFzQkk7NEJBQ3RCRCxpQkFBaUJFOzRCQUNqQjdFLFFBQVFDLEdBQUcsQ0FBQyxxQ0FBOEV3RSxPQUF6Q0UsZUFBZUcsT0FBTyxDQUFDLElBQUcsb0JBQTBDLE9BQTNCTCxnQkFBZ0JLLE9BQU8sQ0FBQzt3QkFDcEg7d0JBRUEsd0NBQXdDO3dCQUN4QyxJQUFJdEQsWUFBWSxNQUFNOzRCQUNwQnhCLFFBQVFDLEdBQUcsQ0FBRTs0QkFDYjt3QkFDRjt3QkFFQSx1Q0FBdUM7d0JBQ3ZDLElBQUlLLElBQUksTUFBTW1FLGtCQUFrQixHQUFHOzRCQUNqQ3pFLFFBQVFDLEdBQUcsQ0FBQywyRUFBNEYsT0FBMUIwRSxlQUFlRyxPQUFPLENBQUMsSUFBRzs0QkFDeEc7d0JBQ0Y7d0JBRUEsOEJBQThCO3dCQUM5QixJQUFJRCx3QkFBd0JiLGtCQUFrQjs0QkFDNUMsaUZBQWlGOzRCQUNqRk8sV0FBV0s7NEJBQ1g1RSxRQUFRQyxHQUFHLENBQUMsZ0NBQTZEK0QsT0FBdkNhLHNCQUFzQkMsT0FBTyxDQUFDLElBQUcsUUFBc0RQLE9BQWhEUCxrQkFBaUIsaUNBQW1ELE9BQXBCTyxTQUFTTyxPQUFPLENBQUM7d0JBQzVJLE9BQU87NEJBQ0wsaUZBQWlGOzRCQUNqRlIsV0FBV007NEJBQ1g1RSxRQUFRQyxHQUFHLENBQUMsK0JBQTREK0QsT0FBdkNhLHNCQUFzQkMsT0FBTyxDQUFDLElBQUcsUUFBc0RSLE9BQWhETixrQkFBaUIsaUNBQW1ELE9BQXBCTSxTQUFTUSxPQUFPLENBQUM7d0JBQzNJO3dCQUVBLCtDQUErQzt3QkFDL0MsSUFBSXRFLEtBQUtpQixHQUFHLENBQUM4QyxXQUFXRCxZQUFZLEtBQUs7NEJBQ3ZDdEUsUUFBUUMsR0FBRyxDQUFDLHlDQUF3RSxPQUF6Q08sS0FBS2lCLEdBQUcsQ0FBQzhDLFdBQVdELFVBQVVRLE9BQU8sQ0FBQyxJQUFHOzRCQUNwRjt3QkFDRjtvQkFDRjtvQkFFQTlFLFFBQVFDLEdBQUcsQ0FBRTtvQkFDYkQsUUFBUUMsR0FBRyxDQUFDLGdDQUE0RCxPQUEvQnVFLG9CQUFvQk0sT0FBTyxDQUFDO29CQUNyRTlFLFFBQVFDLEdBQUcsQ0FBQyxnQ0FBMEQsT0FBMUIwRSxlQUFlRyxPQUFPLENBQUMsSUFBRztvQkFDdEU5RSxRQUFRQyxHQUFHLENBQUMsZ0NBQXdELE9BQTNCd0UsZ0JBQWdCSyxPQUFPLENBQUM7b0JBRWpFLHdEQUF3RDtvQkFDeEQsSUFBSUwsa0JBQWtCLEdBQUc7d0JBQ3ZCekUsUUFBUUMsR0FBRyxDQUFDLGdEQUFrRjBFLE9BQXhDWCxrQkFBaUIseUJBQWlELE9BQTFCVyxlQUFlRyxPQUFPLENBQUMsSUFBRzt3QkFDeEgsTUFBTUMsWUFBWUMsUUFBUSw2Q0FBMEdMLE9BQW5FWCxrQkFBaUIsdURBQTRFLE9BQTFCVyxlQUFlRyxPQUFPLENBQUMsSUFBRzt3QkFDOUosSUFBSSxDQUFDQyxXQUFXOzRCQUNkLE9BQU8xQjt3QkFDVDtvQkFDRjtvQkFFQSw2Q0FBNkM7b0JBQzdDLE1BQU1RLHVCQUF1QjNDLG9CQUFvQnNELHFCQUFxQm5CLEtBQUs5RCxlQUFlO29CQUUxRixJQUFJLENBQUNzRSxzQkFBc0I7d0JBQ3pCQyxNQUFNO3dCQUNOLE9BQU9UO29CQUNUO29CQUVBLGlEQUFpRDtvQkFDakQsTUFBTUMsVUFBVTt3QkFDZCxHQUFHRCxJQUFJO3dCQUNQL0QsZ0JBQWdCa0Y7d0JBQ2hCakYsaUJBQWlCc0UscUJBQXFCdkIsR0FBRzs0RUFBQ3ZDLENBQUFBLFFBQVU7b0NBQ2xELEdBQUdBLEtBQUs7b0NBQ1JlLGVBQWVoQiwyQkFBMkJDO2dDQUM1Qzs7d0JBQ0FKLGFBQWE7NEJBQ1gsR0FBRzBELEtBQUsxRCxXQUFXOzRCQUNuQjRELGtCQUFrQlUsY0FBYzs0QkFDaENULHVCQUF1QlMsYUFBYUQsbUJBQW1CWCxLQUFLMUQsV0FBVyxDQUFDNkQscUJBQXFCO3dCQUMvRjtvQkFDRjtvQkFFQSwrQkFBK0I7b0JBQy9CRixRQUFROUQsa0JBQWtCLEdBQUc4RCxRQUFRL0QsZUFBZSxDQUFDK0IsTUFBTTt3RUFBQyxDQUFDQyxLQUFLeEIsUUFBVXdCLE1BQU14QixNQUFNZSxhQUFhO3VFQUFFO29CQUN2R3dDLFFBQVE3RCxZQUFZLEdBQUc2RCxRQUFRbEUsVUFBVSxHQUFHLElBQUksQ0FBRWtFLFFBQVFsRSxVQUFVLEdBQUdrRSxRQUFROUQsa0JBQWtCLElBQUk4RCxRQUFRbEUsVUFBVSxHQUFJLE1BQU07b0JBRWpJLE1BQU11RSxhQUFhTCxRQUFRL0QsZUFBZSxDQUFDK0IsTUFBTTttRkFBQyxDQUFDQyxLQUFLeEIsUUFBVXdCLE1BQU14QixNQUFNSSxLQUFLO2tGQUFFO29CQUNyRm1ELFFBQVE1RCxhQUFhLEdBQUc0RCxRQUFRaEUsY0FBYyxHQUFHcUU7b0JBRWpEM0QsUUFBUUMsR0FBRyxDQUFDLDJDQUEyQ3FEO29CQUN2RHRELFFBQVFDLEdBQUcsQ0FBQyw2QkFBa0QsT0FBckJxRCxRQUFRN0QsWUFBWSxFQUFDO29CQUU5RCxPQUFPNkQ7Z0JBQ1Q7O1FBQ0Y7dURBQUc7UUFBQ3BDO1FBQXFCcEI7S0FBMkI7SUFFcEQsTUFBTW1GLG1CQUFtQmxHLGtEQUFXQTtzREFBQyxDQUFDZ0U7WUFDcEMvQyxRQUFRQyxHQUFHLENBQUMsOEJBQThCOEM7WUFDMUNJLG9CQUFvQjtnQkFBRS9ELFlBQVkyRDtZQUFVO1FBQzlDO3FEQUFHO1FBQUNJO0tBQW9CO0lBRXhCLE1BQU0rQixpQkFBaUJuRyxrREFBV0E7b0RBQUMsQ0FBQ2dCO1lBQ2xDQyxRQUFRQyxHQUFHLENBQUMsc0JBQXNCRjtZQUVsQ1o7NERBQWFrRSxDQUFBQTtvQkFDWCx3Q0FBd0M7b0JBQ3hDLElBQUlBLEtBQUsxRCxXQUFXLENBQUNGLFlBQVksRUFBRTt3QkFDakMsTUFBTTBGLGdCQUFnQzs0QkFDcEMsR0FBR3BGLEtBQUs7NEJBQ1IrQyxJQUFJc0MsS0FBS0MsR0FBRyxHQUFHQyxRQUFROzRCQUN2QnhFLGVBQWU7d0JBQ2pCO3dCQUNBcUUsY0FBY3JFLGFBQWEsR0FBR2hCLDJCQUEyQnFGO3dCQUV6RCxNQUFNSSx5QkFBeUJsQyxLQUFLN0Qsa0JBQWtCLEdBQUcyRixjQUFjckUsYUFBYTt3QkFDcEYsTUFBTWtELG1CQUFtQlgsS0FBS2pFLFVBQVUsR0FBRyxJQUFJLENBQUVpRSxLQUFLakUsVUFBVSxHQUFHbUcsc0JBQXFCLElBQUtsQyxLQUFLakUsVUFBVSxHQUFJLE1BQU07d0JBRXRILElBQUk0RSxtQkFBbUJYLEtBQUsxRCxXQUFXLENBQUNDLGtCQUFrQixFQUFFOzRCQUMxRGtFLE1BQU0sdUZBQWtILE9BQXBDVCxLQUFLMUQsV0FBVyxDQUFDQyxrQkFBa0IsRUFBQzs0QkFDeEgsT0FBT3lEO3dCQUNUO29CQUNGO29CQUVBLE1BQU1tQyxZQUE0Qjt3QkFDaEMsR0FBR3pGLEtBQUs7d0JBQ1IrQyxJQUFJc0MsS0FBS0MsR0FBRyxHQUFHQyxRQUFRO3dCQUN2QnhFLGVBQWU7d0JBQ2ZjLFNBQVM7b0JBQ1g7b0JBRUE0RCxVQUFVMUUsYUFBYSxHQUFHaEIsMkJBQTJCMEY7b0JBRXJELE1BQU1oRCxjQUFjOzJCQUFJYSxLQUFLOUQsZUFBZTt3QkFBRWlHO3FCQUFVO29CQUN4RCxNQUFNbEMsVUFBVTt3QkFBRSxHQUFHRCxJQUFJO3dCQUFFOUQsaUJBQWlCaUQ7b0JBQVk7b0JBRXhEYyxRQUFROUQsa0JBQWtCLEdBQUdnRCxZQUFZbEIsTUFBTTtvRUFBQyxDQUFDQyxLQUFLZ0IsSUFBTWhCLE1BQU1nQixFQUFFekIsYUFBYTttRUFBRTtvQkFDbkZ3QyxRQUFRN0QsWUFBWSxHQUFHNkQsUUFBUWxFLFVBQVUsR0FBRyxJQUFJLENBQUVrRSxRQUFRbEUsVUFBVSxHQUFHa0UsUUFBUTlELGtCQUFrQixJQUFJOEQsUUFBUWxFLFVBQVUsR0FBSSxNQUFNO29CQUVqSSxNQUFNdUUsYUFBYW5CLFlBQVlsQixNQUFNOytFQUFDLENBQUNDLEtBQUtnQixJQUFNaEIsTUFBTWdCLEVBQUVwQyxLQUFLOzhFQUFFO29CQUNqRW1ELFFBQVE1RCxhQUFhLEdBQUc0RCxRQUFRaEUsY0FBYyxHQUFHcUU7b0JBRWpEM0QsUUFBUUMsR0FBRyxDQUFDLHdDQUF3Q3FEO29CQUNwRCxPQUFPQTtnQkFDVDs7UUFDRjttREFBRztRQUFDeEQ7S0FBMkI7SUFFL0IsTUFBTTJGLGlCQUFpQjFHLGtEQUFXQTtvREFBQyxDQUFDK0QsSUFBWTRDO1lBQzlDMUYsUUFBUUMsR0FBRyxDQUFDLHNCQUFzQjZDLElBQUk0QztZQUV0Q3ZHOzREQUFha0UsQ0FBQUE7b0JBQ1gsTUFBTWIsY0FBY2EsS0FBSzlELGVBQWUsQ0FBQytDLEdBQUc7Z0ZBQUN2QyxDQUFBQTs0QkFDM0MsSUFBSUEsTUFBTStDLEVBQUUsS0FBS0EsSUFBSTtnQ0FDbkIsdURBQXVEO2dDQUN2RCxJQUFJL0MsTUFBTTZCLE9BQU8sSUFBSThELGlCQUFpQnZGLEtBQUssS0FBS0osTUFBTUksS0FBSyxFQUFFO29DQUMzREgsUUFBUUMsR0FBRyxDQUFDO29DQUNaLE9BQU9GO2dDQUNUO2dDQUVBLE1BQU00RixrQkFBa0I7b0NBQUUsR0FBRzVGLEtBQUs7b0NBQUUsR0FBRzJGLGdCQUFnQjtnQ0FBQztnQ0FDeERDLGdCQUFnQjdFLGFBQWEsR0FBR2hCLDJCQUEyQjZGO2dDQUMzRCxPQUFPQTs0QkFDVDs0QkFDQSxPQUFPNUY7d0JBQ1Q7O29CQUVBLE1BQU11RCxVQUFVO3dCQUFFLEdBQUdELElBQUk7d0JBQUU5RCxpQkFBaUJpRDtvQkFBWTtvQkFFeERjLFFBQVE5RCxrQkFBa0IsR0FBR2dELFlBQVlsQixNQUFNO29FQUFDLENBQUNDLEtBQUtnQixJQUFNaEIsTUFBTWdCLEVBQUV6QixhQUFhO21FQUFFO29CQUNuRndDLFFBQVE3RCxZQUFZLEdBQUc2RCxRQUFRbEUsVUFBVSxHQUFHLElBQUksQ0FBRWtFLFFBQVFsRSxVQUFVLEdBQUdrRSxRQUFROUQsa0JBQWtCLElBQUk4RCxRQUFRbEUsVUFBVSxHQUFJLE1BQU07b0JBRWpJLE1BQU11RSxhQUFhbkIsWUFBWWxCLE1BQU07K0VBQUMsQ0FBQ0MsS0FBS2dCLElBQU1oQixNQUFNZ0IsRUFBRXBDLEtBQUs7OEVBQUU7b0JBQ2pFbUQsUUFBUTVELGFBQWEsR0FBRzRELFFBQVFoRSxjQUFjLEdBQUdxRTtvQkFFakQzRCxRQUFRQyxHQUFHLENBQUMscUNBQXFDcUQ7b0JBQ2pELE9BQU9BO2dCQUNUOztRQUNGO21EQUFHO1FBQUN4RDtLQUEyQjtJQUUvQixNQUFNOEYsZUFBZTdHLGtEQUFXQTtrREFBQyxDQUFDK0Q7WUFDaEM5QyxRQUFRQyxHQUFHLENBQUMsb0JBQW9CNkM7WUFFaEMzRDswREFBYWtFLENBQUFBO29CQUNYLE1BQU1iLGNBQWNhLEtBQUs5RCxlQUFlLENBQUNvQyxNQUFNOzhFQUFDWSxDQUFBQSxJQUFLQSxFQUFFTyxFQUFFLEtBQUtBOztvQkFDOUQsT0FBTzt3QkFDTCxHQUFHTyxJQUFJO3dCQUNQOUQsaUJBQWlCaUQ7d0JBQ2pCaEQsb0JBQW9CZ0QsWUFBWWxCLE1BQU07c0VBQUMsQ0FBQ0MsS0FBS2dCLElBQU1oQixNQUFNZ0IsRUFBRXpCLGFBQWE7cUVBQUU7d0JBQzFFckIsY0FBYzRELEtBQUtqRSxVQUFVLEdBQUcsSUFBSSxDQUFFaUUsS0FBS2pFLFVBQVUsR0FBR29ELFlBQVlsQixNQUFNO3NFQUFDLENBQUNDLEtBQUtnQixJQUFNaEIsTUFBTWdCLEVBQUV6QixhQUFhO3FFQUFFLEVBQUMsSUFBS3VDLEtBQUtqRSxVQUFVLEdBQUksTUFBTTt3QkFDN0lNLGVBQWUyRCxLQUFLL0QsY0FBYyxHQUFHa0QsWUFBWWxCLE1BQU07c0VBQUMsQ0FBQ0MsS0FBS2dCLElBQU1oQixNQUFNZ0IsRUFBRXBDLEtBQUs7cUVBQUU7b0JBQ3JGO2dCQUNGOztRQUNGO2lEQUFHLEVBQUU7SUFFTCxNQUFNMEYsZUFBZTlHLGtEQUFXQTtrREFBQztZQUMvQmlCLFFBQVFDLEdBQUcsQ0FBQztZQUNaZDswREFBYWtFLENBQUFBLE9BQVM7d0JBQ3BCLEdBQUdBLElBQUk7d0JBQ1A5RCxpQkFBaUIsRUFBRTt3QkFDbkJDLG9CQUFvQjt3QkFDcEJDLGNBQWM0RCxLQUFLakUsVUFBVSxHQUFHLElBQUksTUFBTTt3QkFDMUNNLGVBQWUyRCxLQUFLL0QsY0FBYztvQkFDcEM7O1FBQ0Y7aURBQUcsRUFBRTtJQUVMLE1BQU13RyxxQkFBcUIvRyxrREFBV0E7d0RBQUMsQ0FBQ21CLE1BQThCQztZQUNwRWhCO2dFQUFha0UsQ0FBQUEsT0FBUzt3QkFDcEIsR0FBR0EsSUFBSTt3QkFDUDFELGFBQWE7NEJBQ1gsR0FBRzBELEtBQUsxRCxXQUFXOzRCQUNuQixDQUFDTyxLQUFLLEVBQUUsQ0FBQ21ELEtBQUsxRCxXQUFXLENBQUNPLEtBQUs7NEJBQy9CLEdBQUlDLFVBQVV1RCxhQUFhO2dDQUFFOUQsb0JBQW9CTzs0QkFBTSxDQUFDO3dCQUMxRDtvQkFDRjs7UUFDRjt1REFBRyxFQUFFO0lBRUwsTUFBTTRGLDBCQUEwQmhILGtEQUFXQTs2REFBQyxDQUFDK0Q7WUFDM0MzRDtxRUFBYWtFLENBQUFBLE9BQVM7d0JBQ3BCLEdBQUdBLElBQUk7d0JBQ1A5RCxpQkFBaUI4RCxLQUFLOUQsZUFBZSxDQUFDK0MsR0FBRztpRkFBQ3ZDLENBQUFBLFFBQ3hDQSxNQUFNK0MsRUFBRSxLQUFLQSxLQUFLO29DQUFFLEdBQUcvQyxLQUFLO29DQUFFNkIsU0FBUyxDQUFDN0IsTUFBTTZCLE9BQU87Z0NBQUMsSUFBSTdCOztvQkFFOUQ7O1FBQ0Y7NERBQUcsRUFBRTtJQUVMLE9BQU87UUFDTGI7UUFDQWlFO1FBQ0ErQjtRQUNBTztRQUNBRztRQUNBQztRQUNBQztRQUNBQztRQUNBbkM7UUFDQXFCO1FBQ0FsQjtJQUNGO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxyaWNhclxcUHJvamV0b3NcXGZsdXl0LXByb3Bvc3RhLXNpbXVsYWRvclxcc3JjXFxob29rc1xcdXNlU2ltdWxhZG9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEZvcm1hUGFnYW1lbnRvLCBTaW11bGFjYW8sIFRyYXZhbWVudG9Db25maWcgfSBmcm9tICcuLi90eXBlcy9zaW11bGFkb3InO1xuXG5leHBvcnQgY29uc3QgdXNlU2ltdWxhZG9yID0gKCkgPT4ge1xuICBjb25zdCBbc2ltdWxhY2FvLCBzZXRTaW11bGFjYW9dID0gdXNlU3RhdGU8U2ltdWxhY2FvPih7XG4gICAgdmFsb3JCcnV0bzogMCxcbiAgICBkZXNjb250bzogMCxcbiAgICB2YWxvck5lZ29jaWFkbzogMCxcbiAgICBmb3JtYXNQYWdhbWVudG86IFtdLFxuICAgIHZhbG9yUmVjZWJpZG9Ub3RhbDogMCxcbiAgICBkZXNjb250b1JlYWw6IDAsXG4gICAgdmFsb3JSZXN0YW50ZTogMCxcbiAgICB0cmF2YW1lbnRvczoge1xuICAgICAgdmFsb3JOZWdvY2lhZG86IGZhbHNlLFxuICAgICAgZGVzY29udG9SZWFsOiBmYWxzZSxcbiAgICAgIGxpbWl0ZURlc2NvbnRvUmVhbDogMjVcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFByaW9yaWRhZGUgcGFyYSByZWRpc3RyaWJ1acOnw6NvIGRlIHZhbG9yZXNcbiAgY29uc3QgUFJJT1JJREFERV9GT1JNQVMgPSB1c2VNZW1vKCgpID0+IFsnRU5UUkFEQScsICdCT0xFVE8nLCAnRklOQU5DRUlSQScsICdDQVJUQU8nXSwgW10pO1xuXG4gIGNvbnN0IGNhbGN1bGFyVmFsb3JSZWNlYmlkb0Zvcm1hID0gdXNlQ2FsbGJhY2soKGZvcm1hOiBGb3JtYVBhZ2FtZW50byk6IG51bWJlciA9PiB7XG4gICAgY29uc29sZS5sb2coJ0NhbGN1bGFuZG8gdmFsb3IgcmVjZWJpZG8gcGFyYTonLCBmb3JtYSk7XG4gICAgXG4gICAgc3dpdGNoIChmb3JtYS50aXBvKSB7XG4gICAgICBjYXNlICdFTlRSQURBJzpcbiAgICAgICAgcmV0dXJuIGZvcm1hLnZhbG9yO1xuICAgICAgXG4gICAgICBjYXNlICdGSU5BTkNFSVJBJzoge1xuICAgICAgICBpZiAoIWZvcm1hLnBhcmNlbGFzIHx8ICFmb3JtYS50YXhhSnVyb3MpIHJldHVybiBmb3JtYS52YWxvcjtcbiAgICAgICAgY29uc3QgaSA9IGZvcm1hLnRheGFKdXJvcyAvIDEwMDtcbiAgICAgICAgY29uc3QgcGFyY2VsYXMgPSBmb3JtYS5wYXJjZWxhcztcbiAgICAgICAgY29uc3QgdmFsb3JQcmVzZW50ZSA9IGZvcm1hLnZhbG9yIC8gTWF0aC5wb3coMSArIGksIHBhcmNlbGFzKTtcbiAgICAgICAgY29uc29sZS5sb2coYEZpbmFuY2VpcmE6IHZhbG9yPSR7Zm9ybWEudmFsb3J9LCBwYXJjZWxhcz0ke3BhcmNlbGFzfSwgdGF4YT0ke2Zvcm1hLnRheGFKdXJvc30lLCBWUD0ke3ZhbG9yUHJlc2VudGV9YCk7XG4gICAgICAgIHJldHVybiB2YWxvclByZXNlbnRlO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjYXNlICdDQVJUQU8nOiB7XG4gICAgICAgIGlmICghZm9ybWEuZGVmbGFjYW8gfHwgIWZvcm1hLmp1cm9zQW50ZWNpcGFjYW8gfHwgIWZvcm1hLnBhcmNlbGFzKSByZXR1cm4gZm9ybWEudmFsb3I7XG4gICAgICAgIGNvbnN0IGZhdG9yRGVmbGFjYW8gPSAxIC0gKGZvcm1hLmRlZmxhY2FvIC8gMTAwKTtcbiAgICAgICAgY29uc3QgZmF0b3JKdXJvcyA9IDEgLSAoZm9ybWEuanVyb3NBbnRlY2lwYWNhbyAvIDEwMCAqIGZvcm1hLnBhcmNlbGFzKTtcbiAgICAgICAgY29uc3QgdmFsb3JSZWNlYmlkbyA9IGZvcm1hLnZhbG9yICogZmF0b3JEZWZsYWNhbyAqIGZhdG9ySnVyb3M7XG4gICAgICAgIGNvbnNvbGUubG9nKGBDYXJ0w6NvOiB2YWxvcj0ke2Zvcm1hLnZhbG9yfSwgZGVmbGHDp8Ojbz0ke2Zvcm1hLmRlZmxhY2FvfSUsIGp1cm9zPSR7Zm9ybWEuanVyb3NBbnRlY2lwYWNhb30lLCBWUj0ke3ZhbG9yUmVjZWJpZG99YCk7XG4gICAgICAgIHJldHVybiB2YWxvclJlY2ViaWRvO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjYXNlICdCT0xFVE8nOiB7XG4gICAgICAgIGlmICghZm9ybWEucGFyY2VsYXMgfHwgIWZvcm1hLmN1c3RvQ2FwaXRhbCkgcmV0dXJuIGZvcm1hLnZhbG9yO1xuICAgICAgICBjb25zdCBpYyA9IGZvcm1hLmN1c3RvQ2FwaXRhbCAvIDEwMDtcbiAgICAgICAgY29uc3QgdmFsb3JQcmVzZW50ZUJvbGV0byA9IGZvcm1hLnZhbG9yIC8gTWF0aC5wb3coMSArIGljLCBmb3JtYS5wYXJjZWxhcyk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBCb2xldG86IHZhbG9yPSR7Zm9ybWEudmFsb3J9LCBwYXJjZWxhcz0ke2Zvcm1hLnBhcmNlbGFzfSwgY3VzdG89JHtmb3JtYS5jdXN0b0NhcGl0YWx9JSwgVlA9JHt2YWxvclByZXNlbnRlQm9sZXRvfWApO1xuICAgICAgICByZXR1cm4gdmFsb3JQcmVzZW50ZUJvbGV0bztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZvcm1hLnZhbG9yO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIGNvbnN0IHJlZGlzdHJpYnVpclZhbG9yZXMgPSB1c2VDYWxsYmFjaygobm92b1ZhbG9yTmVnb2NpYWRvOiBudW1iZXIsIGZvcm1hc0F0dWFpczogRm9ybWFQYWdhbWVudG9bXSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdSZWRpc3RyaWJ1aW5kbyB2YWxvcmVzLiBOb3ZvIHZhbG9yIG5lZ29jaWFkbzonLCBub3ZvVmFsb3JOZWdvY2lhZG8pO1xuICAgIFxuICAgIGNvbnN0IHNvbWFBdHVhbCA9IGZvcm1hc0F0dWFpcy5yZWR1Y2UoKGFjYywgZm9ybWEpID0+IGFjYyArIGZvcm1hLnZhbG9yLCAwKTtcbiAgICBjb25zdCBkaWZlcmVuY2EgPSBub3ZvVmFsb3JOZWdvY2lhZG8gLSBzb21hQXR1YWw7XG4gICAgXG4gICAgaWYgKE1hdGguYWJzKGRpZmVyZW5jYSkgPCAwLjAxKSB7XG4gICAgICByZXR1cm4gZm9ybWFzQXR1YWlzOyAvLyBOw6NvIGjDoSBkaWZlcmVuw6dhIHNpZ25pZmljYXRpdmFcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ0RpZmVyZW7Dp2EgYSByZWRpc3RyaWJ1aXI6JywgZGlmZXJlbmNhKTtcbiAgICBcbiAgICAvLyBTZXBhcmFyIGZvcm1hcyB0cmF2YWRhcyBlIG7Do28gdHJhdmFkYXNcbiAgICBjb25zdCBmb3JtYXNUcmF2YWRhcyA9IGZvcm1hc0F0dWFpcy5maWx0ZXIoZm9ybWEgPT4gZm9ybWEudHJhdmFkbyk7XG4gICAgY29uc3QgZm9ybWFzTmFvVHJhdmFkYXMgPSBmb3JtYXNBdHVhaXMuZmlsdGVyKGZvcm1hID0+ICFmb3JtYS50cmF2YWRvKTtcbiAgICBcbiAgICAvLyBTZSB0b2RhcyBlc3TDo28gdHJhdmFkYXMsIG7Do28gcG9kZW1vcyByZWRpc3RyaWJ1aXJcbiAgICBpZiAoZm9ybWFzTmFvVHJhdmFkYXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLmxvZygnVG9kYXMgYXMgZm9ybWFzIGVzdMOjbyB0cmF2YWRhcycpO1xuICAgICAgcmV0dXJuIG51bGw7IC8vIEluZGljYSBlcnJvXG4gICAgfVxuICAgIFxuICAgIC8vIE9yZGVuYXIgZm9ybWFzIG7Do28gdHJhdmFkYXMgcG9yIHByaW9yaWRhZGVcbiAgICBjb25zdCBmb3JtYXNPcmRlbmFkYXMgPSBmb3JtYXNOYW9UcmF2YWRhcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCBwcmlvcmlkYWRlQSA9IFBSSU9SSURBREVfRk9STUFTLmluZGV4T2YoYS50aXBvKTtcbiAgICAgIGNvbnN0IHByaW9yaWRhZGVCID0gUFJJT1JJREFERV9GT1JNQVMuaW5kZXhPZihiLnRpcG8pO1xuICAgICAgcmV0dXJuIHByaW9yaWRhZGVBIC0gcHJpb3JpZGFkZUI7XG4gICAgfSk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ0Zvcm1hcyBvcmRlbmFkYXMgcG9yIHByaW9yaWRhZGU6JywgZm9ybWFzT3JkZW5hZGFzLm1hcChmID0+IGYudGlwbykpO1xuICAgIFxuICAgIC8vIFJlZGlzdHJpYnVpciBhIGRpZmVyZW7Dp2E6IGFwZW5hcyBhIHByaW1laXJhIGZvcm1hIG5hIG9yZGVtIGRlIHByaW9yaWRhZGUgYWJzb3J2ZSB0b2RhIGEgZGlmZXJlbsOnYVxuICAgIGNvbnN0IG5vdmFzRm9ybWFzID0gWy4uLmZvcm1hc0F0dWFpc107XG4gICAgXG4gICAgLy8gVmVyaWZpY2FyIHNlIHRvZGFzIGFzIGZvcm1hcyBuw6NvIHRyYXZhZGFzIHTDqm0gdmFsb3IgemVyb1xuICAgIGNvbnN0IHNvbWFGb3JtYXNOYW9UcmF2YWRhcyA9IGZvcm1hc09yZGVuYWRhcy5yZWR1Y2UoKGFjYywgZm9ybWEpID0+IGFjYyArIGZvcm1hLnZhbG9yLCAwKTtcbiAgICBcbiAgICBpZiAoc29tYUZvcm1hc05hb1RyYXZhZGFzID09PSAwKSB7XG4gICAgICAvLyBTZSB0b2RhcyBhcyBmb3JtYXMgbsOjbyB0cmF2YWRhcyB0w6ptIHZhbG9yIDAsIGRpc3RyaWJ1aSBpZ3VhbG1lbnRlXG4gICAgICBjb25zb2xlLmxvZygnVG9kYXMgYXMgZm9ybWFzIG7Do28gdHJhdmFkYXMgdMOqbSB2YWxvciB6ZXJvLCBkaXN0cmlidWluZG8gaWd1YWxtZW50ZScpO1xuICAgICAgY29uc3QgYWp1c3RlUG9yRm9ybWEgPSBkaWZlcmVuY2EgLyBmb3JtYXNPcmRlbmFkYXMubGVuZ3RoO1xuICAgICAgZm9ybWFzT3JkZW5hZGFzLmZvckVhY2goZm9ybWEgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYUluZGV4ID0gbm92YXNGb3JtYXMuZmluZEluZGV4KGYgPT4gZi5pZCA9PT0gZm9ybWEuaWQpO1xuICAgICAgICBjb25zdCBub3ZvVmFsb3IgPSBhanVzdGVQb3JGb3JtYTtcbiAgICAgICAgbm92YXNGb3JtYXNbZm9ybWFJbmRleF0gPSB7IC4uLm5vdmFzRm9ybWFzW2Zvcm1hSW5kZXhdLCB2YWxvcjogTWF0aC5tYXgoMCwgbm92b1ZhbG9yKSB9O1xuICAgICAgICBjb25zb2xlLmxvZyhgRm9ybWEgJHtmb3JtYS50aXBvfSBhanVzdGFkYSBwYXJhOiAke25vdm9WYWxvcn0gKGZpbmFsOiAke01hdGgubWF4KDAsIG5vdm9WYWxvcil9KWApO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFwZW5hcyBhIHByaW1laXJhIGZvcm1hIG7Do28gdHJhdmFkYSBuYSBvcmRlbSBkZSBwcmlvcmlkYWRlIGFic29ydmUgdG9kYSBhIGRpZmVyZW7Dp2FcbiAgICAgIGNvbnNvbGUubG9nKCdBanVzdGFuZG8gYXBlbmFzIGEgcHJpbWVpcmEgZm9ybWEgbmEgb3JkZW0gZGUgcHJpb3JpZGFkZScpO1xuICAgICAgY29uc3QgcHJpbWVpcmFGb3JtYSA9IGZvcm1hc09yZGVuYWRhc1swXTtcbiAgICAgIGNvbnN0IGZvcm1hSW5kZXggPSBub3Zhc0Zvcm1hcy5maW5kSW5kZXgoZiA9PiBmLmlkID09PSBwcmltZWlyYUZvcm1hLmlkKTtcbiAgICAgIGNvbnN0IHZhbG9yQ2FsY3VsYWRvID0gcHJpbWVpcmFGb3JtYS52YWxvciArIGRpZmVyZW5jYTtcbiAgICAgIGNvbnN0IG5vdm9WYWxvciA9IE1hdGgubWF4KDAsIHZhbG9yQ2FsY3VsYWRvKTtcbiAgICAgIG5vdmFzRm9ybWFzW2Zvcm1hSW5kZXhdID0geyAuLi5ub3Zhc0Zvcm1hc1tmb3JtYUluZGV4XSwgdmFsb3I6IG5vdm9WYWxvciB9O1xuICAgICAgY29uc29sZS5sb2coYEZvcm1hICR7cHJpbWVpcmFGb3JtYS50aXBvfSBhanVzdGFkYSBkZSAke3ByaW1laXJhRm9ybWEudmFsb3J9IHBhcmEgJHt2YWxvckNhbGN1bGFkb30gKGZpbmFsOiAke25vdm9WYWxvcn0pYCk7XG4gICAgICBcbiAgICAgIC8vIFNlIG8gdmFsb3IgZmljb3UgbmVnYXRpdm8sIGluZGljYXIgaW1wb3NzaWJpbGlkYWRlXG4gICAgICBpZiAodmFsb3JDYWxjdWxhZG8gPCAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gVmFsb3IgbmVnYXRpdm8gZGV0ZWN0YWRvICgke3ZhbG9yQ2FsY3VsYWRvfSksIHBvZGUgZXN0YXIgbm8gbGltaXRlIGRlIGRlc2NvbnRvIHJlYWxgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG5vdmFzRm9ybWFzO1xuICB9LCBbUFJJT1JJREFERV9GT1JNQVNdKTtcblxuICBjb25zdCByZWNhbGN1bGFyU2ltdWxhY2FvID0gdXNlQ2FsbGJhY2soKHVwZGF0ZXM6IFBhcnRpYWw8U2ltdWxhY2FvPikgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdSZWNhbGN1bGFuZG8gc2ltdWxhw6fDo28gY29tIHVwZGF0ZXM6JywgdXBkYXRlcyk7XG4gICAgXG4gICAgc2V0U2ltdWxhY2FvKHByZXYgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZCA9IHsgLi4ucHJldiwgLi4udXBkYXRlcyB9O1xuICAgICAgXG4gICAgICAvLyBWZXJpZmljYXIgc2UgbyBkZXNjb250byByZWFsIGVzdMOhIHRyYXZhZG9cbiAgICAgIGlmICh1cGRhdGVkLnRyYXZhbWVudG9zLmRlc2NvbnRvUmVhbEZpeG8pIHtcbiAgICAgICAgY29uc3QgZGVzY29udG9SZWFsRml4byA9IHVwZGF0ZWQudHJhdmFtZW50b3MudmFsb3JEZXNjb250b1JlYWxGaXhvO1xuICAgICAgICBjb25zb2xlLmxvZyhgRGVzY29udG8gcmVhbCB0cmF2YWRvIGVtICR7ZGVzY29udG9SZWFsRml4b30lLCBhanVzdGFuZG8gdmFsb3IgbmVnb2NpYWRvYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhciBvIHZhbG9yIHJlY2ViaWRvIG5lY2Vzc8OhcmlvIHBhcmEgbWFudGVyIG8gZGVzY29udG8gZml4b1xuICAgICAgICBjb25zdCB2YWxvclJlY2ViaWRvTmVjZXNzYXJpbyA9IHVwZGF0ZWQudmFsb3JCcnV0byAqICgxIC0gZGVzY29udG9SZWFsRml4byAvIDEwMCk7XG4gICAgICAgIFxuICAgICAgICAvLyBFbmNvbnRyYXIgbyB2YWxvciBuZWdvY2lhZG8gcXVlIHJlc3VsdGUgbmVzc2UgdmFsb3IgcmVjZWJpZG9cbiAgICAgICAgLy8gLi4uIGltcGxlbWVudGFyIGzDs2dpY2EgZGUgYnVzY2EgcmV2ZXJzYVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEzDs2dpY2EgZGUgdHJhdmFtZW50byBkbyB2YWxvciBuZWdvY2lhZG9cbiAgICAgIGlmICh1cGRhdGVkLnRyYXZhbWVudG9zLnZhbG9yTmVnb2NpYWRvKSB7XG4gICAgICAgIC8vIFNlIHZhbG9yIG5lZ29jaWFkbyBlc3TDoSB0cmF2YWRvLCBhanVzdGEgbyBkZXNjb250byBxdWFuZG8gdmFsb3IgYnJ1dG8gbXVkYVxuICAgICAgICBpZiAodXBkYXRlcy52YWxvckJydXRvICE9PSB1bmRlZmluZWQgJiYgdXBkYXRlcy52YWxvckJydXRvID4gMCkge1xuICAgICAgICAgIHVwZGF0ZWQuZGVzY29udG8gPSAoKHVwZGF0ZWQudmFsb3JCcnV0byAtIHVwZGF0ZWQudmFsb3JOZWdvY2lhZG8pIC8gdXBkYXRlZC52YWxvckJydXRvKSAqIDEwMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29tcG9ydGFtZW50byBub3JtYWw6IGNhbGN1bGEgdmFsb3IgbmVnb2NpYWRvIGJhc2VhZG8gbm8gZGVzY29udG9cbiAgICAgICAgdXBkYXRlZC52YWxvck5lZ29jaWFkbyA9IHVwZGF0ZWQudmFsb3JCcnV0byAqICgxIC0gdXBkYXRlZC5kZXNjb250byAvIDEwMCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHVwZGF0ZWQuZm9ybWFzUGFnYW1lbnRvID0gdXBkYXRlZC5mb3JtYXNQYWdhbWVudG8ubWFwKGZvcm1hID0+ICh7XG4gICAgICAgIC4uLmZvcm1hLFxuICAgICAgICB2YWxvclJlY2ViaWRvOiBjYWxjdWxhclZhbG9yUmVjZWJpZG9Gb3JtYShmb3JtYSlcbiAgICAgIH0pKTtcbiAgICAgIFxuICAgICAgdXBkYXRlZC52YWxvclJlY2ViaWRvVG90YWwgPSB1cGRhdGVkLmZvcm1hc1BhZ2FtZW50by5yZWR1Y2UoKGFjYywgZm9ybWEpID0+IGFjYyArIGZvcm1hLnZhbG9yUmVjZWJpZG8sIDApO1xuICAgICAgdXBkYXRlZC5kZXNjb250b1JlYWwgPSB1cGRhdGVkLnZhbG9yQnJ1dG8gPiAwID8gKCh1cGRhdGVkLnZhbG9yQnJ1dG8gLSB1cGRhdGVkLnZhbG9yUmVjZWJpZG9Ub3RhbCkgLyB1cGRhdGVkLnZhbG9yQnJ1dG8pICogMTAwIDogMDtcbiAgICAgIFxuICAgICAgY29uc3Qgc29tYUZvcm1hcyA9IHVwZGF0ZWQuZm9ybWFzUGFnYW1lbnRvLnJlZHVjZSgoYWNjLCBmb3JtYSkgPT4gYWNjICsgZm9ybWEudmFsb3IsIDApO1xuICAgICAgdXBkYXRlZC52YWxvclJlc3RhbnRlID0gdXBkYXRlZC52YWxvck5lZ29jaWFkbyAtIHNvbWFGb3JtYXM7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdTaW11bGHDp8OjbyBhdHVhbGl6YWRhOicsIHVwZGF0ZWQpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfSk7XG4gIH0sIFtjYWxjdWxhclZhbG9yUmVjZWJpZG9Gb3JtYV0pO1xuXG4gIGNvbnN0IGVkaXRhclZhbG9yTmVnb2NpYWRvID0gdXNlQ2FsbGJhY2soKG5vdm9WYWxvcjogbnVtYmVyKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0VkaXRhbmRvIHZhbG9yIG5lZ29jaWFkbyBwYXJhOicsIG5vdm9WYWxvcik7XG4gICAgXG4gICAgc2V0U2ltdWxhY2FvKHByZXYgPT4ge1xuICAgICAgY29uc3QgZm9ybWFzUmVkaXN0cmlidWlkYXMgPSByZWRpc3RyaWJ1aXJWYWxvcmVzKG5vdm9WYWxvciwgcHJldi5mb3JtYXNQYWdhbWVudG8pO1xuICAgICAgXG4gICAgICBpZiAoIWZvcm1hc1JlZGlzdHJpYnVpZGFzKSB7XG4gICAgICAgIGFsZXJ0KCdOw6NvIMOpIHBvc3PDrXZlbCBhbHRlcmFyIG8gdmFsb3IuIFRvZGFzIGFzIGZvcm1hcyBkZSBwYWdhbWVudG8gZXN0w6NvIHRyYXZhZGFzLicpO1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgdXBkYXRlZCA9IHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgdmFsb3JOZWdvY2lhZG86IG5vdm9WYWxvcixcbiAgICAgICAgZm9ybWFzUGFnYW1lbnRvOiBmb3JtYXNSZWRpc3RyaWJ1aWRhcy5tYXAoZm9ybWEgPT4gKHtcbiAgICAgICAgICAuLi5mb3JtYSxcbiAgICAgICAgICB2YWxvclJlY2ViaWRvOiBjYWxjdWxhclZhbG9yUmVjZWJpZG9Gb3JtYShmb3JtYSlcbiAgICAgICAgfSkpXG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBSZWNhbGN1bGFyIGRlc2NvbnRvXG4gICAgICB1cGRhdGVkLmRlc2NvbnRvID0gdXBkYXRlZC52YWxvckJydXRvID4gMCA/ICgodXBkYXRlZC52YWxvckJydXRvIC0gdXBkYXRlZC52YWxvck5lZ29jaWFkbykgLyB1cGRhdGVkLnZhbG9yQnJ1dG8pICogMTAwIDogMDtcbiAgICAgIFxuICAgICAgdXBkYXRlZC52YWxvclJlY2ViaWRvVG90YWwgPSB1cGRhdGVkLmZvcm1hc1BhZ2FtZW50by5yZWR1Y2UoKGFjYywgZm9ybWEpID0+IGFjYyArIGZvcm1hLnZhbG9yUmVjZWJpZG8sIDApO1xuICAgICAgdXBkYXRlZC5kZXNjb250b1JlYWwgPSB1cGRhdGVkLnZhbG9yQnJ1dG8gPiAwID8gKCh1cGRhdGVkLnZhbG9yQnJ1dG8gLSB1cGRhdGVkLnZhbG9yUmVjZWJpZG9Ub3RhbCkgLyB1cGRhdGVkLnZhbG9yQnJ1dG8pICogMTAwIDogMDtcbiAgICAgIFxuICAgICAgY29uc3Qgc29tYUZvcm1hcyA9IHVwZGF0ZWQuZm9ybWFzUGFnYW1lbnRvLnJlZHVjZSgoYWNjLCBmb3JtYSkgPT4gYWNjICsgZm9ybWEudmFsb3IsIDApO1xuICAgICAgdXBkYXRlZC52YWxvclJlc3RhbnRlID0gdXBkYXRlZC52YWxvck5lZ29jaWFkbyAtIHNvbWFGb3JtYXM7XG4gICAgICBcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0pO1xuICB9LCBbcmVkaXN0cmlidWlyVmFsb3JlcywgY2FsY3VsYXJWYWxvclJlY2ViaWRvRm9ybWFdKTtcblxuICBjb25zdCBlZGl0YXJEZXNjb250b1JlYWwgPSB1c2VDYWxsYmFjaygobm92b0Rlc2NvbnRvUmVhbDogbnVtYmVyLCBzaG91bGRMb2NrPzogYm9vbGVhbikgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdFZGl0YW5kbyBkZXNjb250byByZWFsIHBhcmE6Jywgbm92b0Rlc2NvbnRvUmVhbCwgJ1RyYXZhcjonLCBzaG91bGRMb2NrKTtcbiAgICBcbiAgICBzZXRTaW11bGFjYW8ocHJldiA9PiB7XG4gICAgICAvLyBTZSBzaG91bGRMb2NrIMOpIHZlcmRhZGVpcm8sIGF0aXZhciBvIHRyYXZhbWVudG9cbiAgICAgIGlmIChzaG91bGRMb2NrKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICB0cmF2YW1lbnRvczoge1xuICAgICAgICAgICAgLi4ucHJldi50cmF2YW1lbnRvcyxcbiAgICAgICAgICAgIGRlc2NvbnRvUmVhbEZpeG86IHRydWUsXG4gICAgICAgICAgICB2YWxvckRlc2NvbnRvUmVhbEZpeG86IG5vdm9EZXNjb250b1JlYWxcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEzDs2dpY2EgZXhpc3RlbnRlIGRhIGJ1c2NhIGJpbsOhcmlhLi4uXG4gICAgICBjb25zdCBjYWxjdWxhckRlc2NvbnRvUmVhbFBhcmFWYWxvciA9ICh2YWxvck5lZ29jaWFkbzogbnVtYmVyKTogbnVtYmVyID0+IHtcbiAgICAgICAgY29uc3QgZm9ybWFzVGVtcCA9IHJlZGlzdHJpYnVpclZhbG9yZXModmFsb3JOZWdvY2lhZG8sIHByZXYuZm9ybWFzUGFnYW1lbnRvKTtcbiAgICAgICAgaWYgKCFmb3JtYXNUZW1wKSByZXR1cm4gLTE7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB2YWxvclJlY2ViaWRvVGVtcCA9IGZvcm1hc1RlbXAucmVkdWNlKChhY2MsIGZvcm1hKSA9PiB7XG4gICAgICAgICAgY29uc3QgZm9ybWFDb21SZWNlYmlkbyA9IHsgLi4uZm9ybWEsIHZhbG9yUmVjZWJpZG86IGNhbGN1bGFyVmFsb3JSZWNlYmlkb0Zvcm1hKGZvcm1hKSB9O1xuICAgICAgICAgIHJldHVybiBhY2MgKyBmb3JtYUNvbVJlY2ViaWRvLnZhbG9yUmVjZWJpZG87XG4gICAgICAgIH0sIDApO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHByZXYudmFsb3JCcnV0byA+IDAgPyAoKHByZXYudmFsb3JCcnV0byAtIHZhbG9yUmVjZWJpZG9UZW1wKSAvIHByZXYudmFsb3JCcnV0bykgKiAxMDAgOiAwO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gQnVzY2EgYmluw6FyaWEgcGFyYSBlbmNvbnRyYXIgbyB2YWxvciBuZWdvY2lhZG8gcXVlIHJlc3VsdGEgbm8gZGVzY29udG8gcmVhbCBkZXNlamFkb1xuICAgICAgbGV0IHZhbG9yTWluID0gMDtcbiAgICAgIGxldCB2YWxvck1heCA9IHByZXYudmFsb3JCcnV0bztcbiAgICAgIGxldCB2YWxvck5lZ29jaWFkb090aW1vID0gcHJldi52YWxvck5lZ29jaWFkbztcbiAgICAgIGxldCBtZWxob3JEaWZlcmVuY2EgPSBJbmZpbml0eTtcbiAgICAgIGxldCBtZWxob3JEZXNjb250byA9IHByZXYuZGVzY29udG9SZWFsO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg8J+OryBJbmljaWFuZG8gYnVzY2EgYmluw6FyaWEgcGFyYSBkZXNjb250byByZWFsOiAke25vdm9EZXNjb250b1JlYWx9JWApO1xuICAgICAgY29uc29sZS5sb2coYERlc2NvbnRvIHJlYWwgYXR1YWw6ICR7cHJldi5kZXNjb250b1JlYWx9JWApO1xuICAgICAgY29uc29sZS5sb2coYEludGVydmFsbyBpbmljaWFsOiAke3ZhbG9yTWlufSAtICR7dmFsb3JNYXh9YCk7XG4gICAgICBcbiAgICAgIC8vIE3DoXhpbW8gZGUgMjUgaXRlcmHDp8O1ZXMgcGFyYSBtYWlvciBwcmVjaXPDo29cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU7IGkrKykge1xuICAgICAgICBjb25zdCB2YWxvclRlc3RlID0gKHZhbG9yTWluICsgdmFsb3JNYXgpIC8gMjtcbiAgICAgICAgY29uc3QgZGVzY29udG9SZWFsQ2FsY3VsYWRvID0gY2FsY3VsYXJEZXNjb250b1JlYWxQYXJhVmFsb3IodmFsb3JUZXN0ZSk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgSXRlcmHDp8OjbyAke2kgKyAxfTogdmFsb3JUZXN0ZT0ke3ZhbG9yVGVzdGUudG9GaXhlZCgyKX0sIGRlc2NvbnRvPSR7ZGVzY29udG9SZWFsQ2FsY3VsYWRvLnRvRml4ZWQoMil9JWApO1xuICAgICAgICBcbiAgICAgICAgaWYgKGRlc2NvbnRvUmVhbENhbGN1bGFkbyA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBFcnJvIG5hIHJlZGlzdHJpYnVpw6fDo28sIHRlbnRhciB2YWxvciBtYWlvclxuICAgICAgICAgIGNvbnNvbGUubG9nKCfinYwgRXJybyBuYSByZWRpc3RyaWJ1acOnw6NvLCBhanVzdGFuZG8gdmFsb3IgbcOtbmltbycpO1xuICAgICAgICAgIHZhbG9yTWluID0gdmFsb3JUZXN0ZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgZGlmZXJlbmNhID0gTWF0aC5hYnMoZGVzY29udG9SZWFsQ2FsY3VsYWRvIC0gbm92b0Rlc2NvbnRvUmVhbCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTZSBlbmNvbnRyb3UgdW0gcmVzdWx0YWRvIG1lbGhvciwgZ3VhcmRhclxuICAgICAgICBpZiAoZGlmZXJlbmNhIDwgbWVsaG9yRGlmZXJlbmNhKSB7XG4gICAgICAgICAgbWVsaG9yRGlmZXJlbmNhID0gZGlmZXJlbmNhO1xuICAgICAgICAgIHZhbG9yTmVnb2NpYWRvT3RpbW8gPSB2YWxvclRlc3RlO1xuICAgICAgICAgIG1lbGhvckRlc2NvbnRvID0gZGVzY29udG9SZWFsQ2FsY3VsYWRvO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgTm92byBtZWxob3IgcmVzdWx0YWRvOiBkZXNjb250bz0ke21lbGhvckRlc2NvbnRvLnRvRml4ZWQoMil9JSwgZGlmZXJlbsOnYT0ke21lbGhvckRpZmVyZW5jYS50b0ZpeGVkKDIpfWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTZSBhIGRpZmVyZW7Dp2Egw6kgbXVpdG8gcGVxdWVuYSwgcGFyYXJcbiAgICAgICAgaWYgKGRpZmVyZW5jYSA8IDAuMDUpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+OryBQcmVjaXPDo28gYXRpbmdpZGEhIFBhcmFuZG8gYnVzY2EuYCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIERldGVjdGFyIHNlIGVzdGFtb3Mgbm8gbGltaXRlIGbDrXNpY29cbiAgICAgICAgaWYgKGkgPiAxMCAmJiBtZWxob3JEaWZlcmVuY2EgPiAyKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBQb3Nzw612ZWwgbGltaXRlIGbDrXNpY28gZGV0ZWN0YWRvLiBNZWxob3IgZGVzY29udG8gcG9zc8OtdmVsOiAke21lbGhvckRlc2NvbnRvLnRvRml4ZWQoMil9JWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBBanVzdGFyIG9zIGxpbWl0ZXMgZGEgYnVzY2FcbiAgICAgICAgaWYgKGRlc2NvbnRvUmVhbENhbGN1bGFkbyA8IG5vdm9EZXNjb250b1JlYWwpIHtcbiAgICAgICAgICAvLyBEZXNjb250byBjYWxjdWxhZG8gw6kgbWVub3IgcXVlIG8gZGVzZWphZG8sIHByZWNpc2Ftb3MgZGltaW51aXIgdmFsb3IgbmVnb2NpYWRvXG4gICAgICAgICAgdmFsb3JNYXggPSB2YWxvclRlc3RlO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OJIERlc2NvbnRvIGJhaXhvICgke2Rlc2NvbnRvUmVhbENhbGN1bGFkby50b0ZpeGVkKDIpfSUgPCAke25vdm9EZXNjb250b1JlYWx9JSksIGRpbWludWluZG8gdmFsb3JNYXggcGFyYSAke3ZhbG9yTWF4LnRvRml4ZWQoMil9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGVzY29udG8gY2FsY3VsYWRvIMOpIG1haW9yIHF1ZSBvIGRlc2VqYWRvLCBwcmVjaXNhbW9zIGF1bWVudGFyIHZhbG9yIG5lZ29jaWFkb1xuICAgICAgICAgIHZhbG9yTWluID0gdmFsb3JUZXN0ZTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiCBEZXNjb250byBhbHRvICgke2Rlc2NvbnRvUmVhbENhbGN1bGFkby50b0ZpeGVkKDIpfSUgPiAke25vdm9EZXNjb250b1JlYWx9JSksIGF1bWVudGFuZG8gdmFsb3JNaW4gcGFyYSAke3ZhbG9yTWluLnRvRml4ZWQoMil9YCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFZlcmlmaWNhciBzZSBvIGludGVydmFsbyBmaWNvdSBtdWl0byBwZXF1ZW5vXG4gICAgICAgIGlmIChNYXRoLmFicyh2YWxvck1heCAtIHZhbG9yTWluKSA8IDEwMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEludGVydmFsbyBtdWl0byBwZXF1ZW5vICgke01hdGguYWJzKHZhbG9yTWF4IC0gdmFsb3JNaW4pLnRvRml4ZWQoMil9KSwgZmluYWxpemFuZG8gYnVzY2FgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg8J+PgSBCdXNjYSBmaW5hbGl6YWRhOmApO1xuICAgICAgY29uc29sZS5sb2coYCAgIFZhbG9yIG5lZ29jaWFkbyDDs3RpbW86ICR7dmFsb3JOZWdvY2lhZG9PdGltby50b0ZpeGVkKDIpfWApO1xuICAgICAgY29uc29sZS5sb2coYCAgIERlc2NvbnRvIHJlYWwgcmVzdWx0YW50ZTogJHttZWxob3JEZXNjb250by50b0ZpeGVkKDIpfSVgKTtcbiAgICAgIGNvbnNvbGUubG9nKGAgICBEaWZlcmVuw6dhIGRvIG9iamV0aXZvOiAke21lbGhvckRpZmVyZW5jYS50b0ZpeGVkKDIpfWApO1xuICAgICAgXG4gICAgICAvLyBTZSBhIGRpZmVyZW7Dp2EgYWluZGEgw6kgbXVpdG8gZ3JhbmRlLCBhdmlzYXIgbyB1c3XDoXJpb1xuICAgICAgaWYgKG1lbGhvckRpZmVyZW5jYSA+IDEpIHtcbiAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBOw6NvIGZvaSBwb3Nzw612ZWwgYXRpbmdpciBleGF0YW1lbnRlICR7bm92b0Rlc2NvbnRvUmVhbH0lLiBNZWxob3IgcmVzdWx0YWRvOiAke21lbGhvckRlc2NvbnRvLnRvRml4ZWQoMSl9JWApO1xuICAgICAgICBjb25zdCBjb25maXJtYXIgPSBjb25maXJtKGBOw6NvIGZvaSBwb3Nzw612ZWwgYXRpbmdpciBleGF0YW1lbnRlICR7bm92b0Rlc2NvbnRvUmVhbH0lIGRlIGRlc2NvbnRvIHJlYWwuXFxuTWVsaG9yIHJlc3VsdGFkbyBwb3Nzw612ZWw6ICR7bWVsaG9yRGVzY29udG8udG9GaXhlZCgxKX0lXFxuXFxuRGVzZWphIGFwbGljYXIgbWVzbW8gYXNzaW0/YCk7XG4gICAgICAgIGlmICghY29uZmlybWFyKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQXBsaWNhciBvIHZhbG9yIG5lZ29jaWFkbyDDs3RpbW8gZW5jb250cmFkb1xuICAgICAgY29uc3QgZm9ybWFzUmVkaXN0cmlidWlkYXMgPSByZWRpc3RyaWJ1aXJWYWxvcmVzKHZhbG9yTmVnb2NpYWRvT3RpbW8sIHByZXYuZm9ybWFzUGFnYW1lbnRvKTtcbiAgICAgIFxuICAgICAgaWYgKCFmb3JtYXNSZWRpc3RyaWJ1aWRhcykge1xuICAgICAgICBhbGVydCgnTsOjbyDDqSBwb3Nzw612ZWwgYWx0ZXJhciBvIGRlc2NvbnRvIHJlYWwuIFRvZGFzIGFzIGZvcm1hcyBkZSBwYWdhbWVudG8gZXN0w6NvIHRyYXZhZGFzLicpO1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTm8gZmluYWwsIGF0dWFsaXphciBvIHRyYXZhbWVudG8gc2UgbmVjZXNzw6FyaW9cbiAgICAgIGNvbnN0IHVwZGF0ZWQgPSB7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIHZhbG9yTmVnb2NpYWRvOiB2YWxvck5lZ29jaWFkb090aW1vLFxuICAgICAgICBmb3JtYXNQYWdhbWVudG86IGZvcm1hc1JlZGlzdHJpYnVpZGFzLm1hcChmb3JtYSA9PiAoe1xuICAgICAgICAgIC4uLmZvcm1hLFxuICAgICAgICAgIHZhbG9yUmVjZWJpZG86IGNhbGN1bGFyVmFsb3JSZWNlYmlkb0Zvcm1hKGZvcm1hKVxuICAgICAgICB9KSksXG4gICAgICAgIHRyYXZhbWVudG9zOiB7XG4gICAgICAgICAgLi4ucHJldi50cmF2YW1lbnRvcyxcbiAgICAgICAgICBkZXNjb250b1JlYWxGaXhvOiBzaG91bGRMb2NrIHx8IGZhbHNlLFxuICAgICAgICAgIHZhbG9yRGVzY29udG9SZWFsRml4bzogc2hvdWxkTG9jayA/IG5vdm9EZXNjb250b1JlYWwgOiBwcmV2LnRyYXZhbWVudG9zLnZhbG9yRGVzY29udG9SZWFsRml4b1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBSZWNhbGN1bGFyIHZhbG9yZXMgZGVyaXZhZG9zXG4gICAgICB1cGRhdGVkLnZhbG9yUmVjZWJpZG9Ub3RhbCA9IHVwZGF0ZWQuZm9ybWFzUGFnYW1lbnRvLnJlZHVjZSgoYWNjLCBmb3JtYSkgPT4gYWNjICsgZm9ybWEudmFsb3JSZWNlYmlkbywgMCk7XG4gICAgICB1cGRhdGVkLmRlc2NvbnRvUmVhbCA9IHVwZGF0ZWQudmFsb3JCcnV0byA+IDAgPyAoKHVwZGF0ZWQudmFsb3JCcnV0byAtIHVwZGF0ZWQudmFsb3JSZWNlYmlkb1RvdGFsKSAvIHVwZGF0ZWQudmFsb3JCcnV0bykgKiAxMDAgOiAwO1xuICAgICAgXG4gICAgICBjb25zdCBzb21hRm9ybWFzID0gdXBkYXRlZC5mb3JtYXNQYWdhbWVudG8ucmVkdWNlKChhY2MsIGZvcm1hKSA9PiBhY2MgKyBmb3JtYS52YWxvciwgMCk7XG4gICAgICB1cGRhdGVkLnZhbG9yUmVzdGFudGUgPSB1cGRhdGVkLnZhbG9yTmVnb2NpYWRvIC0gc29tYUZvcm1hcztcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1NpbXVsYcOnw6NvIGF0dWFsaXphZGEgdmlhIGRlc2NvbnRvIHJlYWw6JywgdXBkYXRlZCk7XG4gICAgICBjb25zb2xlLmxvZyhgRGVzY29udG8gcmVhbCByZXN1bHRhbnRlOiAke3VwZGF0ZWQuZGVzY29udG9SZWFsfSVgKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfSk7XG4gIH0sIFtyZWRpc3RyaWJ1aXJWYWxvcmVzLCBjYWxjdWxhclZhbG9yUmVjZWJpZG9Gb3JtYV0pO1xuXG4gIGNvbnN0IGVkaXRhclZhbG9yQnJ1dG8gPSB1c2VDYWxsYmFjaygobm92b1ZhbG9yOiBudW1iZXIpID0+IHtcbiAgICBjb25zb2xlLmxvZygnRWRpdGFuZG8gdmFsb3IgYnJ1dG8gcGFyYTonLCBub3ZvVmFsb3IpO1xuICAgIHJlY2FsY3VsYXJTaW11bGFjYW8oeyB2YWxvckJydXRvOiBub3ZvVmFsb3IgfSk7XG4gIH0sIFtyZWNhbGN1bGFyU2ltdWxhY2FvXSk7XG5cbiAgY29uc3QgYWRpY2lvbmFyRm9ybWEgPSB1c2VDYWxsYmFjaygoZm9ybWE6IE9taXQ8Rm9ybWFQYWdhbWVudG8sICdpZCcgfCAndmFsb3JSZWNlYmlkbyc+KSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0FkaWNpb25hbmRvIGZvcm1hOicsIGZvcm1hKTtcbiAgICBcbiAgICBzZXRTaW11bGFjYW8ocHJldiA9PiB7XG4gICAgICAvLyBWZXJpZmljYXIgdHJhdmFtZW50byBkZSBkZXNjb250byByZWFsXG4gICAgICBpZiAocHJldi50cmF2YW1lbnRvcy5kZXNjb250b1JlYWwpIHtcbiAgICAgICAgY29uc3Qgbm92YUZvcm1hVGVtcDogRm9ybWFQYWdhbWVudG8gPSB7XG4gICAgICAgICAgLi4uZm9ybWEsXG4gICAgICAgICAgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSxcbiAgICAgICAgICB2YWxvclJlY2ViaWRvOiAwXG4gICAgICAgIH07XG4gICAgICAgIG5vdmFGb3JtYVRlbXAudmFsb3JSZWNlYmlkbyA9IGNhbGN1bGFyVmFsb3JSZWNlYmlkb0Zvcm1hKG5vdmFGb3JtYVRlbXApO1xuICAgICAgICBcbiAgICAgICAgY29uc3Qgbm92b1ZhbG9yUmVjZWJpZG9Ub3RhbCA9IHByZXYudmFsb3JSZWNlYmlkb1RvdGFsICsgbm92YUZvcm1hVGVtcC52YWxvclJlY2ViaWRvO1xuICAgICAgICBjb25zdCBub3ZvRGVzY29udG9SZWFsID0gcHJldi52YWxvckJydXRvID4gMCA/ICgocHJldi52YWxvckJydXRvIC0gbm92b1ZhbG9yUmVjZWJpZG9Ub3RhbCkgLyBwcmV2LnZhbG9yQnJ1dG8pICogMTAwIDogMDtcbiAgICAgICAgXG4gICAgICAgIGlmIChub3ZvRGVzY29udG9SZWFsID4gcHJldi50cmF2YW1lbnRvcy5saW1pdGVEZXNjb250b1JlYWwpIHtcbiAgICAgICAgICBhbGVydChgTsOjbyDDqSBwb3Nzw612ZWwgYWRpY2lvbmFyIGVzdGEgZm9ybWEuIE8gZGVzY29udG8gcmVhbCBleGNlZGVyaWEgbyBsaW1pdGUgZGUgJHtwcmV2LnRyYXZhbWVudG9zLmxpbWl0ZURlc2NvbnRvUmVhbH0lYCk7XG4gICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3Qgbm92YUZvcm1hOiBGb3JtYVBhZ2FtZW50byA9IHtcbiAgICAgICAgLi4uZm9ybWEsXG4gICAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXG4gICAgICAgIHZhbG9yUmVjZWJpZG86IDAsXG4gICAgICAgIHRyYXZhZG86IGZhbHNlXG4gICAgICB9O1xuICAgICAgXG4gICAgICBub3ZhRm9ybWEudmFsb3JSZWNlYmlkbyA9IGNhbGN1bGFyVmFsb3JSZWNlYmlkb0Zvcm1hKG5vdmFGb3JtYSk7XG4gICAgICBcbiAgICAgIGNvbnN0IG5vdmFzRm9ybWFzID0gWy4uLnByZXYuZm9ybWFzUGFnYW1lbnRvLCBub3ZhRm9ybWFdO1xuICAgICAgY29uc3QgdXBkYXRlZCA9IHsgLi4ucHJldiwgZm9ybWFzUGFnYW1lbnRvOiBub3Zhc0Zvcm1hcyB9O1xuICAgICAgXG4gICAgICB1cGRhdGVkLnZhbG9yUmVjZWJpZG9Ub3RhbCA9IG5vdmFzRm9ybWFzLnJlZHVjZSgoYWNjLCBmKSA9PiBhY2MgKyBmLnZhbG9yUmVjZWJpZG8sIDApO1xuICAgICAgdXBkYXRlZC5kZXNjb250b1JlYWwgPSB1cGRhdGVkLnZhbG9yQnJ1dG8gPiAwID8gKCh1cGRhdGVkLnZhbG9yQnJ1dG8gLSB1cGRhdGVkLnZhbG9yUmVjZWJpZG9Ub3RhbCkgLyB1cGRhdGVkLnZhbG9yQnJ1dG8pICogMTAwIDogMDtcbiAgICAgIFxuICAgICAgY29uc3Qgc29tYUZvcm1hcyA9IG5vdmFzRm9ybWFzLnJlZHVjZSgoYWNjLCBmKSA9PiBhY2MgKyBmLnZhbG9yLCAwKTtcbiAgICAgIHVwZGF0ZWQudmFsb3JSZXN0YW50ZSA9IHVwZGF0ZWQudmFsb3JOZWdvY2lhZG8gLSBzb21hRm9ybWFzO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnTm92YSBzaW11bGHDp8OjbyBjb20gZm9ybWEgYWRpY2lvbmFkYTonLCB1cGRhdGVkKTtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0pO1xuICB9LCBbY2FsY3VsYXJWYWxvclJlY2ViaWRvRm9ybWFdKTtcblxuICBjb25zdCBhdHVhbGl6YXJGb3JtYSA9IHVzZUNhbGxiYWNrKChpZDogc3RyaW5nLCBkYWRvc0F0dWFsaXphZG9zOiBPbWl0PEZvcm1hUGFnYW1lbnRvLCAnaWQnIHwgJ3ZhbG9yUmVjZWJpZG8nPikgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdBdHVhbGl6YW5kbyBmb3JtYTonLCBpZCwgZGFkb3NBdHVhbGl6YWRvcyk7XG4gICAgXG4gICAgc2V0U2ltdWxhY2FvKHByZXYgPT4ge1xuICAgICAgY29uc3Qgbm92YXNGb3JtYXMgPSBwcmV2LmZvcm1hc1BhZ2FtZW50by5tYXAoZm9ybWEgPT4ge1xuICAgICAgICBpZiAoZm9ybWEuaWQgPT09IGlkKSB7XG4gICAgICAgICAgLy8gU2UgYSBmb3JtYSBlc3TDoSB0cmF2YWRhLCBuw6NvIHBlcm1pdGUgYWx0ZXJhciBvIHZhbG9yXG4gICAgICAgICAgaWYgKGZvcm1hLnRyYXZhZG8gJiYgZGFkb3NBdHVhbGl6YWRvcy52YWxvciAhPT0gZm9ybWEudmFsb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3JtYSB0cmF2YWRhLCBuw6NvIMOpIHBvc3PDrXZlbCBhbHRlcmFyIG8gdmFsb3InKTtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgZm9ybWFBdHVhbGl6YWRhID0geyAuLi5mb3JtYSwgLi4uZGFkb3NBdHVhbGl6YWRvcyB9O1xuICAgICAgICAgIGZvcm1hQXR1YWxpemFkYS52YWxvclJlY2ViaWRvID0gY2FsY3VsYXJWYWxvclJlY2ViaWRvRm9ybWEoZm9ybWFBdHVhbGl6YWRhKTtcbiAgICAgICAgICByZXR1cm4gZm9ybWFBdHVhbGl6YWRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB1cGRhdGVkID0geyAuLi5wcmV2LCBmb3JtYXNQYWdhbWVudG86IG5vdmFzRm9ybWFzIH07XG4gICAgICBcbiAgICAgIHVwZGF0ZWQudmFsb3JSZWNlYmlkb1RvdGFsID0gbm92YXNGb3JtYXMucmVkdWNlKChhY2MsIGYpID0+IGFjYyArIGYudmFsb3JSZWNlYmlkbywgMCk7XG4gICAgICB1cGRhdGVkLmRlc2NvbnRvUmVhbCA9IHVwZGF0ZWQudmFsb3JCcnV0byA+IDAgPyAoKHVwZGF0ZWQudmFsb3JCcnV0byAtIHVwZGF0ZWQudmFsb3JSZWNlYmlkb1RvdGFsKSAvIHVwZGF0ZWQudmFsb3JCcnV0bykgKiAxMDAgOiAwO1xuICAgICAgXG4gICAgICBjb25zdCBzb21hRm9ybWFzID0gbm92YXNGb3JtYXMucmVkdWNlKChhY2MsIGYpID0+IGFjYyArIGYudmFsb3IsIDApO1xuICAgICAgdXBkYXRlZC52YWxvclJlc3RhbnRlID0gdXBkYXRlZC52YWxvck5lZ29jaWFkbyAtIHNvbWFGb3JtYXM7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdTaW11bGHDp8OjbyBhdHVhbGl6YWRhIGFww7NzIGVkacOnw6NvOicsIHVwZGF0ZWQpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfSk7XG4gIH0sIFtjYWxjdWxhclZhbG9yUmVjZWJpZG9Gb3JtYV0pO1xuXG4gIGNvbnN0IHJlbW92ZXJGb3JtYSA9IHVzZUNhbGxiYWNrKChpZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1JlbW92ZW5kbyBmb3JtYTonLCBpZCk7XG4gICAgXG4gICAgc2V0U2ltdWxhY2FvKHByZXYgPT4ge1xuICAgICAgY29uc3Qgbm92YXNGb3JtYXMgPSBwcmV2LmZvcm1hc1BhZ2FtZW50by5maWx0ZXIoZiA9PiBmLmlkICE9PSBpZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBmb3JtYXNQYWdhbWVudG86IG5vdmFzRm9ybWFzLFxuICAgICAgICB2YWxvclJlY2ViaWRvVG90YWw6IG5vdmFzRm9ybWFzLnJlZHVjZSgoYWNjLCBmKSA9PiBhY2MgKyBmLnZhbG9yUmVjZWJpZG8sIDApLFxuICAgICAgICBkZXNjb250b1JlYWw6IHByZXYudmFsb3JCcnV0byA+IDAgPyAoKHByZXYudmFsb3JCcnV0byAtIG5vdmFzRm9ybWFzLnJlZHVjZSgoYWNjLCBmKSA9PiBhY2MgKyBmLnZhbG9yUmVjZWJpZG8sIDApKSAvIHByZXYudmFsb3JCcnV0bykgKiAxMDAgOiAwLFxuICAgICAgICB2YWxvclJlc3RhbnRlOiBwcmV2LnZhbG9yTmVnb2NpYWRvIC0gbm92YXNGb3JtYXMucmVkdWNlKChhY2MsIGYpID0+IGFjYyArIGYudmFsb3IsIDApXG4gICAgICB9O1xuICAgIH0pO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgbGltcGFyRm9ybWFzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdMaW1wYW5kbyB0b2RhcyBhcyBmb3JtYXMnKTtcbiAgICBzZXRTaW11bGFjYW8ocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIGZvcm1hc1BhZ2FtZW50bzogW10sXG4gICAgICB2YWxvclJlY2ViaWRvVG90YWw6IDAsXG4gICAgICBkZXNjb250b1JlYWw6IHByZXYudmFsb3JCcnV0byA+IDAgPyAxMDAgOiAwLFxuICAgICAgdmFsb3JSZXN0YW50ZTogcHJldi52YWxvck5lZ29jaWFkb1xuICAgIH0pKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGFsdGVybmFyVHJhdmFtZW50byA9IHVzZUNhbGxiYWNrKCh0aXBvOiBrZXlvZiBUcmF2YW1lbnRvQ29uZmlnLCB2YWxvcj86IG51bWJlcikgPT4ge1xuICAgIHNldFNpbXVsYWNhbyhwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgdHJhdmFtZW50b3M6IHtcbiAgICAgICAgLi4ucHJldi50cmF2YW1lbnRvcyxcbiAgICAgICAgW3RpcG9dOiAhcHJldi50cmF2YW1lbnRvc1t0aXBvXSxcbiAgICAgICAgLi4uKHZhbG9yICE9PSB1bmRlZmluZWQgJiYgeyBsaW1pdGVEZXNjb250b1JlYWw6IHZhbG9yIH0pXG4gICAgICB9XG4gICAgfSkpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgYWx0ZXJuYXJUcmF2YW1lbnRvRm9ybWEgPSB1c2VDYWxsYmFjaygoaWQ6IHN0cmluZykgPT4ge1xuICAgIHNldFNpbXVsYWNhbyhwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgZm9ybWFzUGFnYW1lbnRvOiBwcmV2LmZvcm1hc1BhZ2FtZW50by5tYXAoZm9ybWEgPT4gXG4gICAgICAgIGZvcm1hLmlkID09PSBpZCA/IHsgLi4uZm9ybWEsIHRyYXZhZG86ICFmb3JtYS50cmF2YWRvIH0gOiBmb3JtYVxuICAgICAgKVxuICAgIH0pKTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiB7XG4gICAgc2ltdWxhY2FvLFxuICAgIHJlY2FsY3VsYXJTaW11bGFjYW8sXG4gICAgYWRpY2lvbmFyRm9ybWEsXG4gICAgYXR1YWxpemFyRm9ybWEsXG4gICAgcmVtb3ZlckZvcm1hLFxuICAgIGxpbXBhckZvcm1hcyxcbiAgICBhbHRlcm5hclRyYXZhbWVudG8sXG4gICAgYWx0ZXJuYXJUcmF2YW1lbnRvRm9ybWEsXG4gICAgZWRpdGFyVmFsb3JOZWdvY2lhZG8sXG4gICAgZWRpdGFyVmFsb3JCcnV0byxcbiAgICBlZGl0YXJEZXNjb250b1JlYWxcbiAgfTtcbn07XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZU1lbW8iLCJ1c2VTaW11bGFkb3IiLCJzaW11bGFjYW8iLCJzZXRTaW11bGFjYW8iLCJ2YWxvckJydXRvIiwiZGVzY29udG8iLCJ2YWxvck5lZ29jaWFkbyIsImZvcm1hc1BhZ2FtZW50byIsInZhbG9yUmVjZWJpZG9Ub3RhbCIsImRlc2NvbnRvUmVhbCIsInZhbG9yUmVzdGFudGUiLCJ0cmF2YW1lbnRvcyIsImxpbWl0ZURlc2NvbnRvUmVhbCIsIlBSSU9SSURBREVfRk9STUFTIiwiY2FsY3VsYXJWYWxvclJlY2ViaWRvRm9ybWEiLCJmb3JtYSIsImNvbnNvbGUiLCJsb2ciLCJ0aXBvIiwidmFsb3IiLCJwYXJjZWxhcyIsInRheGFKdXJvcyIsImkiLCJ2YWxvclByZXNlbnRlIiwiTWF0aCIsInBvdyIsImRlZmxhY2FvIiwianVyb3NBbnRlY2lwYWNhbyIsImZhdG9yRGVmbGFjYW8iLCJmYXRvckp1cm9zIiwidmFsb3JSZWNlYmlkbyIsImN1c3RvQ2FwaXRhbCIsImljIiwidmFsb3JQcmVzZW50ZUJvbGV0byIsInJlZGlzdHJpYnVpclZhbG9yZXMiLCJub3ZvVmFsb3JOZWdvY2lhZG8iLCJmb3JtYXNBdHVhaXMiLCJzb21hQXR1YWwiLCJyZWR1Y2UiLCJhY2MiLCJkaWZlcmVuY2EiLCJhYnMiLCJmb3JtYXNUcmF2YWRhcyIsImZpbHRlciIsInRyYXZhZG8iLCJmb3JtYXNOYW9UcmF2YWRhcyIsImxlbmd0aCIsImZvcm1hc09yZGVuYWRhcyIsInNvcnQiLCJhIiwiYiIsInByaW9yaWRhZGVBIiwiaW5kZXhPZiIsInByaW9yaWRhZGVCIiwibWFwIiwiZiIsIm5vdmFzRm9ybWFzIiwic29tYUZvcm1hc05hb1RyYXZhZGFzIiwiYWp1c3RlUG9yRm9ybWEiLCJmb3JFYWNoIiwiZm9ybWFJbmRleCIsImZpbmRJbmRleCIsImlkIiwibm92b1ZhbG9yIiwibWF4IiwicHJpbWVpcmFGb3JtYSIsInZhbG9yQ2FsY3VsYWRvIiwicmVjYWxjdWxhclNpbXVsYWNhbyIsInVwZGF0ZXMiLCJwcmV2IiwidXBkYXRlZCIsImRlc2NvbnRvUmVhbEZpeG8iLCJ2YWxvckRlc2NvbnRvUmVhbEZpeG8iLCJ2YWxvclJlY2ViaWRvTmVjZXNzYXJpbyIsInVuZGVmaW5lZCIsInNvbWFGb3JtYXMiLCJlZGl0YXJWYWxvck5lZ29jaWFkbyIsImZvcm1hc1JlZGlzdHJpYnVpZGFzIiwiYWxlcnQiLCJlZGl0YXJEZXNjb250b1JlYWwiLCJub3ZvRGVzY29udG9SZWFsIiwic2hvdWxkTG9jayIsImNhbGN1bGFyRGVzY29udG9SZWFsUGFyYVZhbG9yIiwiZm9ybWFzVGVtcCIsInZhbG9yUmVjZWJpZG9UZW1wIiwiZm9ybWFDb21SZWNlYmlkbyIsInZhbG9yTWluIiwidmFsb3JNYXgiLCJ2YWxvck5lZ29jaWFkb090aW1vIiwibWVsaG9yRGlmZXJlbmNhIiwiSW5maW5pdHkiLCJtZWxob3JEZXNjb250byIsInZhbG9yVGVzdGUiLCJkZXNjb250b1JlYWxDYWxjdWxhZG8iLCJ0b0ZpeGVkIiwiY29uZmlybWFyIiwiY29uZmlybSIsImVkaXRhclZhbG9yQnJ1dG8iLCJhZGljaW9uYXJGb3JtYSIsIm5vdmFGb3JtYVRlbXAiLCJEYXRlIiwibm93IiwidG9TdHJpbmciLCJub3ZvVmFsb3JSZWNlYmlkb1RvdGFsIiwibm92YUZvcm1hIiwiYXR1YWxpemFyRm9ybWEiLCJkYWRvc0F0dWFsaXphZG9zIiwiZm9ybWFBdHVhbGl6YWRhIiwicmVtb3ZlckZvcm1hIiwibGltcGFyRm9ybWFzIiwiYWx0ZXJuYXJUcmF2YW1lbnRvIiwiYWx0ZXJuYXJUcmF2YW1lbnRvRm9ybWEiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useSimulador.ts\n"));

/***/ })

});